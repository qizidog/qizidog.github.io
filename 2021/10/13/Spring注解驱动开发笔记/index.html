

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/favicon.png">
  <link rel="icon" href="/img/favicon.png">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="description" content="本文重点关注Spring底层原理，包括基本文件及主启动类分析、Bean注入容器的多种方式总结、Bean拓展点总结、以及Bean生命周期整理，共4个部分。文中参考了众多资料，大都附有出处链接，个人仅做添砖加瓦工作，巩固学习而已。">
  <meta name="author" content="qizidog">
  <meta name="keywords" content="">
  <meta name="description" content="本文重点关注Spring底层原理，包括基本文件及主启动类分析、Bean注入容器的多种方式总结、Bean拓展点总结、以及Bean生命周期整理，共4个部分。文中参考了众多资料，大都附有出处链接，个人仅做添砖加瓦工作，巩固学习而已。">
<meta property="og:type" content="article">
<meta property="og:title" content="Spring注解驱动开发笔记">
<meta property="og:url" content="https://qizidog.github.io/2021/10/13/Spring%E6%B3%A8%E8%A7%A3%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0/index.html">
<meta property="og:site_name" content="qizidog小窝">
<meta property="og:description" content="本文重点关注Spring底层原理，包括基本文件及主启动类分析、Bean注入容器的多种方式总结、Bean拓展点总结、以及Bean生命周期整理，共4个部分。文中参考了众多资料，大都附有出处链接，个人仅做添砖加瓦工作，巩固学习而已。">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://qizidog.github.io/images/Spring%E6%B3%A8%E8%A7%A3%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0.assets/Snipaste_2021-10-13_16-37-28.png">
<meta property="og:image" content="https://qizidog.github.io/images/Spring%E6%B3%A8%E8%A7%A3%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0.assets/1595415587435.png">
<meta property="og:image" content="https://qizidog.github.io/images/Spring%E6%B3%A8%E8%A7%A3%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0.assets/1595493884773.png">
<meta property="og:image" content="https://qizidog.github.io/images/Spring%E6%B3%A8%E8%A7%A3%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0.assets/image-20201127220232413.png">
<meta property="og:image" content="https://qizidog.github.io/images/Spring%E6%B3%A8%E8%A7%A3%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0.assets/image-20210409173738495.png">
<meta property="article:published_time" content="2021-10-13T09:06:03.000Z">
<meta property="article:modified_time" content="2021-10-15T09:02:35.722Z">
<meta property="article:author" content="qizidog">
<meta property="article:tag" content="spring">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="https://qizidog.github.io/images/Spring%E6%B3%A8%E8%A7%A3%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0.assets/Snipaste_2021-10-13_16-37-28.png">
  
  <title>Spring注解驱动开发笔记 - qizidog小窝</title>

  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/css/bootstrap.min.css" />


  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/github-markdown-css@4/github-markdown.min.css" />
  <link  rel="stylesheet" href="/lib/hint/hint.min.css" />

  
    
    
      
      <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@10/styles/github-gist.min.css" />
    
  

  
    <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3/dist/jquery.fancybox.min.css" />
  


<!-- 主题依赖的图标库，不要自行修改 -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_ba1fz6golrf.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_kmeydafke9r.css">


<link  rel="stylesheet" href="/css/main.css" />

<!-- 自定义样式保持在最底部 -->


  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    var CONFIG = {"hostname":"qizidog.github.io","root":"/","version":"1.8.12","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"right","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"copy_btn":true,"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":true,"baidu":null,"google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname"}},"search_path":"/local-search.xml"};
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
<meta name="generator" content="Hexo 5.4.0"></head>


<body>
  <header style="height: 70vh;">
    <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>qizidog小窝</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                首页
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                归档
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                分类
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                标签
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                关于
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              &nbsp;<i class="iconfont icon-search"></i>&nbsp;
            </a>
          </li>
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">&nbsp;<i
                class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

    <div class="banner" id="banner" parallax=true
         style="background: url('/images/post.png') no-repeat center center;
           background-size: cover;">
      <div class="full-bg-img">
        <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
          <div class="page-header text-center fade-in-up">
            <span class="h2" id="subtitle" title="Spring注解驱动开发笔记">
              
            </span>

            
              <div class="mt-3">
  
  
    <span class="post-meta">
      <i class="iconfont icon-date-fill" aria-hidden="true"></i>
      <time datetime="2021-10-13 17:06" pubdate>
        2021年10月13日 下午
      </time>
    </span>
  
</div>

<div class="mt-1">
  
    <span class="post-meta mr-2">
      <i class="iconfont icon-chart"></i>
      44k 字
    </span>
  

  
    <span class="post-meta mr-2">
      <i class="iconfont icon-clock-fill"></i>
      
      
      137 分钟
    </span>
  

  
  
</div>

            
          </div>

          
        </div>
      </div>
    </div>
  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="d-none d-lg-block col-lg-2"></div>
    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div class="py-5" id="board">
          <article class="post-content mx-auto">
            <!-- SEO header -->
            <h1 style="display: none">Spring注解驱动开发笔记</h1>
            
            <div class="markdown-body">
              <h1 id="Spring注解驱动开发笔记"><a href="#Spring注解驱动开发笔记" class="headerlink" title="Spring注解驱动开发笔记"></a>Spring注解驱动开发笔记</h1><h2 id="1-一切的起点"><a href="#1-一切的起点" class="headerlink" title="1 一切的起点"></a>1 一切的起点</h2><h3 id="1-1-pom父依赖"><a href="#1-1-pom父依赖" class="headerlink" title="1.1 pom父依赖"></a>1.1 pom父依赖</h3><blockquote>
<p><strong>pom.xml</strong></p>
</blockquote>
<ul>
<li>spring-boot-dependencies：核心依赖在父工程中</li>
<li>我们在写或者引入一些Springboot依赖的时候，不需要指定版本，就因为有这些版本仓库</li>
</ul>
<p>1、其中它主要是依赖一个父项目，主要是管理项目的资源过滤及插件</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">parent</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-parent<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.3.1.RELEASE<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">relativePath</span>/&gt;</span> <br>    <span class="hljs-comment">&lt;!-- lookup parent from repository --&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">parent</span>&gt;</span><br></code></pre></td></tr></table></figure>

<p>2、点进去，发现还有一个父依赖</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">parent</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-dependencies<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.3.1.RELEASE<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">parent</span>&gt;</span><br></code></pre></td></tr></table></figure>

<p>3、这里才是真正管理SpringBoot应用里面所有依赖版本的地方，SpringBoot的版本控制中心；</p>
<p><strong>4、以后我们导入依赖默认是不需要写版本；但是如果导入的包没有在依赖中管理着就需要手动配置版本了；</strong></p>
<h3 id="1-2-spring-boot-starter"><a href="#1-2-spring-boot-starter" class="headerlink" title="1.2 spring-boot-starter"></a>1.2 spring-boot-starter</h3><ul>
<li><p>依赖</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>	<span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure></li>
<li><p><strong>springboot-boot-starter-xxx</strong>，说白了就是Springboot的启动场景</p>
</li>
<li><p>比如<strong>spring-boot-starter-web</strong>，他就会帮我们自动导入web的所有依赖</p>
</li>
<li><p>springboot会将所有的功能场景，都变成一个个的启动器</p>
</li>
<li><p>我们要使用什么功能，就只需要找到对应的启动器就好了<code>start</code></p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://docs.spring.io/spring-boot/docs/current/reference/html/using-spring-boot.html#using-boot-starter">官方的所有starter</a></p>
</li>
</ul>
<h3 id="1-3-SpringBootApplication"><a href="#1-3-SpringBootApplication" class="headerlink" title="1.3 @SpringBootApplication"></a>1.3 @SpringBootApplication</h3><blockquote>
<h4 id="默认的主启动类"><a href="#默认的主启动类" class="headerlink" title="默认的主启动类"></a>默认的主启动类</h4></blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//@SpringBootApplication 来标注一个主程序类</span><br><span class="hljs-comment">//说明这是一个Spring Boot应用</span><br><span class="hljs-meta">@SpringBootApplication</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SpringbootApplication</span> </span>&#123;<br>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>     <span class="hljs-comment">//以为是启动了一个方法，没想到启动了一个服务</span><br>      SpringApplication.run(SpringbootApplication.class, args);<br>   &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>但是，一个简单的启动类并不简单，我们来分析一下这些注解都干了什么。</p>
<blockquote>
<h4 id="拆分注解（-SpringBootApplication）"><a href="#拆分注解（-SpringBootApplication）" class="headerlink" title="拆分注解（@SpringBootApplication）"></a>拆分注解（@SpringBootApplication）</h4></blockquote>
<p><img src="/images/Spring%E6%B3%A8%E8%A7%A3%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0.assets/Snipaste_2021-10-13_16-37-28.png" srcset="/img/loading.gif" lazyload></p>
<ul>
<li><p>作用：标注在某个类上说明这个类是SpringBoot的主配置；</p>
</li>
<li><p>SpringBoot就应该运行这个类的main方法来启动SpringBoot应用；</p>
</li>
<li><p>进入这个注解：可以看到上面还有很多其他注解</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@SpringBootConfiguration</span><br><span class="hljs-meta">@EnableAutoConfiguration</span><br><span class="hljs-meta">@ComponentScan(</span><br><span class="hljs-meta">    excludeFilters = &#123;</span><br><span class="hljs-meta">        @Filter(type = FilterType.CUSTOM, classes = &#123;TypeExcludeFilter.class&#125;), </span><br><span class="hljs-meta">        @Filter(type = FilterType.CUSTOM, classes = &#123;AutoConfigurationExcludeFilter.class&#125;)</span><br><span class="hljs-meta">    &#125;</span><br><span class="hljs-meta">)</span><br><span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> SpringBootApplication &#123;<br>    <span class="hljs-comment">// ......</span><br>&#125;<br></code></pre></td></tr></table></figure></li>
</ul>
<p>==<strong>@ComponentScan</strong>==</p>
<ul>
<li>这个注解在Spring中很重要，它对应XML配置中的元素。</li>
<li>作用：自动扫描并加载符合条件的组件或者bean，将这个bean定义加载到IOC容器中。</li>
</ul>
<p>==<strong>@SpringBootConfiguration</strong>==</p>
<ul>
<li><p>作用：SpringBoot的配置类，标注在某个类上，表示这是一个SpringBoot的配置类；</p>
</li>
<li><p>我们继续进去这个注解查看</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 点进去得到下面的 @Component</span><br><span class="hljs-meta">@Configuration</span><br><span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> SpringBootConfiguration &#123;&#125;<br><br><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> Configuration &#123;&#125;<br></code></pre></td></tr></table></figure></li>
<li><p>这里的 <strong>@Configuration</strong>，说明这是一个spring的配置类，配置类就是对应Spring的xml 配置文件；</p>
</li>
<li><p><strong>@Component</strong> 这就说明，启动类本身也是Spring中的一个组件而已，负责启动应用</p>
</li>
<li><p>我们回到 SpringBootApplication 注解中继续看。</p>
</li>
</ul>
<p>==<strong>@EnableAutoConfiguration</strong>==</p>
<ul>
<li><p><strong>开启自动配置功能</strong></p>
<ul>
<li><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@AutoConfigurationPackage</span><br><span class="hljs-meta">@Import(&#123;AutoConfigurationImportSelector.class&#125;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> EnableAutoConfiguration &#123;<br>    <span class="hljs-comment">// ......</span><br>&#125;<br></code></pre></td></tr></table></figure></li>
<li><p>以前我们需要自己配置的东西，而现在SpringBoot可以自动帮我们配置；</p>
</li>
<li><p>@EnableAutoConfiguration告诉SpringBoot开启自动配置功能，这样自动配置才能生效；</p>
</li>
</ul>
<p>点进注解接续查看：</p>
</li>
<li><p><strong>@AutoConfigurationPackage ：自动配置包</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Import(&#123;Registrar.class&#125;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> AutoConfigurationPackage &#123;<br>&#125;<br></code></pre></td></tr></table></figure>

<ul>
<li><strong>@import</strong>：Spring底层注解@import，给容器中导入一个组件</li>
<li><strong>Registrar.class</strong> 作用：实现了ImportBeanDefinitionRegistrar接口，自动配置包注册，将主启动类的所在包及包下面所有子包里面的所有组件扫描到Spring容器 ；</li>
<li>这个分析完了，退到上一步，继续看</li>
</ul>
</li>
<li><p><strong>@Import({AutoConfigurationImportSelector.class}) ：给容器导入组件 ；</strong></p>
<ul>
<li><strong>AutoConfigurationImportSelector</strong>：自动配置导入选择器，那么它会导入哪些组件的选择器呢？我们点击去这个类看源码：</li>
</ul>
</li>
<li><p>获取所有的配置：==List&lt;String&gt; configurations = this.getCandidateConfigurations(annotationMetadata, attributes);==</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">protected</span> List&lt;String&gt; <span class="hljs-title">getCandidateConfigurations</span><span class="hljs-params">(AnnotationMetadata metadata, AnnotationAttributes attributes)</span> </span>&#123;<br>    <span class="hljs-comment">// 和下面的方法对应</span><br>    List&lt;String&gt; configurations = SpringFactoriesLoader.loadFactoryNames(<span class="hljs-keyword">this</span>.getSpringFactoriesLoaderFactoryClass(), <span class="hljs-keyword">this</span>.getBeanClassLoader());<br><br>    Assert.notEmpty(configurations, <span class="hljs-string">&quot;No auto configuration classes found in META-INF/spring.factories. If you are using a custom packaging, make sure that file is correct.&quot;</span>);<br>    <span class="hljs-keyword">return</span> configurations;<br>&#125;<br><br><span class="hljs-comment">//  这里的getSpringFactoriesLoaderFactoryClass()方法</span><br><span class="hljs-comment">//  和上面的类的方法loadFactoryNames里面的第一个参数对应</span><br><span class="hljs-comment">//  返回的就是我们最开始看的启动自动导入配置文件的注解类；EnableAutoConfiguration</span><br><span class="hljs-keyword">protected</span> Class&lt;?&gt; getSpringFactoriesLoaderFactoryClass() &#123;<br>    <span class="hljs-keyword">return</span> EnableAutoConfiguration.class;<br>&#125;<br></code></pre></td></tr></table></figure></li>
<li><p>这个方法<code>getCandidateConfigurations()</code>又调用了 <code>SpringFactoriesLoader</code> 类的<code>loadFactoryNames</code>静态方法，我们进入<code>SpringFactoriesLoader</code>类loadFactoryNames() 方法，获取所有的加载配置</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> List&lt;String&gt; <span class="hljs-title">loadFactoryNames</span><span class="hljs-params">(Class&lt;?&gt; factoryClass, <span class="hljs-meta">@Nullable</span> ClassLoader classLoader)</span> </span>&#123;<br>    String factoryClassName = factoryClass.getName();<br>    <span class="hljs-comment">//这里它又调用了 loadSpringFactories 方法</span><br>    <span class="hljs-keyword">return</span> (List)loadSpringFactories(classLoader).getOrDefault(factoryClassName, Collections.emptyList());<br>&#125;<br></code></pre></td></tr></table></figure></li>
<li><p>我们继续点击查看 loadSpringFactories 方法</p>
<ul>
<li><p>项目资源：<code>META-INF/spring.factories</code></p>
</li>
<li><p>系统资源：<code>META-INF/spring.factories</code></p>
</li>
<li><p>从这些资源中配置了所有的nextElement（自动配置），封装成properties</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//将所有的资源加载到配置类中（将下面的抽离出来分析，第15行）</span><br>Properties properties = PropertiesLoaderUtils.loadProperties(resource);<br></code></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Map&lt;String, List&lt;String&gt;&gt; loadSpringFactories(<span class="hljs-meta">@Nullable</span> ClassLoader classLoader) &#123;<br>    <span class="hljs-comment">//获得classLoader，我们返回可以看到这里得到的就是EnableAutoConfiguration标注的类本身</span><br>    MultiValueMap&lt;String, String&gt; result = (MultiValueMap)cache.get(classLoader);<br>    <span class="hljs-keyword">if</span> (result != <span class="hljs-keyword">null</span>) &#123;<br>        <span class="hljs-keyword">return</span> result;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-comment">//去获取一个资源 &quot;META-INF/spring.factories&quot;</span><br>            Enumeration&lt;URL&gt; urls = classLoader != <span class="hljs-keyword">null</span> ? classLoader.getResources(<span class="hljs-string">&quot;META-INF/spring.factories&quot;</span>) : ClassLoader.getSystemResources(<span class="hljs-string">&quot;META-INF/spring.factories&quot;</span>);<br>            LinkedMultiValueMap result = <span class="hljs-keyword">new</span> LinkedMultiValueMap();<br>            <span class="hljs-comment">//判断有没有更多的元素，将读取到的资源循环遍历，封装成为一个Properties</span><br>            <span class="hljs-keyword">while</span>(urls.hasMoreElements()) &#123;<br>                URL url = (URL)urls.nextElement();<br>                UrlResource resource = <span class="hljs-keyword">new</span> UrlResource(url);<br>                Properties properties = PropertiesLoaderUtils.loadProperties(resource);<br>                Iterator var6 = properties.entrySet().iterator();<br>                <span class="hljs-keyword">while</span>(var6.hasNext()) &#123;<br>                    Entry&lt;?, ?&gt; entry = (Entry)var6.next();<br>                    String factoryClassName = ((String)entry.getKey()).trim();<br>                    String[] var9 = StringUtils.commaDelimitedListToStringArray((String)entry.getValue());<br>                    <span class="hljs-keyword">int</span> var10 = var9.length;<br>                    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> var11 = <span class="hljs-number">0</span>; var11 &lt; var10; ++var11) &#123;<br>                        String factoryName = var9[var11];<br>                        result.add(factoryClassName, factoryName.trim());<br>                    &#125;<br>                &#125;<br>            &#125;<br>            cache.put(classLoader, result);<br>            <span class="hljs-keyword">return</span> result;<br>        &#125; <span class="hljs-keyword">catch</span> (IOException var13) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalArgumentException(<span class="hljs-string">&quot;Unable to load factories from location [META-INF/spring.factories]&quot;</span>, var13);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li>
<li><p>发现一个多次出现的文件：spring.factories，全局搜索它</p>
</li>
</ul>
</li>
</ul>
<blockquote>
<h4 id="spring-factories"><a href="#spring-factories" class="headerlink" title="spring.factories"></a><strong>spring.factories</strong></h4></blockquote>
<p>我们根据源头打开spring.factories，看到了很多自动配置的文件；这就是自动配置根源所在。</p>
<p><img src="/images/Spring%E6%B3%A8%E8%A7%A3%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0.assets/1595415587435.png" srcset="/img/loading.gif" lazyload alt="1595415587435"></p>
<p>每一个这样的 xxxAutoConfiguration类都是容器中的一个<strong>组件，都加入到容器中；用他们来做自动配置；</strong></p>
<blockquote>
<h4 id="案例说明"><a href="#案例说明" class="headerlink" title="案例说明"></a><strong>案例说明</strong></h4></blockquote>
<p>我们以<strong>HttpEncodingAutoConfiguration（Http编码自动配置）</strong>为例解释自动配置原理；</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//表示这是一个配置类，和以前编写的配置文件一样，也可以给容器中添加组件；</span><br><span class="hljs-meta">@Configuration</span> <br><br><span class="hljs-comment">//启动指定类的ConfigurationProperties功能；</span><br><span class="hljs-comment">//进入这个HttpProperties查看，将配置文件中对应的值和HttpProperties绑定起来；</span><br><span class="hljs-comment">//并把HttpProperties加入到ioc容器中</span><br><span class="hljs-meta">@EnableConfigurationProperties(&#123;HttpProperties.class&#125;)</span> <br><br><span class="hljs-comment">//Spring底层@Conditional注解</span><br>  <span class="hljs-comment">//根据不同的条件判断，如果满足指定的条件，整个配置类里面的配置就会生效；</span><br>  <span class="hljs-comment">//这里的意思就是判断当前应用是否是web应用，如果是，当前配置类生效</span><br><span class="hljs-meta">@ConditionalOnWebApplication(</span><br><span class="hljs-meta">    type = Type.SERVLET</span><br><span class="hljs-meta">)</span><br><br><span class="hljs-comment">//判断当前项目有没有这个类CharacterEncodingFilter；SpringMVC中进行乱码解决的过滤器；</span><br><span class="hljs-meta">@ConditionalOnClass(&#123;CharacterEncodingFilter.class&#125;)</span><br><br><span class="hljs-comment">//判断配置文件中是否存在某个配置：spring.http.encoding.enabled；</span><br><span class="hljs-comment">//如果不存在，判断也是成立的</span><br><span class="hljs-comment">//即使我们配置文件中不配置pring.http.encoding.enabled=true，也是默认生效的；</span><br><span class="hljs-meta">@ConditionalOnProperty(</span><br><span class="hljs-meta">    prefix = &quot;spring.http.encoding&quot;,</span><br><span class="hljs-meta">    value = &#123;&quot;enabled&quot;&#125;,</span><br><span class="hljs-meta">    matchIfMissing = true</span><br><span class="hljs-meta">)</span><br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HttpEncodingAutoConfiguration</span> </span>&#123;<br>    <span class="hljs-comment">//他已经和SpringBoot的配置文件映射了</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Encoding properties;<br>    <span class="hljs-comment">//只有一个有参构造器的情况下，参数的值就会从容器中拿</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">HttpEncodingAutoConfiguration</span><span class="hljs-params">(HttpProperties properties)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.properties = properties.getEncoding();<br>    &#125;<br><br>    <span class="hljs-comment">//给容器中添加一个组件，这个组件的某些值需要从properties中获取</span><br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-meta">@ConditionalOnMissingBean</span> <span class="hljs-comment">//判断容器没有这个组件？</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> CharacterEncodingFilter <span class="hljs-title">characterEncodingFilter</span><span class="hljs-params">()</span> </span>&#123;<br>        CharacterEncodingFilter filter = <span class="hljs-keyword">new</span> OrderedCharacterEncodingFilter();<br>        filter.setEncoding(<span class="hljs-keyword">this</span>.properties.getCharset().name());<br>    filter.setForceRequestEncoding(<span class="hljs-keyword">this</span>.properties.shouldForce(org.springframework.boot.autoconfigure.http.HttpProperties.Encoding.Type.REQUEST));<br>        filter.setForceResponseEncoding(<span class="hljs-keyword">this</span>.properties.shouldForce(org.springframework.boot.autoconfigure.http.HttpProperties.Encoding.Type.RESPONSE));<br>        <span class="hljs-keyword">return</span> filter;<br>    &#125;<br>    <span class="hljs-comment">//。。。。。。。</span><br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>一句话总结 ：根据当前不同的条件判断，决定这个配置类是否生效</strong></p>
<ul>
<li><p>一但这个配置类生效；这个配置类就会给容器中添加各种组件；</p>
</li>
<li><p>这些组件的属性是从对应的properties类中获取的，这些类里面的每一个属性又是和配置文件绑定的；</p>
</li>
<li><p>所有在配置文件中能配置的属性都是在xxxxProperties类中封装着；</p>
</li>
<li><p>配置文件能配置什么就可以参照某个功能对应的这个属性类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//从配置文件中获取指定的值和bean的属性进行绑定</span><br><span class="hljs-meta">@ConfigurationProperties(prefix = &quot;spring.http&quot;)</span> <br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HttpProperties</span> </span>&#123;<br>    <span class="hljs-comment">// .....</span><br>&#125;<br></code></pre></td></tr></table></figure></li>
</ul>
<p>我们去配置文件里面试试前缀，看提示</p>
<p><img src="/images/Spring%E6%B3%A8%E8%A7%A3%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0.assets/1595493884773.png" srcset="/img/loading.gif" lazyload alt="1595493884773"></p>
<p>所以，自动配置真正实现是从classpath中搜寻所有的<code>META-INF/spring.factories</code>配置文件，并将其中对应的 <code>org.springframework.boot.autoconfigure</code>. 包下的配置项，通过反射实例化为对应标注了<code> @Configuration的JavaConfig</code>形式的IOC容器配置类，然后将这些都汇总成为一个实例并加载到IOC容器中。</p>
<p><strong>结论</strong></p>
<ol>
<li>SpringBoot在启动的时候从类路径下的<code>META-INF/spring.factories</code>中获取<code>EnableAutoConfiguration</code>指定的值</li>
<li>将这些值作为自动配置类导入容器，自动配置类就生效，帮我们进行自动配置工作；</li>
<li>以前我们需要自动配置的东西，现在springboot帮我们做了</li>
<li>整合JavaEE，整体解决方案和自动配置的东西都在<code>springboot-autoconfigure</code>的jar包中；</li>
<li>它会把所有需要导入的组件，以类名的方式返回，这些组件就会被添加到容器中</li>
<li>它会给容器中导入非常多的自动配置类 （xxxAutoConfiguration）, 就是给容器中导入这个场景需要的所有组件，并自动配置xxxProperties；</li>
<li>有了自动配置类，免去了我们手动编写配置注入功能组件等的工作；</li>
<li>springboot配置文件到底能写什么？怎么写？有两种查看方式：<ul>
<li><a target="_blank" rel="noopener" href="https://docs.spring.io/spring-boot/docs/2.3.1.RELEASE/reference/html/appendix-application-properties.html#core-properties">官网配置详解</a></li>
<li>找到对应的xxxProperties类，查看源码</li>
</ul>
</li>
</ol>
<h3 id="1-4-main方法"><a href="#1-4-main方法" class="headerlink" title="1.4 main方法"></a>1.4 main方法</h3><p><strong><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV19K4y1L7MT?p=84">视频教程</a></strong> </p>
<p>SpringApplication.run方法主要分两部分，一是SpringApplication的实例化，二是run方法的执行。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@SpringBootApplication</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Springboot01HellowordApplication</span> </span>&#123;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>       	<span class="hljs-comment">// 该方法返回一个ConfigurableApplicationContext对象</span><br> 		<span class="hljs-comment">// 参数一：应用入口的类； 参数二：命令行参数  </span><br>        SpringApplication.run(Springboot01HellowordApplication.class, args);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>整体流程：</strong></p>
<ul>
<li><p>创建 <strong>SpringApplication</strong></p>
</li>
<li><ul>
<li>保存一些信息。</li>
<li>判定当前应用的类型。ClassUtils。Servlet</li>
</ul>
</li>
<li><ul>
<li>==bootstrappers==：<strong>初始启动引导器</strong>（<code>List&lt;Bootstrapper&gt;</code>）：去<strong>spring.factories</strong>文件中找org.springframework.boot.==Bootstrapper==</li>
<li>找 ==ApplicationContextInitializer==；去<strong>spring.factories</strong> 找 <strong>==ApplicationContextInitializer==</strong></li>
</ul>
</li>
<li><ul>
<li><ul>
<li>List&lt;ApplicationContextInitializer&lt;?&gt;&gt; <strong>initializers</strong></li>
</ul>
</li>
</ul>
</li>
<li><ul>
<li><strong>找</strong> ==ApplicationListener== 应用监听器。去<strong>spring.factories</strong> 找 <strong>==ApplicationListener==</strong></li>
</ul>
</li>
<li><ul>
<li><ul>
<li>List&lt;ApplicationListener&lt;?&gt;&gt; <strong>listeners</strong></li>
</ul>
</li>
</ul>
</li>
<li><p>运行 <strong>SpringApplication</strong></p>
</li>
<li><ul>
<li><strong>StopWatch</strong></li>
<li><strong>记录应用的启动时间</strong></li>
</ul>
</li>
<li><ul>
<li><strong>创建引导上下文（Context环境）createBootstrapContext()</strong></li>
</ul>
</li>
<li><ul>
<li><ul>
<li>获取到所有之前的 ==bootstrappers==挨个执行 intitialize() 来完成对引导启动器上下文环境设置</li>
</ul>
</li>
</ul>
</li>
<li><ul>
<li>让当前应用进入<strong>headless</strong>模式。<strong>java.awt.headless</strong></li>
<li><strong>获取所有</strong> ==RunListener==（运行监听器）【为了方便所有Listener进行事件感知】</li>
</ul>
</li>
<li><ul>
<li><ul>
<li>getSpringFactoriesInstances 去<strong>spring.factories</strong> 找 ==<strong>SpringApplicationRunListener</strong>==</li>
</ul>
</li>
</ul>
</li>
<li><ul>
<li>遍历 <strong>SpringApplicationRunListener</strong> 调用 starting 方法；</li>
</ul>
</li>
<li><ul>
<li><ul>
<li>==相当于通知所有感兴趣系统正在启动过程的人，项目正在 starting。==</li>
</ul>
</li>
</ul>
</li>
<li><ul>
<li>保存命令行参数；ApplicationArguments</li>
<li>准备环境 prepareEnvironment（）;</li>
</ul>
</li>
<li><ul>
<li><ul>
<li>返回或者创建基础环境信息对象。<strong>StandardServletEnvironment</strong></li>
<li><strong>配置环境信息对象。</strong></li>
</ul>
</li>
</ul>
</li>
<li><ul>
<li><ul>
<li><ul>
<li><strong>读取所有的配置源的配置属性值。</strong></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><ul>
<li><ul>
<li>绑定环境信息</li>
<li>监听器调用 listener.environmentPrepared()；通知所有的监听器当前环境准备完成</li>
</ul>
</li>
</ul>
</li>
<li><ul>
<li>创建IOC容器（createApplicationContext（））</li>
</ul>
</li>
<li><ul>
<li><ul>
<li>根据项目类型（Servlet）创建容器，</li>
<li>当前会创建 <strong>AnnotationConfigServletWebServerApplicationContext</strong></li>
</ul>
</li>
</ul>
</li>
<li><ul>
<li><strong>准备ApplicationContext IOC容器的基本信息</strong>  <strong>prepareContext()</strong></li>
</ul>
</li>
<li><ul>
<li><ul>
<li>保存环境信息</li>
<li>IOC容器的后置处理流程。</li>
</ul>
</li>
</ul>
</li>
<li><ul>
<li><ul>
<li>应用初始化器；applyInitializers；</li>
</ul>
</li>
</ul>
</li>
<li><ul>
<li><ul>
<li><ul>
<li>遍历所有的 ==ApplicationContextInitializer== 。调用 <strong>initialize.。来对ioc容器进行初始化扩展功能</strong></li>
<li>遍历所有的 listener 调用 <strong>contextPrepared</strong>。EventPublishRunListenr；通知所有的监听器<strong>contextPrepared</strong></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><ul>
<li><ul>
<li><strong>所有的监听器 调用</strong> <strong>contextLoaded。通知所有的监听器</strong> <strong>contextLoaded；</strong></li>
</ul>
</li>
</ul>
</li>
<li><ul>
<li><strong>刷新IOC容器。</strong>refreshContext</li>
</ul>
</li>
<li><ul>
<li><ul>
<li>创建容器中的所有组件（参见Bean的完整生命周期）</li>
</ul>
</li>
</ul>
</li>
<li><ul>
<li>容器刷新完成后工作？afterRefresh</li>
<li>所有监听 器 调用 listeners.<strong>started</strong>(context); <strong>通知所有的监听器</strong> <strong>started</strong></li>
</ul>
</li>
<li><ul>
<li><strong>调用所有runners；</strong>callRunners()</li>
</ul>
</li>
<li><ul>
<li><ul>
<li><strong>获取容器中的</strong> <strong>==ApplicationRunner==</strong> </li>
<li><strong>获取容器中的</strong> <strong>==CommandLineRunner==</strong></li>
</ul>
</li>
</ul>
</li>
<li><ul>
<li><ul>
<li><strong>合并所有runner并且按照@Order进行排序</strong></li>
<li><strong>遍历所有的runner。调用 run</strong> <strong>方法</strong></li>
</ul>
</li>
</ul>
</li>
<li><ul>
<li><strong>如果以上有异常，</strong></li>
</ul>
</li>
<li><ul>
<li><ul>
<li><strong>调用Listener 的 failed</strong></li>
</ul>
</li>
</ul>
</li>
<li><ul>
<li><strong>调用所有监听器的 running 方法</strong>  listeners.running(context); <strong>通知所有的监听器</strong> <strong>running</strong> </li>
<li><strong>running如果有问题。继续通知 failed 。调用所有 Listener 的 failed；通知所有的监听器 failed</strong></li>
</ul>
</li>
</ul>
<p><img src="/images/Spring%E6%B3%A8%E8%A7%A3%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0.assets/image-20201127220232413.png" srcset="/img/loading.gif" lazyload alt="image-20201127220232413"></p>
<h2 id="2-Bean对象注入容器"><a href="#2-Bean对象注入容器" class="headerlink" title="2 Bean对象注入容器"></a>2 Bean对象注入容器</h2><p>在SpringBoot中将对象注入到容器中有多种方法。</p>
<h3 id="2-1-ComponentScan"><a href="#2-1-ComponentScan" class="headerlink" title="2.1 @ComponentScan"></a>2.1 @ComponentScan</h3><p>通过@ComponentScan自动扫包+组件标注注解（@Component/@Controller/@Service/@Repository）实现。</p>
<p>@ComponentScan可以指定include/exclude某些类，具体的规则通过@Filter参数指定。在Java8中@ComponentScan可以重复标记。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@ComponentScan(value=&quot;com.meimeixia&quot;, includeFilters=&#123;</span><br><span class="hljs-meta">   /* type：指定你要排除的规则，是按照注解进行排除，还是按照给定的类型进行排除，还是按照正则表达式进行排除，等等</span><br><span class="hljs-meta">	* classes：我们需要Spring在扫描时，只包含@Controller注解标注的类</span><br><span class="hljs-meta">	*/</span><br><span class="hljs-meta">    @Filter(type=FilterType.ANNOTATION, classes=&#123;Controller.class&#125;)</span><br><span class="hljs-meta">&#125;, useDefaultFilters=false)</span> <span class="hljs-comment">// value指定要扫描的包</span><br><span class="hljs-meta">@ComponentScan(value=&quot;com.meimeixia&quot;, includeFilters=&#123;</span><br><span class="hljs-meta">   /* type：指定你要排除的规则，是按照注解进行排除，还是按照给定的类型进行排除，还是按照正则表达式进行排除，等等</span><br><span class="hljs-meta">	* classes：我们需要Spring在扫描时，只包含@Service注解标注的类</span><br><span class="hljs-meta">	*/</span><br><span class="hljs-meta">    @Filter(type=FilterType.ANNOTATION, classes=&#123;Service.class&#125;)</span><br><span class="hljs-meta">&#125;, useDefaultFilters=false)</span> <span class="hljs-comment">// value指定要扫描的包</span><br></code></pre></td></tr></table></figure>

<p>如果不是Java8，但又需要设置多个条件，可以使用如下方式：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@ComponentScans(value=&#123;</span><br><span class="hljs-meta">    @ComponentScan(value=&quot;com.meimeixia&quot;, includeFilters=&#123;</span><br><span class="hljs-meta">       /* type：指定你要排除的规则，是按照注解进行排除，还是按照给定的类型进行排除，还是按照正则表达式进行排除，等等</span><br><span class="hljs-meta">		* classes：我们需要Spring在扫描时，只包含@Controller注解标注的类</span><br><span class="hljs-meta">		*/</span><br><span class="hljs-meta">        @Filter(type=FilterType.ANNOTATION, classes=&#123;Controller.class&#125;)</span><br><span class="hljs-meta">    &#125;, useDefaultFilters=false), // value指定要扫描的包</span><br><span class="hljs-meta">    @ComponentScan(value=&quot;com.meimeixia&quot;, includeFilters=&#123;</span><br><span class="hljs-meta">       /* type：指定你要排除的规则，是按照注解进行排除，还是按照给定的类型进行排除，还是按照正则表达式进行排除，等等</span><br><span class="hljs-meta">		* classes：我们需要Spring在扫描时，只包含@Service注解标注的类</span><br><span class="hljs-meta">		*/</span><br><span class="hljs-meta">        @Filter(type=FilterType.ANNOTATION, classes=&#123;Service.class&#125;)</span><br><span class="hljs-meta">    &#125;, useDefaultFilters=false) // value指定要扫描的包</span><br><span class="hljs-meta">&#125;)</span><br></code></pre></td></tr></table></figure>

<p>这种注入方式只适用于自己写的类，对于自己写的类，可以在类上面加上组件标注注解，但是对于引用的别人的类，该方法就无法使用。</p>
<p><strong>@Filter使用进阶</strong></p>
<p>Filter支持以下5种类型：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">FilterType</span> </span>&#123;<br>    <span class="hljs-comment">// 被标记注解的类型、类的class类型、ASPECTJ表达式、正则表达式、自定义类型</span><br>    ANNOTATION, ASSIGNABLE_TYPE, ASPECTJ, REGEX, CUSTOM;<br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">FilterType</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-comment">/* compiled code */</span> &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>前两种类型很好理解，重点讲CUSTOM类型的用法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@ComponentScan(value=&quot;com.meimeixia&quot;, includeFilters=&#123;</span><br><span class="hljs-meta">   /*</span><br><span class="hljs-meta">	* type：指定你要排除的规则，是按照注解进行排除，还是按照给定的类型进行排除，还是按照正则表达式进行排除，等等</span><br><span class="hljs-meta">	*/</span><br><span class="hljs-meta">   // 指定新的过滤规则，这个过滤规则是我们自个自定义的，过滤规则就是由我们这个自定义的MyTypeFilter类返回true或者false来代表匹配还是没匹配</span><br><span class="hljs-meta">	@Filter(type=FilterType.CUSTOM, classes=&#123;MyTypeFilter.class&#125;)</span><br><span class="hljs-meta">&#125;, useDefaultFilters=false)</span>  <span class="hljs-comment">// value指定要扫描的包</span><br></code></pre></td></tr></table></figure>

<p>自定义过滤规则类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyTypeFilter</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">TypeFilter</span> </span>&#123;<br>	<span class="hljs-comment">/**</span><br><span class="hljs-comment">	 * 参数：</span><br><span class="hljs-comment">	 * metadataReader：读取到的当前正在扫描的类的信息</span><br><span class="hljs-comment">	 * metadataReaderFactory：可以获取到其他任何类的信息的（工厂）</span><br><span class="hljs-comment">	 */</span><br>	<span class="hljs-meta">@Override</span><br>	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">match</span><span class="hljs-params">(MetadataReader metadataReader, MetadataReaderFactory metadataReaderFactory)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>		<span class="hljs-comment">// 获取当前类注解的信息</span><br>		AnnotationMetadata annotationMetadata = metadataReader.getAnnotationMetadata();<br>		<span class="hljs-comment">// 获取当前正在扫描的类的类信息，比如说它的类型是什么啊，它实现了什么接口啊之类的</span><br>		ClassMetadata classMetadata = metadataReader.getClassMetadata();<br>		<span class="hljs-comment">// 获取当前类的资源信息，比如说类的路径等信息</span><br>		Resource resource = metadataReader.getResource();<br>		<span class="hljs-comment">// 获取当前正在扫描的类的类名</span><br>		String className = classMetadata.getClassName();<br>		System.out.println(<span class="hljs-string">&quot;---&gt;&quot;</span> + className);<br>		<span class="hljs-comment">// 现在来指定一个规则</span><br>		<span class="hljs-keyword">if</span> (className.contains(<span class="hljs-string">&quot;er&quot;</span>)) &#123;<br>			<span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>; <span class="hljs-comment">// 只要类名包含“er”，就会被包含在容器中（无需被@Component标注）</span><br>		&#125;<br>		<span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>	&#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="2-2-Bean"><a href="#2-2-Bean" class="headerlink" title="2.2 @Bean"></a>2.2 @Bean</h3><p>使用@Configuration和@Bean注解，手动构建对象，并把它注入到容器中去。被@Configuration标记的配置类相当于Spring中的<code>bean.xml</code>文件，@Bean则相当于<code>&lt;bean&gt;</code>标签。</p>
<p>使用这种方式，被@Configuration标记的配置类也会被注入到容器中去。</p>
<ul>
<li>用@Bean给容器中添加组件，<strong>方法名</strong>就是组件的id，返回类型就是组件类型，返回值就是组件在容器中的实例。</li>
<li>被@Configuration标记的配置类的id就是该配置类的类名（首字母自动转为小写，不是全类名）。</li>
</ul>
<p>以下是@Configuration的使用案例，<code>proxyBeanMethods</code>属性用来设置Full模式与Lite模式</p>
<ul>
<li>配置类组件之间无依赖关系用Lite模式加速容器启动过程，减少判断</li>
<li>配置类组件之间有依赖关系，方法会被调用得到之前单实例组件，用Full模式</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// ####################Configuration使用示例######################</span><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 1、配置类里面使用<span class="hljs-doctag">@Bean</span>标注在方法上给容器注册组件，默认也是单实例的</span><br><span class="hljs-comment"> * 2、配置类本身也是组件</span><br><span class="hljs-comment"> * 3、proxyBeanMethods：代理bean的方法</span><br><span class="hljs-comment"> *      Full(proxyBeanMethods = true)、【保证每个<span class="hljs-doctag">@Bean</span>方法被调用多少次返回的组件都是单实例的】</span><br><span class="hljs-comment"> *      Lite(proxyBeanMethods = false)【每个<span class="hljs-doctag">@Bean</span>方法被调用多少次返回的组件都是新创建的】</span><br><span class="hljs-comment"> *      组件依赖必须使用Full模式默认。其他默认是Lite模式</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@Configuration(proxyBeanMethods = false)</span> <span class="hljs-comment">//告诉SpringBoot这是一个配置类 == 配置文件</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyConfig</span> </span>&#123;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * Full:外部无论对配置类中的这个组件注册方法调用多少次获取的都是之前注册容器中的单实例对象</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Bean</span> <span class="hljs-comment">//给容器中添加组件。以方法名作为组件的id。返回类型就是组件类型。返回的值，就是组件在容器中的实例</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> User <span class="hljs-title">user01</span><span class="hljs-params">()</span></span>&#123;<br>        User zhangsan = <span class="hljs-keyword">new</span> User(<span class="hljs-string">&quot;zhangsan&quot;</span>, <span class="hljs-number">18</span>);<br>        <span class="hljs-comment">//user组件依赖了Pet组件</span><br>        zhangsan.setPet(tomcatPet());<br>        <span class="hljs-keyword">return</span> zhangsan;<br>    &#125;<br><br>    <span class="hljs-meta">@Bean(&quot;tom&quot;)</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Pet <span class="hljs-title">tomcatPet</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Pet(<span class="hljs-string">&quot;tomcat&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// ##################@Configuration测试代码如下#####################</span><br><span class="hljs-meta">@SpringBootConfiguration</span><br><span class="hljs-meta">@EnableAutoConfiguration</span><br><span class="hljs-meta">@ComponentScan(&quot;com.atguigu.boot&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MainApplication</span> </span>&#123;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        <span class="hljs-comment">//1、返回我们IOC容器</span><br>        ConfigurableApplicationContext run = SpringApplication.run(MainApplication.class, args);<br><br>        <span class="hljs-comment">//2、查看容器里面的组件</span><br>        String[] names = run.getBeanDefinitionNames();<br>        <span class="hljs-keyword">for</span> (String name : names) &#123;<br>            System.out.println(name);<br>        &#125;<br><br>        <span class="hljs-comment">//3、从容器中获取组件</span><br>        Pet tom01 = run.getBean(<span class="hljs-string">&quot;tom&quot;</span>, Pet.class);<br>        Pet tom02 = run.getBean(<span class="hljs-string">&quot;tom&quot;</span>, Pet.class);<br>        System.out.println(<span class="hljs-string">&quot;组件：&quot;</span>+(tom01 == tom02));  <span class="hljs-comment">// true</span><br><br>        <span class="hljs-comment">//4、com.atguigu.boot.config.MyConfig$$EnhancerBySpringCGLIB$$51f1e1ca@1654a892</span><br>        MyConfig bean = run.getBean(MyConfig.class);<br>        System.out.println(bean);<br><br>        <span class="hljs-comment">//如果@Configuration(proxyBeanMethods = true)代理对象调用方法。SpringBoot总会检查这个组件是否在容器中有。</span><br>        <span class="hljs-comment">//保持组件单实例</span><br>        User user = bean.user01();<br>        User user1 = bean.user01();<br>        System.out.println(user == user1);<br><br>        User user01 = run.getBean(<span class="hljs-string">&quot;user01&quot;</span>, User.class);<br>        Pet tom = run.getBean(<span class="hljs-string">&quot;tom&quot;</span>, Pet.class);<br><br>        System.out.println(<span class="hljs-string">&quot;用户的宠物：&quot;</span>+(user01.getPet() == tom)); <span class="hljs-comment">// true/false与proxyBeanMethods有关</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>@Scope</strong></p>
<p>默认@Bean使用的是Singleton单例模式，每次获取的都是同一个对象，并且是饿汉式加载，可以使用@Scope修改为Prototype，每次获取对象均不同，该模式下会启用懒汉式加载。</p>
<p><strong>@Lazy</strong></p>
<p>使用该注解会将单例模式的Bean修改为懒加载模式。</p>
<h3 id="2-3-Import"><a href="#2-3-Import" class="headerlink" title="2.3 @Import"></a>2.3 @Import</h3><p><strong>简单Import</strong></p>
<p>也可以使用@Import注解注入bean到容器中去.</p>
<p>@Import注解接收一个Class[]，被注入bean的id默认是导入类的<code>全类名</code>，bean默认使用无参构造做初始化。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * @Import(&#123;User.class, DBHelper.class&#125;)</span><br><span class="hljs-comment"> * 给容器中自动创建出这两个类型的组件、默认组件的名字就是全类名</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@Import(&#123;User.class, DBHelper.class&#125;)</span><br><span class="hljs-meta">@Configuration(proxyBeanMethods = false)</span> <span class="hljs-comment">//告诉SpringBoot这是一个配置类 == 配置文件</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyConfig</span> </span>&#123;<br>    <br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>ImportSelector</strong></p>
<p>可以自己创建一个类，并且实现 <code>ImportSelector</code> 接口，重写 <code>ImportSelector</code> 的 <code>selectImports</code> 方法，<code>selectImports</code> 方法返回的是需要被注入类的全类名，然后把这个自己创建的类加入@Import的数组中。</p>
<p>被注入bean的名字默认是导入类的<code>全类名</code>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Import(TestImportSelector.class)</span>  <span class="hljs-comment">// 通过@ImportSelector注入</span><br><span class="hljs-meta">@Configuration</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TestConfiguration</span> </span>&#123;<br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">StrBean</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;this is a string&quot;</span>;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TestImportSelector</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">ImportSelector</span> </span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> String[] selectImports(AnnotationMetadata annotationMetadata) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> String[]&#123;<span class="hljs-string">&quot;qizi.Main&quot;</span>&#125;;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Predicate&lt;String&gt; <span class="hljs-title">getExclusionFilter</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>ImportBeanDefinitionRegistrar</strong></p>
<p>自己创建一个类，继承<code>ImportBeanDefinitionRegistrar</code>并重写方法，手动注册beanDefinition，可以自定义bean的id名。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 使用ImportBeanDefinitionRegistrar注入</span><br><span class="hljs-meta">@Import(&#123;TestImportSelector.class, TestImportBeanDefinitionRegistrar.class&#125;)</span><br><span class="hljs-meta">@Configuration</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TestConfiguration</span> </span>&#123;<br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">StrBean</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;this is a string&quot;</span>;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TestImportBeanDefinitionRegistrar</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">ImportBeanDefinitionRegistrar</span> </span>&#123;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> importingClassMetadata 当前类的注解</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> registry beandefinition注册类</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">registerBeanDefinitions</span><span class="hljs-params">(AnnotationMetadata importingClassMetadata, BeanDefinitionRegistry registry)</span> </span>&#123;<br>        registry.registerBeanDefinition(<span class="hljs-string">&quot;diy_hashmap_id&quot;</span>, <span class="hljs-keyword">new</span> RootBeanDefinition(HashMap.class));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="2-4-Conditional"><a href="#2-4-Conditional" class="headerlink" title="2.4 @Conditional"></a>2.4 @Conditional</h3><p>有一个专门的注解叫@Conditional，需要和@Configuration等注解配合使用。可以根据自己指定的类来决定是否加载被标记类到IOC容器，必须是@Conditional指定的条件成立，才给容器中添加组件，配置配里面的所有内容才生效。</p>
<p>也有一些已经封装好的条件装配注解：当满足ConditionalOn指定的条件时，才进行组件注入。</p>
<table>
<thead>
<tr>
<th>@ConditionalOn扩展注解</th>
<th>作用(判断是否满足当前指定条件)</th>
</tr>
</thead>
<tbody><tr>
<td>@ConditionalOnJava</td>
<td>系统的java版本是否符合要求</td>
</tr>
<tr>
<td>@ConditionalOnJava</td>
<td>容器中存在指定Bean</td>
</tr>
<tr>
<td>@ConditionalOnMissingBean</td>
<td>容器中不存在指定Bean</td>
</tr>
<tr>
<td>@ConditionalOnExpression</td>
<td>满足SpEL表达式指定</td>
</tr>
<tr>
<td>@ConditionalOnClass</td>
<td>系统中有指定的类</td>
</tr>
<tr>
<td>@ConditionalOnMissingClass</td>
<td>系统中没有指定的类</td>
</tr>
<tr>
<td>@ConditionalOnSingleCandidate</td>
<td>容器中只有一个指定的Bean，或者这个Bean是首选Bean</td>
</tr>
<tr>
<td>@ConditionalOnProperty</td>
<td>系统中指定的属性是否有指定的值</td>
</tr>
<tr>
<td>@ConditionalOnResource</td>
<td>类路径下是否存在指定资源文件</td>
</tr>
<tr>
<td>@ConditionalOnWebApplication</td>
<td>当前是web环境</td>
</tr>
<tr>
<td>@ConditionalOnNotWebApplication</td>
<td>当前不是web环境</td>
</tr>
<tr>
<td>@ConditionalOnJndi</td>
<td>JNDI存在指定项</td>
</tr>
</tbody></table>
<p><strong>那么多的自动配置类，必须在一定的条件下才能生效；也就是说，我们加载了这么多的配置类，但不是所有的都生效了。</strong></p>
<blockquote>
<p><strong>自动配置类是否生效</strong></p>
</blockquote>
<p>我们可以在application.properties通过启用 <code>debug=true</code>属性；在控制台打印自动配置报告，这样我们就可以很方便的知道哪些自动配置类生效；</p>
<figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-comment"># 开启springboot的调试类</span><br><span class="hljs-attr">debug</span>=<span class="hljs-string">true</span><br></code></pre></td></tr></table></figure>

<ul>
<li>Positive matches:（自动配置类启用的：正匹配）</li>
<li>Negative matches:（没有启动，没有匹配成功的自动配置类：负匹配）</li>
<li>Unconditional classes: （没有条件的类）</li>
<li>【演示：查看输出的日志】</li>
</ul>
<h3 id="2-5-ImportResource"><a href="#2-5-ImportResource" class="headerlink" title="2.5 @ImportResource"></a>2.5 @ImportResource</h3><p>考虑到部分存量代码是用Spring时代的xml方法配置的，为了兼容历史代码，可以使用@ImportResource注解指定bean.xml配置的路径，加载xml配置中的bean。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@ImportResource(&quot;classpath:beans.xml&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyConfig</span> </span>&#123;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="2-6-FactoryBean"><a href="#2-6-FactoryBean" class="headerlink" title="2.6 FactoryBean"></a>2.6 FactoryBean</h3><p>一般情况下，Spring是通过反射机制利用bean的class属性指定实现类来实例化bean的。在某些情况下，实例化bean过程比较复杂，如果按照传统的方式，那么则需要在标签中提供大量的配置信息，配置方式的灵活性是受限的，这时采用编码的方式可以得到一个更加简单的方案。Spring为此提供了一个org.springframework.bean.factory.FactoryBean的工厂类接口，用户可以通过实现该接口定制实例化bean的逻辑。</p>
<p>FactoryBean接口对于Spring框架来说占有非常重要的地位，Spring自身就提供了70多个FactoryBean接口的实现。它们隐藏了实例化一些复杂bean的细节，给上层应用带来了便利。从Spring 3.0开始，FactoryBean开始支持泛型，即接口声明改为<code>FactoryBean&lt;T&gt;</code>的形式。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">FactoryBean</span> &lt;<span class="hljs-title">T</span>&gt; </span>&#123;<br>    String OBJECT_TYPE_ATTRIBUTE = <span class="hljs-string">&quot;factoryBeanObjectType&quot;</span>;<br><br>    <span class="hljs-meta">@Nullable</span><br>    <span class="hljs-function">T <span class="hljs-title">getObject</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception</span>;  <span class="hljs-comment">// 返回由FactoryBean创建的bean实例</span><br><br>    <span class="hljs-meta">@Nullable</span><br>    java.lang.Class&lt;?&gt; getObjectType();  <span class="hljs-comment">// 返回bean实例对象的类型</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">default</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isSingleton</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-comment">/* compiled code */</span> &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>需要注意的是：当配置文件中标签的class属性配置的实现类是FactoryBean时，通过 getBean()方法返回的不是FactoryBean本身，而是FactoryBean#getObject()方法所返回的对象，相当于FactoryBean#getObject()代理了getBean()方法。如果确实需要获取FactoryBean，使用时需要在context#getBean的beanid前面加上一个<code>&amp;</code>符号。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ColorFactoryBean</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">FactoryBean</span>&lt;<span class="hljs-title">Color</span>&gt; </span>&#123;<br><br>	<span class="hljs-meta">@Override</span><br>	<span class="hljs-function"><span class="hljs-keyword">public</span> Color <span class="hljs-title">getObject</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;  <span class="hljs-comment">// 返回一个Color对象到容器中</span><br>		System.out.println(<span class="hljs-string">&quot;ColorFactoryBean...getObject...&quot;</span>);<br>		<span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Color();<br>	&#125;<br><br>	<span class="hljs-meta">@Override</span><br>	<span class="hljs-keyword">public</span> Class&lt;?&gt; getObjectType() &#123;  <span class="hljs-comment">// 返回这个对象的类型</span><br>		<span class="hljs-keyword">return</span> Color.class;<br>	&#125;<br><br>	<span class="hljs-meta">@Override</span><br>	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isSingleton</span><span class="hljs-params">()</span> </span>&#123;  <span class="hljs-comment">// 是否为单例</span><br>		<span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>	&#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MainConfig</span></span>&#123;<br>    <span class="hljs-meta">@Bean</span><br>	<span class="hljs-function"><span class="hljs-keyword">public</span> ColorFactoryBean <span class="hljs-title">colorFactoryBean</span><span class="hljs-params">()</span> </span>&#123;<br>		<span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> ColorFactoryBean();<br>	&#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>测试</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testImport</span><span class="hljs-params">()</span> </span>&#123;<br>    AnnotationConfigApplicationContext applicationContext = <span class="hljs-keyword">new</span> AnnotationConfigApplicationContext(MainConfig2.class);<br>    String[] definitionNames = applicationContext.getBeanDefinitionNames();<br>    <span class="hljs-keyword">for</span> (String name : definitionNames) &#123;<br>        System.out.println(name);  <span class="hljs-comment">// 会看到有一个definitionName叫colorFactoryBean</span><br>    &#125;<br>    <br>    <span class="hljs-comment">// 工厂bean获取的是调用getObject方法创建的对象</span><br>    Object bean2 = applicationContext.getBean(<span class="hljs-string">&quot;colorFactoryBean&quot;</span>);<br>    System.out.println(<span class="hljs-string">&quot;bean的类型：&quot;</span> + bean2.getClass());  <span class="hljs-comment">// 实际上这个colorFactoryBean是Color.class类型</span><br>	<br>    <span class="hljs-comment">// 获取FactoryBean对象本省</span><br>    Object bean4 = applicationContext.getBean(<span class="hljs-string">&quot;&amp;colorFactoryBean&quot;</span>);<br>    System.out.println(bean4.getClass());  <span class="hljs-comment">// FactoryBean.class</span><br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="3-Bean常用拓展点"><a href="#3-Bean常用拓展点" class="headerlink" title="3 Bean常用拓展点"></a>3 Bean常用拓展点</h2><h3 id="3-1-初始化和销毁"><a href="#3-1-初始化和销毁" class="headerlink" title="3.1 初始化和销毁"></a>3.1 初始化和销毁</h3><p>如果是使用XML配置文件的方式配置bean的话，那么可以在标签中指定bean的初始化和销毁方法，如下所示。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;person&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.meimeixia.bean.Person&quot;</span> <span class="hljs-attr">init-method</span>=<span class="hljs-string">&quot;init&quot;</span> <span class="hljs-attr">destroy-method</span>=<span class="hljs-string">&quot;destroy&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;age&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;18&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;name&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;liayun&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br></code></pre></td></tr></table></figure>

<p>这里，需要注意的是，在我们自己写的Person类中，需要存在init()方法和destroy()方法。而且Spring中还规定，这里的init()方法和destroy()方法必须是<strong>无参方法</strong>，但可以抛出异常。</p>
<p><strong>@Bean注解指定</strong></p>
<p>可以通过@Bean注解的两个参数指定初始化和销毁方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MainConfigOfLifeCycle</span> </span>&#123;<br>	<span class="hljs-meta">@Bean(initMethod=&quot;init&quot;, destroyMethod=&quot;destroy&quot;)</span><br>	<span class="hljs-function"><span class="hljs-keyword">public</span> Car <span class="hljs-title">car</span><span class="hljs-params">()</span> </span>&#123;<br>		<span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Car();  <span class="hljs-comment">// Car类中需要提供名叫init和destory的两个方法</span><br>	&#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>初始化方法和销毁方法的调用时机？</p>
<ul>
<li>初始化方法调用的时机：对象创建完成，如果对象中存在一些属性，并且这些属性也都赋好值之后，那么就会调用bean的初始化方法。对于单实例bean来说，在Spring容器创建完成后，Spring容器会自动调用bean的初始化方法；对于多实例bean来说，在每次获取bean对象的时候，调用bean的初始化方法。</li>
<li>销毁方法调用的时机：对于单实例bean来说，在容器关闭的时候，会调用bean的销毁方法；对于多实例bean来说，Spring容器不会管理这个bean，也就不会自动调用这个bean的销毁方法了。不过，用户可以手动调用多实例bean的销毁方法。</li>
</ul>
<p><strong>实现InitializingBean和DisposableBean接口</strong></p>
<p>如果不使用@Bean指定初始化和销毁方法，也可以实现InitializingBean、DisposableBean这两个接口，这样也能实现指定初始化和销毁方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Cat</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">InitializingBean</span>, <span class="hljs-title">DisposableBean</span> </span>&#123;<br>	<br>	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Cat</span><span class="hljs-params">()</span> </span>&#123;<br>		System.out.println(<span class="hljs-string">&quot;cat constructor...&quot;</span>);<br>	&#125;<br>    <br>    <span class="hljs-meta">@Override</span>  <span class="hljs-comment">// 会在bean创建完成，并且属性都赋好值以后进行调用</span><br>	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">afterPropertiesSet</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>		System.out.println(<span class="hljs-string">&quot;cat afterPropertiesSet...&quot;</span>);<br>	&#125;<br><br>	<span class="hljs-meta">@Override</span>  <span class="hljs-comment">// 会在容器关闭的时候进行调用</span><br>	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">destroy</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>		System.out.println(<span class="hljs-string">&quot;cat destroy...&quot;</span>);<br>	&#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>@PostConstruct和@PreDestroy注解</strong></p>
<p>@PostConstruct和@PreDestroy是Java依据JSR-250规范定义的两个注解。</p>
<ul>
<li>Constructor（构造方法）→@Autowired（依赖注入）→@PostConstruct（注释的方法）</li>
<li>调用destroy()方法→@PreDestroy→destroy()方法→bean销毁</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Dog</span> </span>&#123;<br>	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Dog</span><span class="hljs-params">()</span> </span>&#123;<br>		System.out.println(<span class="hljs-string">&quot;dog constructor...&quot;</span>);<br>	&#125;<br>	<br>	<span class="hljs-meta">@PostConstruct</span><br>	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">init</span><span class="hljs-params">()</span> </span>&#123;  <span class="hljs-comment">// 在对象创建完成并且属性赋值完成之后调用</span><br>		System.out.println(<span class="hljs-string">&quot;dog...@PostConstruct...&quot;</span>);<br>	&#125;<br>	<br>	<span class="hljs-meta">@PreDestroy</span><br>	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">destory</span><span class="hljs-params">()</span> </span>&#123;  <span class="hljs-comment">// 在容器销毁（移除）对象之前调用</span><br>		System.out.println(<span class="hljs-string">&quot;dog...@PreDestroy...&quot;</span>);<br>	&#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="3-2-BeanPostProcessor"><a href="#3-2-BeanPostProcessor" class="headerlink" title="3.2 BeanPostProcessor"></a>3.2 BeanPostProcessor</h3><p>BeanPostProcessor后置处理器。<strong>Spring容器中的每一个bean对象初始化前后，都会执行BeanPostProcessor接口的实现类中的这两个方法</strong>。</p>
<p>postProcessBeforeInitialization方法会在bean实例化和==属性设置之后，自定义初始化方法之前==被调用，而postProcessAfterInitialization方法会在自定义==初始化方法执行之后==被调用。当容器中存在多个BeanPostProcessor的实现类时，会按照它们在容器中注册的顺序执行。对于自定义的BeanPostProcessor实现类，还可以让其实现Ordered接口自定义排序。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Component</span> <span class="hljs-comment">// 将后置处理器加入到容器中，这样Spring就能让它工作了</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyBeanPostProcessor</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">BeanPostProcessor</span> </span>&#123;<br>	<span class="hljs-meta">@Override</span><br>	<span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">postProcessBeforeInitialization</span><span class="hljs-params">(Object bean, String beanName)</span> <span class="hljs-keyword">throws</span> BeansException </span>&#123;<br>		System.out.println(<span class="hljs-string">&quot;postProcessBeforeInitialization...&quot;</span> + beanName + <span class="hljs-string">&quot;=&gt;&quot;</span> + bean);<br>		<span class="hljs-keyword">return</span> bean;<br>	&#125;<br><br>	<span class="hljs-meta">@Override</span><br>	<span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">postProcessAfterInitialization</span><span class="hljs-params">(Object bean, String beanName)</span> <span class="hljs-keyword">throws</span> BeansException </span>&#123;<br>		System.out.println(<span class="hljs-string">&quot;postProcessAfterInitialization...&quot;</span> + beanName + <span class="hljs-string">&quot;=&gt;&quot;</span> + bean);<br>		<span class="hljs-keyword">return</span> bean;<br>	&#125;<br>    <br>    <span class="hljs-meta">@Override</span><br>	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getOrder</span><span class="hljs-params">()</span> </span>&#123;  <span class="hljs-comment">// 自定义后置处理器排序</span><br>		<span class="hljs-keyword">return</span> <span class="hljs-number">3</span>;<br>	&#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="3-3-XxxAware接口"><a href="#3-3-XxxAware接口" class="headerlink" title="3.3 XxxAware接口"></a>3.3 XxxAware接口</h3><p>XxxAware使用案例</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 以Red类为例来讲解ApplicationContextAware接口、BeanNameAware接口以及EmbeddedValueResolverAware接口</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Red</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">ApplicationContextAware</span>, <span class="hljs-title">BeanNameAware</span>, <span class="hljs-title">EmbeddedValueResolverAware</span> </span>&#123;<br>	<br>	<span class="hljs-keyword">private</span> ApplicationContext applicationContext;<br><br>	<span class="hljs-meta">@Override</span><br>	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setApplicationContext</span><span class="hljs-params">(ApplicationContext applicationContext)</span> <span class="hljs-keyword">throws</span> BeansException </span>&#123;<br>		System.out.println(<span class="hljs-string">&quot;传入的IOC：&quot;</span> + applicationContext);<br>		<span class="hljs-keyword">this</span>.applicationContext = applicationContext;<br>	&#125;<br><br>	<span class="hljs-comment">/**</span><br><span class="hljs-comment">	 * 参数name：IOC容器创建当前对象时，为这个对象起的名字</span><br><span class="hljs-comment">	 */</span><br>	<span class="hljs-meta">@Override</span><br>	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setBeanName</span><span class="hljs-params">(String name)</span> </span>&#123;<br>		System.out.println(<span class="hljs-string">&quot;当前bean的名字：&quot;</span> + name);<br>	&#125;<br>	<br>	<span class="hljs-comment">/**</span><br><span class="hljs-comment">	 * 参数resolver：IOC容器启动时会自动地将这个String值的解析器传递过来给我们</span><br><span class="hljs-comment">	 */</span><br>	<span class="hljs-meta">@Override</span><br>	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setEmbeddedValueResolver</span><span class="hljs-params">(StringValueResolver resolver)</span> </span>&#123;<br>		String resolveStringValue = resolver.resolveStringValue(<span class="hljs-string">&quot;你好，$&#123;os.name&#125;，我的年龄是#&#123;20*18&#125;&quot;</span>);<br>		System.out.println(<span class="hljs-string">&quot;解析的字符串：&quot;</span> + resolveStringValue);<br>	&#125;<br><br>&#125;<br></code></pre></td></tr></table></figure>

<p>XxxAware接口的底层原理是由XxxAwareProcessor实现类实现的，每一个XxxAware接口都有它自己对应的XxxAwareProcessor实现类。 例如，以ApplicationContextAware接口为例，ApplicationContextAware接口的底层原理就是由ApplicationContextAwareProcessor类实现的。从ApplicationContextAwareProcessor类的源码可以看出，其实现了BeanPostProcessor接口，本质上是一个后置处理器。</p>
<h3 id="3-4-AOP使用及原理"><a href="#3-4-AOP使用及原理" class="headerlink" title="3.4 AOP使用及原理"></a>3.4 AOP使用及原理</h3><p><strong>引入AOP依赖</strong></p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-aspects<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>4.3.12.RELEASE<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure>

<p><strong>定义目标类</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MathCalculator</span> </span>&#123;<br>	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">div</span><span class="hljs-params">(<span class="hljs-keyword">int</span> i, <span class="hljs-keyword">int</span> j)</span> </span>&#123;<br>		System.out.println(<span class="hljs-string">&quot;MathCalculator...div...&quot;</span>);<br>		<span class="hljs-keyword">return</span> i / j;<br>	&#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>定义切面类</strong></p>
<p>AOP中的通知方法及其对应的注解与含义如下：</p>
<ul>
<li>前置通知（对应的注解是@Before）：在目标方法运行之前运行</li>
<li>后置通知（对应的注解是@After）：在目标方法运行结束之后运行，无论目标方法是正常结束还是异常结束都会执行</li>
<li>返回通知（对应的注解是@AfterReturning）：在目标方法正常返回之后运行</li>
<li>异常通知（对应的注解是@AfterThrowing）：在目标方法运行出现异常之后运行</li>
<li>环绕通知（对应的注解是@Around）：动态代理，我们可以直接手动推进目标方法运行</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Aspect</span>  <span class="hljs-comment">// 告诉Spring当前类是一个切面类</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LogAspects</span> </span>&#123;<br>    <br>    <span class="hljs-comment">// 如果切入点表达式都一样的情况下，那么我们可以抽取出一个公共的切入点表达式</span><br>	<span class="hljs-meta">@Pointcut(&quot;execution(public int com.meimeixia.aop.MathCalculator.*(..))&quot;)</span><br>	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">pointCut</span><span class="hljs-params">()</span> </span>&#123;&#125;<br>	<br>	<span class="hljs-comment">// @Before：在目标方法（即div方法）运行之前切入，public int com.meimeixia.aop.MathCalculator.div(int, int)这一串就是切入点表达式，指定在哪个方法切入</span><br>	<span class="hljs-comment">// @Before(&quot;public int com.meimeixia.aop.MathCalculator.*(..)&quot;)</span><br>    <span class="hljs-meta">@Before(&quot;pointCut()&quot;)</span>  <span class="hljs-comment">// 抽取公用的切点</span><br>	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">logStart</span><span class="hljs-params">(JoinPoint joinPoint)</span> </span>&#123;<br>		Object[] args = joinPoint.getArgs(); <span class="hljs-comment">// 拿到参数列表，即目标方法运行需要的参数列表</span><br>		System.out.println(joinPoint.getSignature().getName() + <span class="hljs-string">&quot;运行......@Before，参数列表是：&#123;&quot;</span> + Arrays.asList(args) + <span class="hljs-string">&quot;&#125;&quot;</span>);<br>	&#125;<br>	<br>	<span class="hljs-comment">// 在目标方法（即div方法）结束时被调用</span><br>	<span class="hljs-comment">// @After(&quot;public int com.meimeixia.aop.MathCalculator.*(..)&quot;)</span><br>    <span class="hljs-meta">@After(&quot;pointCut()&quot;)</span>  <span class="hljs-comment">// 抽取公用的切点</span><br>	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">logEnd</span><span class="hljs-params">(JoinPoint joinPoint)</span> </span>&#123;<br>		<span class="hljs-comment">// System.out.println(&quot;除法结束......@After&quot;);</span><br>		System.out.println(joinPoint.getSignature().getName() + <span class="hljs-string">&quot;结束......@After&quot;</span>);<br>	&#125;<br>	<br>	<span class="hljs-comment">// 在目标方法（即div方法）正常返回了，有返回值，被调用</span><br>	<span class="hljs-comment">// @AfterReturning(&quot;public int com.meimeixia.aop.MathCalculator.*(..)&quot;)</span><br>    <span class="hljs-meta">@AfterReturning(&quot;pointCut()&quot;)</span>  <span class="hljs-comment">// 抽取公用的切点</span><br>	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">logReturn</span><span class="hljs-params">(JoinPoint joinPoint, Object result)</span> </span>&#123; <span class="hljs-comment">// 一定要注意：JoinPoint这个参数要写，一定不能写到后面，它必须出现在参数列表的第一位，否则Spring也是无法识别的，就会报错</span><br>		System.out.println(joinPoint.getSignature().getName() + <span class="hljs-string">&quot;正常返回......@AfterReturning，运行结果是：&#123;&quot;</span> + result + <span class="hljs-string">&quot;&#125;&quot;</span>);<br>	&#125;<br>	<br>	<span class="hljs-comment">// 在目标方法（即div方法）出现异常，被调用</span><br>	<span class="hljs-comment">// @AfterThrowing(&quot;public int com.meimeixia.aop.MathCalculator.*(..)&quot;)</span><br>    <span class="hljs-meta">@AfterThrowing(&quot;pointCut()&quot;)</span>  <span class="hljs-comment">// 抽取公用的切点</span><br>	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">logException</span><span class="hljs-params">()</span> </span>&#123;<br>		System.out.println(<span class="hljs-string">&quot;除法出现异常......异常信息：&#123;&#125;&quot;</span>);<br>	&#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>开启基于注解的AOP模式</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@EnableAspectJAutoProxy</span><br><span class="hljs-meta">@Configuration</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MainConfigOfAOP</span> </span>&#123;<br>	<br>	<span class="hljs-comment">// 将业务逻辑类（目标方法所在类）加入到容器中</span><br>	<span class="hljs-meta">@Bean</span><br>	<span class="hljs-function"><span class="hljs-keyword">public</span> MathCalculator <span class="hljs-title">calculator</span><span class="hljs-params">()</span> </span>&#123;<br>		<span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> MathCalculator();<br>	&#125;<br>	<br>	<span class="hljs-comment">// 将切面类加入到容器中</span><br>	<span class="hljs-meta">@Bean</span><br>	<span class="hljs-function"><span class="hljs-keyword">public</span> LogAspects <span class="hljs-title">logAspects</span><span class="hljs-params">()</span> </span>&#123;<br>		<span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> LogAspects();<br>	&#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>AOP底层原理</strong></p>
<p>最后，我们还需要对AOP原理做一个简单的总结，完美结束对其研究的旅程。</p>
<ol>
<li><p>利用@EnableAspectJAutoProxy注解来开启AOP功能</p>
</li>
<li><p>这个AOP功能是怎么开启的呢？主要是通过@EnableAspectJAutoProxy注解向IOC容器中注册一个AnnotationAwareAspectJAutoProxyCreator组件来做到这点的</p>
</li>
<li><p>AnnotationAwareAspectJAutoProxyCreator组件是一个后置处理器</p>
</li>
<li><p>该后置处理器是怎么工作的呢？在IOC容器创建的过程中，我们就能清楚地看到这个后置处理器是如何创建以及注册的，以及它的工作流程。</p>
<ol>
<li><p>首先，在创建IOC容器的过程中，会调用refresh()方法来刷新容器，而在刷新容器的过程中有一步是来注册后置处理器的，如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">registerBeanPostProcessors(beanFactory); <span class="hljs-comment">// 注册后置处理器，在这一步会创建AnnotationAwareAspectJAutoProxyCreator对象</span><br></code></pre></td></tr></table></figure>

<p>其实，这一步会为所有后置处理器都创建对象。</p>
</li>
<li><p>在刷新容器的过程中还有一步是来完成BeanFactory的初始化工作的，如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">finishBeanFactoryInitialization(beanFactory); <span class="hljs-comment">// 完成BeanFactory的初始化工作。所谓的完成BeanFactory的初始化工作，其实就是来创建剩下的单实例bean的。</span><br></code></pre></td></tr></table></figure>

<p>很显然，剩下的单实例bean自然就包括MathCalculator（业务逻辑类）和LogAspects（切面类）这两个bean，因此这两个bean就是在这儿被创建的。</p>
<ol>
<li>创建业务逻辑组件和切面组件</li>
<li>在这两个组件创建的过程中，最核心的一点就是AnnotationAwareAspectJAutoProxyCreator（后置处理器）会来拦截这俩组件的创建过程</li>
<li>怎么拦截呢？主要就是在组件创建完成之后，判断组件是否需要增强。如需要，则会把切面里的通知方法包装成增强器，然后再为业务逻辑组件创建一个代理对象。我们也认真仔细探究过了，在为业务逻辑组件创建代理对象的时候，使用的是cglib来创建动态代理的。当然了，如果业务逻辑类有实现接口，那么就使用jdk来创建动态代理。一旦这个代理对象创建出来了，那么它里面就会有所有的增强器。这个代理对象创建完以后，IOC容器也就创建完了。接下来，便要来执行目标方法了。</li>
</ol>
</li>
</ol>
</li>
<li><p>执行目标方法</p>
<ol>
<li>此时，其实是代理对象来执行目标方法</li>
<li>使用CglibAopProxy类的intercept()方法来拦截目标方法的执行，拦截的过程如下：<ol>
<li>得到目标方法的拦截器链，所谓的拦截器链其实就是每一个通知方法又被包装为了方法拦截器，即MethodInterceptor</li>
<li>利用拦截器的链式机制（责任链模式），依次进入每一个拦截器中进行执行</li>
<li>最终，整个的执行效果就会有两套：（据说Spring5中下面的拦截顺序有调整）<ul>
<li>目标方法正常执行：前置通知→目标方法→后置通知→返回通知</li>
<li>目标方法出现异常：前置通知→目标方法→后置通知→异常通知</li>
</ul>
</li>
</ol>
</li>
</ol>
</li>
</ol>
<h3 id="3-5-声明式事务"><a href="#3-5-声明式事务" class="headerlink" title="3.5 声明式事务"></a>3.5 声明式事务</h3><p><strong>添加c3p0数据源、MySQL数据库驱动以及spring-jdbc的依赖</strong></p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>c3p0<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>c3p0<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>0.9.1.2<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>mysql<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>mysql-connector-java<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>5.1.44<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-jdbc<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>4.3.12.RELEASE<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure>

<p>引入spring-jdbc模块后就可以用Spring提供的JDBC模板（即JdbcTemplate）来操作数据库，从而简化对数据库的操作以及事务控制。</p>
<p><strong>配置类bean注册</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@EnableTransactionManagement</span> <span class="hljs-comment">// 开启基于注解的事务管理功能的</span><br><span class="hljs-meta">@ComponentScan(&quot;com.meimeixia.tx&quot;)</span><br><span class="hljs-meta">@Configuration</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TxConfig</span> </span>&#123;<br>	<span class="hljs-meta">@Bean</span>  <span class="hljs-comment">// 注册c3p0数据源</span><br>	<span class="hljs-function"><span class="hljs-keyword">public</span> DataSource <span class="hljs-title">dataSource</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>		ComboPooledDataSource dataSource = <span class="hljs-keyword">new</span> ComboPooledDataSource();<br>		dataSource.setUser(<span class="hljs-string">&quot;root&quot;</span>);<br>		dataSource.setPassword(<span class="hljs-string">&quot;liayun&quot;</span>);<br>		dataSource.setDriverClass(<span class="hljs-string">&quot;com.mysql.jdbc.Driver&quot;</span>);<br>		dataSource.setJdbcUrl(<span class="hljs-string">&quot;jdbc:mysql://localhost:3306/test&quot;</span>);<br>		<span class="hljs-keyword">return</span> dataSource;<br>	&#125;<br>	<br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> JdbcTemplate <span class="hljs-title">jdbcTemplate</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>        JdbcTemplate jdbcTemplate = <span class="hljs-keyword">new</span> JdbcTemplate(dataSource());<br>        <span class="hljs-keyword">return</span> jdbcTemplate;<br>    &#125;<br>    <br>    <span class="hljs-meta">@Bean</span>  <span class="hljs-comment">// 注册事务管理器</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> PlatformTransactionManager <span class="hljs-title">platformTransactionManager</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> DataSourceTransactionManager(dataSource());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>测试</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Repository</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserDao</span> </span>&#123;<br>	<span class="hljs-meta">@Autowired</span><br>	<span class="hljs-keyword">private</span> JdbcTemplate jdbcTemplate;<br>	<br>	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">insert</span><span class="hljs-params">()</span> </span>&#123;<br>		String sql = <span class="hljs-string">&quot;insert into `tbl_user`(username, age) values(?, ?)&quot;</span>;<br>		String username = UUID.randomUUID().toString().substring(<span class="hljs-number">0</span>, <span class="hljs-number">5</span>);<br>		jdbcTemplate.update(sql, username, <span class="hljs-number">19</span>); <span class="hljs-comment">// 增删改都来调用这个方法</span><br>	&#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Service</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserService</span> </span>&#123;<br>	<span class="hljs-meta">@Autowired</span><br>	<span class="hljs-keyword">private</span> UserDao userDao;<br>	<br>    <span class="hljs-meta">@Transactional</span><br>	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">insertUser</span><span class="hljs-params">()</span> </span>&#123;<br>        userDao.insert();<br>        <span class="hljs-comment">// otherDao.other(); // 该方法中的业务逻辑势必不会像现在这么简单，肯定还会调用其他dao的方法</span><br>        System.out.println(<span class="hljs-string">&quot;插入完成...&quot;</span>);<br>        <span class="hljs-keyword">int</span> i = <span class="hljs-number">10</span> / <span class="hljs-number">0</span>;<br>    &#125;	<br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>声明式事务的原理</strong></p>
<p>首先，使用AutoProxyRegistrar向Spring容器里面注册一个后置处理器，这个后置处理器会负责给我们包装代理对象。然后，使用ProxyTransactionManagementConfiguration（配置类）再向Spring容器里面注册一个事务增强器，此时，需要用到事务拦截器。最后，代理对象执行目标方法，在这一过程中，便会执行到当前Spring容器里面的拦截器链，而且每次在执行目标方法时，如果出现了异常，那么便会利用事务管理器进行回滚事务，如果执行过程中一切正常，那么则会利用事务管理器提交事务。</p>
<p><strong>分析细节：<a target="_blank" rel="noopener" href="https://liayun.blog.csdn.net/article/details/111872692">Spring注解驱动开发第35讲——声明式事务原理的源码分析</a></strong> </p>
<h3 id="3-6-BeanFactoryPostProcessor"><a href="#3-6-BeanFactoryPostProcessor" class="headerlink" title="3.6 BeanFactoryPostProcessor"></a>3.6 BeanFactoryPostProcessor</h3><p>与bean实例的后置处理器BeanPostProcessor相似，BeanFactoryPostProcessor是BeanFactory（创建bean的工厂）的后置处理器。</p>
<p>BeanFactoryPostProcessor是Spring提供的一个增强点，该增强点的增强时机是<strong>“在BeanFactory标准初始化之后，所有的beanDefinition已经保存加载到BeanFactory中，但是bean的实例还未被创建，可以来定制和修改BeanFactory里面的一些内容”</strong>。</p>
<p>可以通过实现<code>BeanFactoryPostProcessor</code>接口来自定义自己的bean工厂后置处理器。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyBeanFactoryPostProcessor</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">BeanFactoryPostProcessor</span> </span>&#123;<br><br>	<span class="hljs-meta">@Override</span><br>	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">postProcessBeanFactory</span><span class="hljs-params">(ConfigurableListableBeanFactory beanFactory)</span> <span class="hljs-keyword">throws</span> BeansException </span>&#123;<br>		System.out.println(<span class="hljs-string">&quot;MyBeanFactoryPostProcessor...postProcessBeanFactory...&quot;</span>); <span class="hljs-comment">// 这个时候我们所有的bean还没被创建</span><br>		                                                                              <span class="hljs-comment">// 但是我们可以看一下通过Spring给我们传过来的这个beanFactory，我们能拿到什么</span><br>		<span class="hljs-keyword">int</span> count = beanFactory.getBeanDefinitionCount(); <span class="hljs-comment">// 我们能拿到有几个bean定义</span><br>		String[] names = beanFactory.getBeanDefinitionNames(); <span class="hljs-comment">// 除此之外，我们还能拿到每一个bean定义的名字</span><br>		System.out.println(<span class="hljs-string">&quot;当前BeanFactory中有&quot;</span> + count + <span class="hljs-string">&quot;个Bean&quot;</span>);<br>		System.out.println(Arrays.asList(names));<br>	&#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>分析细节：<a target="_blank" rel="noopener" href="https://liayun.blog.csdn.net/article/details/113103870">Spring注解驱动开发第36讲——从源码角度理解BeanFactoryPostProcessor的原理</a></strong> </p>
<h3 id="3-7-BeanDefinitionRegistryPostProcessor"><a href="#3-7-BeanDefinitionRegistryPostProcessor" class="headerlink" title="3.7 BeanDefinitionRegistryPostProcessor"></a>3.7 BeanDefinitionRegistryPostProcessor</h3><p><code>BeanDefinitionRegistryPostProcessor</code>是<code>BeanFactoryPostProcessor</code>的子接口，同样也是Spring提供的一个增强点。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">BeanDefinitionRegistryPostProcessor</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">BeanFactoryPostProcessor</span></span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">postProcessBeanDefinitionRegistry</span><span class="hljs-params">(BeanDefinitionRegistry registry)</span> <span class="hljs-keyword">throws</span> BeansException</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>BeanDefinitionRegistryPostProcessor的切入时机是在所有bean定义信息将要被加载，但是bean实例还未创建的时候</strong>。</p>
<p>即：BeanDefinitionRegistryPostProcessor ➡️ 加载beanDefinition ➡️ BeanFactoryPostProcessor</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyBeanDefinitionRegistryPostProcessor</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">BeanDefinitionRegistryPostProcessor</span> </span>&#123;<br><br>	<span class="hljs-meta">@Override</span><br>	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">postProcessBeanFactory</span><span class="hljs-params">(ConfigurableListableBeanFactory beanFactory)</span> <span class="hljs-keyword">throws</span> BeansException </span>&#123;<br>		System.out.println(<span class="hljs-string">&quot;MyBeanDefinitionRegistryPostProcessor...bean的数量：&quot;</span> + beanFactory.getBeanDefinitionCount());<br>	&#125;<br><br>	<span class="hljs-comment">/**</span><br><span class="hljs-comment">	 * 这个BeanDefinitionRegistry就是Bean定义的保存中心，这个注册中心里面存储了所有的bean定义信息</span><br><span class="hljs-comment">	 * BeanFactory就是按照BeanDefinitionRegistry里面保存的每一个bean定义信息来创建bean实例</span><br><span class="hljs-comment">	 * bean定义信息包括有：这个bean是单例的还是多例的、bean的类型是什么以及bean的id是什么。</span><br><span class="hljs-comment">	 * 也就是说，这些信息都是存在BeanDefinitionRegistry里面的。</span><br><span class="hljs-comment">	 */</span><br>	<span class="hljs-meta">@Override</span><br>	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">postProcessBeanDefinitionRegistry</span><span class="hljs-params">(BeanDefinitionRegistry registry)</span> <span class="hljs-keyword">throws</span> BeansException </span>&#123;<br>		<span class="hljs-comment">// TODO Auto-generated method stub</span><br>		System.out.println(<span class="hljs-string">&quot;postProcessBeanDefinitionRegistry...bean的数量：&quot;</span> + registry.getBeanDefinitionCount());<br>		<span class="hljs-comment">// 除了查看bean的数量之外，我们还可以给容器里面注册一些bean，我们以前也简单地用过</span><br>		<span class="hljs-comment">/*</span><br><span class="hljs-comment">		 * 第一个参数：我们将要给容器中注册的bean的名字</span><br><span class="hljs-comment">		 * 第二个参数：BeanDefinition对象</span><br><span class="hljs-comment">		 */</span><br>		<span class="hljs-comment">// RootBeanDefinition beanDefinition = new RootBeanDefinition(Blue.class); // 现在我准备给容器中添加一个Blue对象</span><br>		<span class="hljs-comment">// 咱们也可以用另外一种办法，即使用BeanDefinitionBuilder这个构建器生成一个BeanDefinition对象，很显然，这两种方法的效果都是一样的</span><br>		AbstractBeanDefinition beanDefinition = BeanDefinitionBuilder.rootBeanDefinition(Blue.class).getBeanDefinition();<br>		registry.registerBeanDefinition(<span class="hljs-string">&quot;hello&quot;</span>, beanDefinition);<br>	&#125;<br><br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>BeanDefinitionRegistryPostProcessor组件执行原理小结</strong></p>
<ol>
<li>创建IOC容器</li>
<li>创建IOC容器时，要调用一个刷新方法，即refresh方法</li>
<li>从IOC容器中获取到所有的BeanDefinitionRegistryPostProcessor组件，并依次触发它们的postProcessBeanDefinitionRegistry方法，然后再来触发它们的postProcessBeanFactory方法</li>
<li>再来从IOC容器中获取到所有的BeanFactoryPostProcessor组件，并依次触发它们的postProcessBeanFactory方法</li>
</ol>
<p><strong>分析细节：<a target="_blank" rel="noopener" href="https://liayun.blog.csdn.net/article/details/113781809">Spring注解驱动开发第37讲——BeanDefinitionRegistryPostProcessor执行原理</a></strong> </p>
<h3 id="3-8-ApplicationListener"><a href="#3-8-ApplicationListener" class="headerlink" title="3.8 ApplicationListener"></a>3.8 ApplicationListener</h3><p>ApplicationListener是Spring提供的基于观察者模式实现的应用监听器。当有指定的事件发生时，就会触发对应的监听器，执行onApplicationEvent方法。该接口中带的泛型就是我们要监听的事件。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">ApplicationListener</span> &lt;<span class="hljs-title">E</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">ApplicationEvent</span>&gt; <span class="hljs-keyword">extends</span> <span class="hljs-title">EventListener</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">onApplicationEvent</span><span class="hljs-params">(E e)</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>案例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyApplicationListener</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">ApplicationListener</span>&lt;<span class="hljs-title">ApplicationEvent</span>&gt; </span>&#123;<br><br>	<span class="hljs-comment">// 当容器中发布此事件以后，下面这个方法就会被触发</span><br>	<span class="hljs-meta">@Override</span><br>	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onApplicationEvent</span><span class="hljs-params">(ApplicationEvent event)</span> </span>&#123;<br>		System.out.println(<span class="hljs-string">&quot;收到事件：&quot;</span> + event);<br>	&#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>Spring默认的四个事件：</strong></p>
<ul>
<li>ContextClosedEvent  容器关闭事件</li>
<li>ContextRefreshedEvent  容器刷新事件</li>
<li>ContextStartedEvent  容器开始事件</li>
<li>ContextStoppedEvent  容器停止事件</li>
</ul>
<p><strong>发布自定义事件</strong></p>
<ol>
<li>写一个监听器来监听某个事件。当然了，监听的这个事件必须是ApplicationEvent及其子类。</li>
<li>把监听器加入到容器中，这样Spring才能知道有这样一个监听器。</li>
<li>只要容器中有相关事件发布，那么我们就能监听到这个事件。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">IOCTest_Ext</span> </span>&#123;<br>	<br>	<span class="hljs-meta">@Test</span><br>	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span> </span>&#123;<br>		AnnotationConfigApplicationContext applicationContext = <span class="hljs-keyword">new</span> AnnotationConfigApplicationContext(ExtConfig.class);  <span class="hljs-comment">// 触发容器开始事件</span><br>		<br>        applicationContext.publishEvent(<span class="hljs-keyword">new</span> ApplicationEvent(<span class="hljs-keyword">new</span> String(<span class="hljs-string">&quot;diy事件&quot;</span>)));<br>        <br>		applicationContext.close();  <span class="hljs-comment">// 触发容器关闭事件</span><br>	&#125;<br><br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>事件监听机制原理</strong></p>
<ol>
<li>IOC容器启动过程中，通过在refresh()方法中调用registerListeners()方法，将所有的监听器注册到事件派发器中去</li>
<li>事件发布时，首先获取到事件派发器，遍历所有监听器，向所有符合条件的监听器派发事件</li>
<li>监听器获取到事件后执行onApplicationEvent方法</li>
</ol>
<h3 id="3-9-EventListener"><a href="#3-9-EventListener" class="headerlink" title="3.9 @EventListener"></a>3.9 @EventListener</h3><p>除了通过实现ApplicationListener接口完成事件监听以外，还可以通过使用@EventListener注解，让任意方法都能监听事件。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Service</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserService</span> </span>&#123;<br><br>    <span class="hljs-comment">// @EventListener(classes=ApplicationEvent.class)</span><br>    <span class="hljs-meta">@EventListener(classes=&#123;ApplicationEvent.class&#125;)</span>  <span class="hljs-comment">// 可以指定监听多个事件</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">listen</span><span class="hljs-params">()</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;UserService...监听到的事件：&quot;</span> + event);<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>@EventListener注解原理</strong></p>
<p>Spring会使用EventListenerMethodProcessor这个处理器来解析方法上的@EventListener注解。</p>
<p>EventListenerMethodProcessor实现了一个接口，叫SmartInitializingSingleton，这个接口有一个afterSingletonsInstantiated方法，该方法是在所有的单实例bean已经全部被创建完以后才会被执行。</p>
<p>在创建好所有的单实例bean后，判断每一个bean对象是否是SmartInitializingSingleton这个接口类型的，如果是，那么便调用它里面的afterSingletonsInstantiated方法，而该方法就是SmartInitializingSingleton接口中定义的方法。</p>
<h2 id="4-完整生命周期小结"><a href="#4-完整生命周期小结" class="headerlink" title="4 完整生命周期小结"></a>4 完整生命周期小结</h2><p><strong>1、prepareRefresh();  刷新前的预处理</strong></p>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><span class="hljs-bullet">1.</span> initPropertySources()初始化一些属性设置;子类自定义个性化的属性设置方法；<br><span class="hljs-bullet">2.</span> getEnvironment().validateRequiredProperties();检验属性的合法等<br><span class="hljs-bullet">3.</span> earlyApplicationEvents= new LinkedHashSet<span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">ApplicationEvent</span>&gt;</span></span>(); 保存容器中的一些早期的事件<br></code></pre></td></tr></table></figure>

<p><strong>2、obtainFreshBeanFactory();  获取BeanFactory</strong></p>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><span class="hljs-bullet">1.</span> refreshBeanFactory();刷新【创建】BeanFactory；<br><span class="hljs-bullet">	-</span> 创建了一个this.beanFactory = new DefaultListableBeanFactory();<br><span class="hljs-bullet">	-</span> 设置id；<br><span class="hljs-bullet">2.</span> getBeanFactory();返回刚才GenericApplicationContext创建的BeanFactory对象；<br><span class="hljs-bullet">3.</span> 将创建的BeanFactory【DefaultListableBeanFactory】返回；<br></code></pre></td></tr></table></figure>

<p><strong>3、prepareBeanFactory(beanFactory);  BeanFactory的预准备工作（BeanFactory进行一些设置）</strong></p>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><span class="hljs-bullet">1.</span> 设置BeanFactory的类加载器、支持表达式解析器...2. 添加部分BeanPostProcessor【ApplicationContextAwareProcessor】3. 设置忽略的自动装配的接口EnvironmentAware、EmbeddedValueResolverAware、xxx；4. 注册可以解析的自动装配；我们能直接在任何组件中自动注入：	- BeanFactory、ResourceLoader、ApplicationEventPublisher、ApplicationContext5. 添加BeanPostProcessor【ApplicationListenerDetector】6. 添加编译时的AspectJ；7. 给BeanFactory中注册一些能用的组件；    - environment【ConfigurableEnvironment】、    - systemProperties【Map<span class="xml">&lt;String, Object&gt;</span>】、    - systemEnvironment【Map<span class="xml">&lt;String, Object&gt;</span>】<br></code></pre></td></tr></table></figure>

<p><strong>4、postProcessBeanFactory(beanFactory);  BeanFactory准备工作完成后进行的后置处理工作</strong></p>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><span class="hljs-bullet">-</span> 子类通过重写这个方法来在BeanFactory创建并预准备完成以后做进一步的设置<br></code></pre></td></tr></table></figure>

<p>==以上是BeanFactory的创建及预准备工作==</p>
<p><strong>5、invokeBeanFactoryPostProcessors(beanFactory);  执行BeanFactoryPostProcessor的方法</strong></p>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs markdown">BeanFactoryPostProcessor：BeanFactory的后置处理器。在BeanFactory标准初始化之后执行的；<br>两个接口：BeanFactoryPostProcessor、BeanDefinitionRegistryPostProcessor<br><span class="hljs-bullet">1.</span> 先执行BeanDefinitionRegistryPostProcessor<br><span class="hljs-bullet">    -</span> 获取所有的BeanDefinitionRegistryPostProcessor；<br><span class="hljs-bullet">    -</span> 看先执行实现了PriorityOrdered优先级接口的BeanDefinitionRegistryPostProcessor、<br><span class="hljs-code">    	postProcessor.postProcessBeanDefinitionRegistry(registry)</span><br><span class="hljs-code">    - 在执行实现了Ordered顺序接口的BeanDefinitionRegistryPostProcessor；</span><br><span class="hljs-code">    	postProcessor.postProcessBeanDefinitionRegistry(registry)</span><br><span class="hljs-code">    - 最后执行没有实现任何优先级或者是顺序接口的BeanDefinitionRegistryPostProcessors；</span><br><span class="hljs-code">    	postProcessor.postProcessBeanDefinitionRegistry(registry)</span><br><span class="hljs-code">2. 加载BeanDefinition</span><br><span class="hljs-code">3. 再执行BeanFactoryPostProcessor的方法</span><br><span class="hljs-code">	- 获取所有的BeanFactoryPostProcessor</span><br><span class="hljs-code">    - 看先执行实现了PriorityOrdered优先级接口的BeanFactoryPostProcessor、</span><br><span class="hljs-code">		postProcessor.postProcessBeanFactory()</span><br><span class="hljs-code">	- 在执行实现了Ordered顺序接口的BeanFactoryPostProcessor；</span><br><span class="hljs-code">		postProcessor.postProcessBeanFactory()</span><br><span class="hljs-code">	- 最后执行没有实现任何优先级或者是顺序接口的BeanFactoryPostProcessor；</span><br><span class="hljs-code">		postProcessor.postProcessBeanFactory()</span><br></code></pre></td></tr></table></figure>

<p><strong>6、registerBeanPostProcessors(beanFactory);  注册BeanPostProcessor(Bean的后置处理器)【 intercept bean creation】</strong></p>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><span class="hljs-bullet">-</span> 不同接口类型的BeanPostProcessor；在Bean创建前后的执行时机是不一样的<br><span class="hljs-bullet">    -</span> BeanPostProcessor、<br><span class="hljs-bullet">    -</span> DestructionAwareBeanPostProcessor、<br><span class="hljs-bullet">    -</span> InstantiationAwareBeanPostProcessor、<br><span class="hljs-bullet">    -</span> SmartInstantiationAwareBeanPostProcessor、<br><span class="hljs-bullet">    -</span> MergedBeanDefinitionPostProcessor【internalPostProcessors】、<br><span class="hljs-code">		</span><br><span class="hljs-code">1. 获取所有的 BeanPostProcessor;后置处理器都默认可以通过PriorityOrdered、Ordered接口来执行优先级</span><br><span class="hljs-code">2. 先注册PriorityOrdered优先级接口的BeanPostProcessor；</span><br><span class="hljs-code">	把每一个BeanPostProcessor；添加到BeanFactory中</span><br><span class="hljs-code">    beanFactory.addBeanPostProcessor(postProcessor);</span><br><span class="hljs-code">3. 再注册Ordered接口的</span><br><span class="hljs-code">4. 最后注册没有实现任何优先级接口的</span><br><span class="hljs-code">5. 最终注册MergedBeanDefinitionPostProcessor；</span><br><span class="hljs-code">6. 注册一个ApplicationListenerDetector；来在Bean创建完成后检查是否是ApplicationListener，如果是，applicationContext.addApplicationListener((ApplicationListener&lt;?&gt;) bean);</span><br></code></pre></td></tr></table></figure>

<p><strong>7、initMessageSource();  初始化MessageSource组件(做国际化功能；消息绑定，消息解析)</strong></p>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><span class="hljs-bullet">1.</span> 获取BeanFactory<br><span class="hljs-bullet">2.</span> 看容器中是否有id为messageSource的，类型是MessageSource的组件<br><span class="hljs-bullet">	-</span> 如果有赋值给messageSource，如果没有自己创建一个DelegatingMessageSource；<br><span class="hljs-bullet">		-</span> MessageSource：取出国际化配置文件中的某个key的值；能按照区域信息获取；<br><span class="hljs-bullet">3.</span> 把创建好的MessageSource注册在容器中，以后获取国际化配置文件的值的时候，可以自动注入MessageSource；<br><span class="hljs-bullet">	-</span> beanFactory.registerSingleton(MESSAGE<span class="hljs-emphasis">_SOURCE_</span>BEAN<span class="hljs-emphasis">_NAME, this.messageSource);	</span><br><span class="hljs-emphasis">	- MessageSource.getMessage(String code, Object[] args, String defaultMessage, Locale locale);</span><br></code></pre></td></tr></table></figure>

<p><strong>8、initApplicationEventMulticaster();  初始化事件派发器</strong></p>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><span class="hljs-bullet">1.</span> 获取BeanFactory<br><span class="hljs-bullet">2.</span> 从BeanFactory中获取applicationEventMulticaster的ApplicationEventMulticaster；<br><span class="hljs-bullet">3.</span> 如果上一步没有配置；创建一个SimpleApplicationEventMulticaster<br><span class="hljs-bullet">4.</span> 将创建的ApplicationEventMulticaster添加到BeanFactory中，以后其他组件直接自动注入<br></code></pre></td></tr></table></figure>

<p><strong>9、onRefresh();  留给子容器（子类）</strong></p>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><span class="hljs-bullet">-</span> 子类重写这个方法，在容器刷新的时候可以自定义逻辑；<br></code></pre></td></tr></table></figure>

<p><strong>10、registerListeners();  从容器中将所有项目里面的ApplicationListener注册到事件派发器</strong></p>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><span class="hljs-bullet">1.</span> 从容器中拿到所有的ApplicationListener<br><span class="hljs-bullet">2.</span> 将每个监听器添加到事件派发器中；<br><span class="hljs-bullet">	-</span> getApplicationEventMulticaster().addApplicationListenerBean(listenerBeanName);<br><span class="hljs-bullet">3.</span> 派发之前步骤产生的事件；<br></code></pre></td></tr></table></figure>

<p><strong>11、finishBeanFactoryInitialization(beanFactory);  初始化所有剩下的单实例bean</strong></p>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs markdown">beanFactory.preInstantiateSingletons();  初始化后剩下的单实例bean<br><span class="hljs-bullet">1.</span> 获取容器中的所有Bean，依次进行初始化和创建对象<br><span class="hljs-bullet">2.</span> 获取Bean的定义信息；RootBeanDefinition<br><span class="hljs-bullet">3.</span> Bean不是抽象的，是单实例的，不是懒加载；<br><span class="hljs-code">	1）、判断是否是FactoryBean；是否是实现FactoryBean接口的Bean；</span><br><span class="hljs-code">	2）、不是工厂Bean。利用getBean(beanName);创建对象</span><br><span class="hljs-code">		0、getBean(beanName)； ioc.getBean();</span><br><span class="hljs-code">		1、doGetBean(name, null, null, false);</span><br><span class="hljs-code">		2、先获取缓存中保存的单实例Bean。如果能获取到说明这个Bean之前被创建过（所有创建过的单实例Bean都会被缓存起来）</span><br><span class="hljs-code">			从private final Map&lt;String, Object&gt; singletonObjects = new ConcurrentHashMap&lt;String, Object&gt;(256);获取的</span><br><span class="hljs-code">		3、缓存中获取不到，开始Bean的创建对象流程；</span><br><span class="hljs-code">		4、标记当前bean已经被创建</span><br><span class="hljs-code">		5、获取Bean的定义信息；</span><br><span class="hljs-code">		6、【获取当前Bean依赖的其他Bean;如果有按照getBean()把依赖的Bean先创建出来；】</span><br><span class="hljs-code">		7、启动单实例Bean的创建流程；</span><br><span class="hljs-code">			1）、createBean(beanName, mbd, args);</span><br><span class="hljs-code">			2）、Object bean = resolveBeforeInstantiation(beanName, mbdToUse);让BeanPostProcessor先拦截返回代理对象；</span><br><span class="hljs-code">				【InstantiationAwareBeanPostProcessor】：提前执行；</span><br><span class="hljs-code">				先触发：postProcessBeforeInstantiation()；</span><br><span class="hljs-code">				如果有返回值：触发postProcessAfterInitialization()；</span><br><span class="hljs-code">			3）、如果前面的InstantiationAwareBeanPostProcessor没有返回代理对象；调用4）</span><br><span class="hljs-code">			4）、Object beanInstance = doCreateBean(beanName, mbdToUse, args);创建Bean</span><br><span class="hljs-code">				 1）、【创建Bean实例】；createBeanInstance(beanName, mbd, args);</span><br><span class="hljs-code">				 	利用工厂方法或者对象的构造器创建出Bean实例；</span><br><span class="hljs-code">				 2）、applyMergedBeanDefinitionPostProcessors(mbd, beanType, beanName);</span><br><span class="hljs-code">				 	调用MergedBeanDefinitionPostProcessor的postProcessMergedBeanDefinition(mbd, beanType, beanName);</span><br><span class="hljs-code">				 3）、【Bean属性赋值】populateBean(beanName, mbd, instanceWrapper);</span><br><span class="hljs-code">				 	赋值之前：</span><br><span class="hljs-code">				 	1）、拿到InstantiationAwareBeanPostProcessor后置处理器；</span><br><span class="hljs-code">				 		postProcessAfterInstantiation()；</span><br><span class="hljs-code">				 	2）、拿到InstantiationAwareBeanPostProcessor后置处理器；</span><br><span class="hljs-code">				 		postProcessPropertyValues()；</span><br><span class="hljs-code">				 	=====赋值之前：=====</span><br><span class="hljs-code">				 	3）、应用Bean属性的值；为属性利用setter方法等进行赋值；</span><br><span class="hljs-code">				 		applyPropertyValues(beanName, mbd, bw, pvs);</span><br><span class="hljs-code">				 4）、【Bean初始化】initializeBean(beanName, exposedObject, mbd);</span><br><span class="hljs-code">				 	1）、【执行Aware接口方法】invokeAwareMethods(beanName, bean);执行xxxAware接口的方法</span><br><span class="hljs-code">				 		BeanNameAware\BeanClassLoaderAware\BeanFactoryAware</span><br><span class="hljs-code">				 	2）、【执行后置处理器初始化之前】applyBeanPostProcessorsBeforeInitialization(wrappedBean, beanName);</span><br><span class="hljs-code">				 		BeanPostProcessor.postProcessBeforeInitialization（）;</span><br><span class="hljs-code">				 	3）、【执行初始化方法】invokeInitMethods(beanName, wrappedBean, mbd);</span><br><span class="hljs-code">				 		1）、是否是InitializingBean接口的实现；执行接口规定的初始化；</span><br><span class="hljs-code">				 		2）、是否自定义初始化方法；</span><br><span class="hljs-code">				 	4）、【执行后置处理器初始化之后】applyBeanPostProcessorsAfterInitialization</span><br><span class="hljs-code">				 		BeanPostProcessor.postProcessAfterInitialization()；</span><br><span class="hljs-code">				 5）、注册Bean的销毁方法；</span><br><span class="hljs-code">			5）、将创建的Bean添加到缓存中singletonObjects；</span><br><span class="hljs-code">		ioc容器就是这些Map；很多的Map里面保存了单实例Bean，环境信息。。。。；</span><br><span class="hljs-code"></span><br>所有Bean都利用getBean创建完成以后；<br><span class="hljs-bullet">1.</span> 检查所有的Bean是否是SmartInitializingSingleton接口的；如果是；就执行afterSingletonsInstantiated();<br></code></pre></td></tr></table></figure>

<p><strong>12、finishRefresh();  完成BeanFactory的初始化创建工作、IOC容器就创建完成</strong></p>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><span class="hljs-bullet">1.</span> initLifecycleProcessor();初始化和生命周期有关的后置处理器；LifecycleProcessor<br><span class="hljs-bullet">	-</span> 默认从容器中找是否有lifecycleProcessor的组件【LifecycleProcessor】；如果没有，new DefaultLifecycleProcessor();<br><span class="hljs-bullet">	-</span> 加入到容器；<br><span class="hljs-bullet">	-</span> 写一个LifecycleProcessor的实现类，可以在BeanFactory<br><span class="hljs-bullet">		-</span> void onRefresh();<br><span class="hljs-bullet">		-</span> void onClose();	<br><span class="hljs-bullet">2.</span> getLifecycleProcessor().onRefresh();<br><span class="hljs-bullet">	-</span> 拿到前面定义的生命周期处理器（BeanFactory）；回调onRefresh()；<br><span class="hljs-bullet">3.</span> publishEvent(new ContextRefreshedEvent(this));发布容器刷新完成事件；<br><span class="hljs-bullet">4.</span> liveBeansView.registerApplicationContext(this);<br></code></pre></td></tr></table></figure>

<p><img src="/images/Spring%E6%B3%A8%E8%A7%A3%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0.assets/image-20210409173738495.png" srcset="/img/loading.gif" lazyload alt="image-20210409173738495"></p>
<p><strong>总结：</strong></p>
<ol>
<li>Spring容器在启动的时候，先会保存所有注册进来的Bean的定义信息；<ul>
<li>xml注册bean；<code>&lt;bean&gt;</code></li>
<li>注解注册Bean；@Service、@Component、@Bean、xxx</li>
</ul>
</li>
<li>Spring容器会合适的时机创建这些Bean<ul>
<li>用到这个bean的时候；利用getBean创建bean；创建好以后保存在容器中；</li>
<li>统一创建剩下所有的bean的时候；finishBeanFactoryInitialization()；</li>
</ul>
</li>
<li>后置处理器；BeanPostProcessor<ul>
<li>每一个bean创建完成，都会使用各种后置处理器进行处理；来增强bean的功能；<ul>
<li>AutowiredAnnotationBeanPostProcessor:处理自动注入</li>
<li>AnnotationAwareAspectJAutoProxyCreator:来做AOP功能；</li>
<li>…</li>
</ul>
</li>
<li>增强的功能注解：<ul>
<li>AsyncAnnotationBeanPostProcessor</li>
<li>…</li>
</ul>
</li>
</ul>
</li>
<li>事件驱动模型；<ul>
<li>ApplicationListener；事件监听；</li>
<li>ApplicationEventMulticaster；事件派发：</li>
</ul>
</li>
</ol>

            </div>
            <hr>
            <div>
              <div class="post-metas mb-3">
                
                  <div class="post-meta mr-3">
                    <i class="iconfont icon-category"></i>
                    
                      <a class="hover-with-bg" href="/categories/java/">java</a>
                    
                  </div>
                
                
                  <div class="post-meta">
                    <i class="iconfont icon-tags"></i>
                    
                      <a class="hover-with-bg" href="/tags/spring/">spring</a>
                    
                  </div>
                
              </div>
              
                <p class="note note-warning">
                  
                    本博客所有文章除特别声明外，均采用 <a target="_blank" href="https://creativecommons.org/licenses/by-sa/4.0/deed.zh" rel="nofollow noopener noopener">CC BY-SA 4.0 协议</a> ，转载请注明出处！
                  
                </p>
              
              
                <div class="post-prevnext">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2021/10/20/Git%E7%AC%94%E8%AE%B0/">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">Git笔记</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2021/10/02/CMake%E7%AC%94%E8%AE%B0/">
                        <span class="hidden-mobile">CMake笔记</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>
    
      <div class="d-none d-lg-block col-lg-2 toc-container" id="toc-ctn">
        <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;目录</p>
  <div class="toc-body" id="toc-body"></div>
</div>

      </div>
    
  </div>
</div>

<!-- Custom -->


    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v"
                 for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>
    

    
  </main>

  <footer class="text-center mt-5 py-3">
  <div class="footer-content">
     <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
  </div>
  
  <div class="statistics">
    
    

    
      
        <!-- 不蒜子统计PV -->
        <span id="busuanzi_container_site_pv" style="display: none">
            总访问量 
            <span id="busuanzi_value_site_pv"></span>
             次
          </span>
      
      
        <!-- 不蒜子统计UV -->
        <span id="busuanzi_container_site_uv" style="display: none">
            总访客数 
            <span id="busuanzi_value_site_uv"></span>
             人
          </span>
      
    
  </div>


  

  
</footer>


  <!-- SCRIPTS -->
  
  <script  src="https://cdn.jsdelivr.net/npm/nprogress@0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/nprogress@0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js" ></script>
<script  src="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>

<!-- Plugins -->


  <script  src="/js/local-search.js" ></script>



  
    <script  src="/js/img-lazyload.js" ></script>
  



  



  
    <script  src="https://cdn.jsdelivr.net/npm/tocbot@4/dist/tocbot.min.js" ></script>
  
  
    <script  src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3/dist/jquery.fancybox.min.js" ></script>
  
  
    <script  src="https://cdn.jsdelivr.net/npm/anchor-js@4/anchor.min.js" ></script>
  
  
    <script defer src="https://cdn.jsdelivr.net/npm/clipboard@2/dist/clipboard.min.js" ></script>
  



  <script defer src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" ></script>




  <script  src="https://cdn.jsdelivr.net/npm/typed.js@2/lib/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var title = document.getElementById('subtitle').title;
      
      typing(title)
      
    })(window, document);
  </script>












  

  

  

  

  

  





<!-- 主题的启动项 保持在最底部 -->
<script  src="/js/boot.js" ></script>


</body>
</html>
