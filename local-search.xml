<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>卡尔曼滤波</title>
    <link href="/2021/11/23/%E5%8D%A1%E5%B0%94%E6%9B%BC%E6%BB%A4%E6%B3%A2/"/>
    <url>/2021/11/23/%E5%8D%A1%E5%B0%94%E6%9B%BC%E6%BB%A4%E6%B3%A2/</url>
    
    <content type="html"><![CDATA[<h1 id="卡尔曼滤波-Kalman-Filter"><a href="#卡尔曼滤波-Kalman-Filter" class="headerlink" title="卡尔曼滤波 Kalman Filter"></a>卡尔曼滤波 Kalman Filter</h1><p>视频教程地址：<a href="https://space.bilibili.com/230105574/channel/detail?cid=139198&amp;ctype=0">https://space.bilibili.com/230105574/channel/detail?cid=139198&amp;ctype=0</a></p><p>卡尔曼滤波五个公式各参数意义：<a href="https://blog.csdn.net/wccsu1994/article/details/84643221">https://blog.csdn.net/wccsu1994/article/details/84643221</a></p><p><img src="/images/%E5%8D%A1%E5%B0%94%E6%9B%BC%E6%BB%A4%E6%B3%A2.assets/image-20211121212609532.png" alt="image-20211121212609532"></p><p><img src="/images/%E5%8D%A1%E5%B0%94%E6%9B%BC%E6%BB%A4%E6%B3%A2.assets/image-20211121212701116.png" alt="image-20211121212701116"></p><h2 id="第一讲-递归算法"><a href="#第一讲-递归算法" class="headerlink" title="第一讲 递归算法"></a>第一讲 递归算法</h2><p>最初的引入</p><p><img src="/images/%E5%8D%A1%E5%B0%94%E6%9B%BC%E6%BB%A4%E6%B3%A2.assets/image-20211120202524044.png" alt="image-20211120202524044"></p><p>卡尔曼增益系数分析</p><p><img src="/images/%E5%8D%A1%E5%B0%94%E6%9B%BC%E6%BB%A4%E6%B3%A2.assets/image-20211120202442837.png" alt="image-20211120202442837"></p><p>卡尔曼滤波基本步骤、小案例</p><p><img src="/images/%E5%8D%A1%E5%B0%94%E6%9B%BC%E6%BB%A4%E6%B3%A2.assets/image-20211120202905489.png" alt="image-20211120202905489"></p><p>案例手算演示</p><p><img src="/images/%E5%8D%A1%E5%B0%94%E6%9B%BC%E6%BB%A4%E6%B3%A2.assets/image-20211120203118039.png" alt="image-20211120203118039"></p><p>案例excel演算结果</p><p><img src="/images/%E5%8D%A1%E5%B0%94%E6%9B%BC%E6%BB%A4%E6%B3%A2.assets/image-20211120203239474.png" alt="image-20211120203239474"></p><h2 id="第二讲-数学基础"><a href="#第二讲-数学基础" class="headerlink" title="第二讲 数学基础"></a>第二讲 数学基础</h2><blockquote><p><strong>数据融合、协方差矩阵、状态空间方程</strong></p></blockquote><p><strong>数据融合</strong></p><p>数据融合的原理：使得融合后数据的误差方差最小</p><p><img src="/images/%E5%8D%A1%E5%B0%94%E6%9B%BC%E6%BB%A4%E6%B3%A2.assets/image-20211120203653141.png" alt="image-20211120203653141"></p><p>融合数据方差推算</p><p><img src="/images/%E5%8D%A1%E5%B0%94%E6%9B%BC%E6%BB%A4%E6%B3%A2.assets/image-20211120204347570.png" alt="image-20211120204347570"></p><p><strong>协方差矩阵</strong></p><p>协方差矩阵概念、矩阵计算方式</p><p><img src="/images/%E5%8D%A1%E5%B0%94%E6%9B%BC%E6%BB%A4%E6%B3%A2.assets/image-20211120211344073.png" alt="image-20211120211344073"></p><p>excel演示协方差矩阵</p><p><img src="/images/%E5%8D%A1%E5%B0%94%E6%9B%BC%E6%BB%A4%E6%B3%A2.assets/image-20211120205516430.png" alt="image-20211120205516430"></p><p><strong>状态空间方程</strong></p><p>弹簧振动系统案例</p><p><img src="/images/%E5%8D%A1%E5%B0%94%E6%9B%BC%E6%BB%A4%E6%B3%A2.assets/image-20211120213548403.png" alt="image-20211120213548403"></p><p>连续变量和离散型变量的矩阵形式表达</p><p><img src="/images/%E5%8D%A1%E5%B0%94%E6%9B%BC%E6%BB%A4%E6%B3%A2.assets/image-20211120213916548.png" alt="image-20211120213916548"></p><h2 id="第三讲-卡尔曼增益数学推导"><a href="#第三讲-卡尔曼增益数学推导" class="headerlink" title="第三讲 卡尔曼增益数学推导"></a>第三讲 卡尔曼增益数学推导</h2><p>画红框的是书上给出的卡尔曼滤波器公式</p><p><img src="/images/%E5%8D%A1%E5%B0%94%E6%9B%BC%E6%BB%A4%E6%B3%A2.assets/image-20211121161436600.png" alt="image-20211121161436600"></p><p>目标：寻找合适的k_k，使得P的迹最小</p><p><img src="/images/%E5%8D%A1%E5%B0%94%E6%9B%BC%E6%BB%A4%E6%B3%A2.assets/image-20211121161852537.png" alt="image-20211121161852537"></p><p>推出符合目标的卡尔曼增益k_k</p><p><img src="/images/%E5%8D%A1%E5%B0%94%E6%9B%BC%E6%BB%A4%E6%B3%A2.assets/image-20211121164223698.png" alt="image-20211121164223698"></p><h2 id="第四讲-误差协方差矩阵数学推导"><a href="#第四讲-误差协方差矩阵数学推导" class="headerlink" title="第四讲 误差协方差矩阵数学推导"></a>第四讲 误差协方差矩阵数学推导</h2><p>梳理</p><p><img src="/images/%E5%8D%A1%E5%B0%94%E6%9B%BC%E6%BB%A4%E6%B3%A2.assets/image-20211121171509996.png" alt="image-20211121171509996"></p><p>P_k先验推导</p><p><img src="/images/%E5%8D%A1%E5%B0%94%E6%9B%BC%E6%BB%A4%E6%B3%A2.assets/image-20211121171917274.png" alt="image-20211121171917274"></p><p>P_k后验更新、完整公式整理</p><p><img src="/images/%E5%8D%A1%E5%B0%94%E6%9B%BC%E6%BB%A4%E6%B3%A2.assets/image-20211121172209639.png" alt="image-20211121172209639"></p><h2 id="第五讲-二维实例演算"><a href="#第五讲-二维实例演算" class="headerlink" title="第五讲 二维实例演算"></a>第五讲 二维实例演算</h2><p>excel程序下载链接：<a href="https://pan.baidu.com/s/1GdJe2eWIlaQrk2nrjemRCQ">https://pan.baidu.com/s/1GdJe2eWIlaQrk2nrjemRCQ</a> 提取码：txn3 （已放进asset文件夹）  $6.5 + (0.2<strong>2 / (0.2</strong>2 + 0.4**2)) * (7.3 - 6.5) = 6.66$ </p><p><img src="/images/%E5%8D%A1%E5%B0%94%E6%9B%BC%E6%BB%A4%E6%B3%A2.assets/image-20211120225536532.png" alt="image-20211120225536532"></p><p>一个简单而又不简单的例子（一个人在走路，同时通过天上卫星可观测其位置和速度）</p><p><img src="/images/%E5%8D%A1%E5%B0%94%E6%9B%BC%E6%BB%A4%E6%B3%A2.assets/image-20211120231344535.png" alt="image-20211120231344535"></p><p>基础公式</p><p><img src="/images/%E5%8D%A1%E5%B0%94%E6%9B%BC%E6%BB%A4%E6%B3%A2.assets/image-20211120232119734.png" alt="image-20211120232119734"></p><p>excel演示</p><p><img src="/images/%E5%8D%A1%E5%B0%94%E6%9B%BC%E6%BB%A4%E6%B3%A2.assets/image-20211120232744596.png" alt="image-20211120232744596"></p><p>个人任务：python实现一下</p><p>别人写的：<a href="https://github.com/liuchangji/2D-Kalman-Filter-Example_Dr_CAN_in_python">https://github.com/liuchangji/2D-Kalman-Filter-Example_Dr_CAN_in_python</a></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#! python3</span><br><span class="hljs-comment"># -- encoding: utf-8 --</span><br><span class="hljs-comment"># @Author: qizidog</span><br><span class="hljs-comment"># @Time:   2021/11/21 22:10:07</span><br><br><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br><span class="hljs-keyword">from</span> matplotlib <span class="hljs-keyword">import</span> pyplot <span class="hljs-keyword">as</span> plt<br><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">disturb</span>(<span class="hljs-params">scale</span>):</span><br>    <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">    返回一个指定标准差的正太扰动</span><br><span class="hljs-string">    :param scale: 标准差</span><br><span class="hljs-string">    :return:</span><br><span class="hljs-string">    &quot;&quot;&quot;</span><br>    <span class="hljs-keyword">return</span> np.random.normal(<span class="hljs-number">0</span>, scale)<br><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">calc_prior_hx</span>(<span class="hljs-params">A, hx_k_1, B, u_k_1</span>):</span><br>    <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">    计算先验估计值</span><br><span class="hljs-string">    :param A: 预测使用的状态转移矩阵</span><br><span class="hljs-string">    :param hx_k_1: 上一次的后验估计值</span><br><span class="hljs-string">    :param B: 将输入转为状态的转移矩阵</span><br><span class="hljs-string">    :param u_k_1: 系统输入</span><br><span class="hljs-string">    :return: 先验估计值</span><br><span class="hljs-string">    &quot;&quot;&quot;</span><br>    hx_prior_k = np.dot(A, hx_k_1)<br>    <span class="hljs-keyword">if</span> B <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">None</span> <span class="hljs-keyword">and</span> u_k_1 <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">None</span>:<br>        hx_prior_k += np.dot(B, u_k_1)<br>    <span class="hljs-keyword">return</span> hx_prior_k<br><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">calc_prior_P</span>(<span class="hljs-params">A, P_k_1, Q</span>):</span><br>    <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">    计算先验状态估计协方差矩阵</span><br><span class="hljs-string">    :param A: 预测使用的状态转移矩阵</span><br><span class="hljs-string">    :param P_k_1: 上一次的后验状态估计协方差矩阵</span><br><span class="hljs-string">    :param Q: 预测过程的噪声协方差矩阵</span><br><span class="hljs-string">    :return: 先验的状态估计协方差矩阵</span><br><span class="hljs-string">    &quot;&quot;&quot;</span><br>    P_prior_k = np.dot(A, P_k_1)<br>    P_prior_k = np.dot(P_prior_k, A.T) + Q<br>    <span class="hljs-keyword">return</span> P_prior_k<br><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">kalman_gain</span>(<span class="hljs-params">P_prior_k, H, R</span>):</span><br>    <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">    计算kalman gain卡尔曼增益</span><br><span class="hljs-string">    :param P_prior_k: 先验的状态估计协方差矩阵</span><br><span class="hljs-string">    :param H: 状态变量到测量值的转换矩阵</span><br><span class="hljs-string">    :param R: 测量噪声协方差矩阵</span><br><span class="hljs-string">    :return: 卡尔曼增益系数矩阵</span><br><span class="hljs-string">    &quot;&quot;&quot;</span><br>    up = np.dot(P_prior_k, H.T)<br>    down = np.dot(H, P_prior_k)<br>    down = np.dot(down, H.T) + R<br>    K_k = np.dot(up, np.linalg.inv(down))  <span class="hljs-comment"># 矩阵除法等于乘以逆矩阵</span><br>    <span class="hljs-keyword">return</span> K_k<br><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">calc_posterior_hx</span>(<span class="hljs-params">hx_prior_k, K_k, z_k, H</span>):</span><br>    <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">    计算后验估计值</span><br><span class="hljs-string">    :param hx_prior_k: 先验估计值</span><br><span class="hljs-string">    :param K_k: 卡尔曼增益系数矩阵</span><br><span class="hljs-string">    :param z_k: 测量值</span><br><span class="hljs-string">    :param H: 状态变量到测量值的转换矩阵</span><br><span class="hljs-string">    :return: 后验估计值</span><br><span class="hljs-string">    &quot;&quot;&quot;</span><br>    hx_k = hx_prior_k + np.dot(K_k, (z_k - np.dot(H, hx_prior_k)))<br>    <span class="hljs-keyword">return</span> hx_k<br><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">update_posterior_P</span>(<span class="hljs-params">K_k, H, P_prior_k</span>):</span><br>    <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">    更新后验状态估计协方差矩阵</span><br><span class="hljs-string">    :param K_k: 卡尔曼增益</span><br><span class="hljs-string">    :param H: 状态变量到测量值的转换矩阵</span><br><span class="hljs-string">    :param P_prior_k: 先验的状态估计协方差矩阵</span><br><span class="hljs-string">    :return: 后验状态估计协方差矩阵</span><br><span class="hljs-string">    &quot;&quot;&quot;</span><br>    P_k = P_prior_k - np.dot(np.dot(K_k, H), P_prior_k)<br>    <span class="hljs-keyword">return</span> P_k<br><br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&quot;__main__&quot;</span>:<br>    <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">    kalman filter 案例实践</span><br><span class="hljs-string">    &quot;&quot;&quot;</span><br>    <span class="hljs-comment"># -----初始化用于画图的数据列表-----</span><br>    position_true = []<br>    position_measure = []<br>    position_prior_est = []<br>    position_posterior_est = []<br><br>    speed_true = []<br>    speed_measure = []<br>    speed_prior_est = []<br>    speed_posterior_est = []<br><br>    <span class="hljs-comment"># -----一些初始值-----</span><br>    <span class="hljs-comment"># A 用于计算预测值的状态转移矩阵</span><br>    A = np.array([<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>]).reshape([<span class="hljs-number">2</span>, <span class="hljs-number">2</span>])<br>    B, u_k_1 = <span class="hljs-literal">None</span>, <span class="hljs-literal">None</span><br>    <span class="hljs-comment"># 初始的位置和速度估计值</span><br>    hx_k_1 = np.array([<span class="hljs-number">0</span>, <span class="hljs-number">1</span>]).reshape([<span class="hljs-number">2</span>, <span class="hljs-number">1</span>])<br>    <span class="hljs-comment"># 状态估计协方差矩阵P初始化</span><br>    P_k_1 = np.array([<span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>]).reshape([<span class="hljs-number">2</span>, <span class="hljs-number">2</span>])<br>    <span class="hljs-comment"># 过程噪声协方差矩阵Q，p(w)~N(0,Q)，噪声来自预测的不确定性</span><br>    Q = np.array([<span class="hljs-number">5</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">5</span>]).reshape((<span class="hljs-number">2</span>, <span class="hljs-number">2</span>))  <span class="hljs-comment"># 个人认为预测的误差较大</span><br>    <span class="hljs-comment"># 状态观测矩阵</span><br>    H = np.array([<span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>]).reshape([<span class="hljs-number">2</span>, <span class="hljs-number">2</span>])<br>    <span class="hljs-comment"># 测量噪声协方差矩阵R，p(v)~N(0,R)</span><br>    R = np.array([[<span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>]]).reshape([<span class="hljs-number">2</span>, <span class="hljs-number">2</span>])  <span class="hljs-comment"># 个人认为测量的误差比较小</span><br><br>    <span class="hljs-comment"># 初始位置、速度的真值（随便取的 x=3, v=3）</span><br>    x_k = np.array([<span class="hljs-number">3</span>, <span class="hljs-number">3</span>]).reshape([<span class="hljs-number">2</span>, <span class="hljs-number">1</span>]) + np.array([disturb(Q[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>]), disturb(Q[<span class="hljs-number">1</span>][<span class="hljs-number">1</span>])])  <span class="hljs-comment"># 加点扰动</span><br><br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">30</span>):<br>        <span class="hljs-comment"># -----------------------生成真实值----------------------</span><br>        <span class="hljs-keyword">if</span> i != <span class="hljs-number">0</span>:  <span class="hljs-comment"># 第一次时，使用上面指定的初始真值</span><br>            x_k = np.dot(A, x_k) + np.array([disturb(Q[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>]), disturb(Q[<span class="hljs-number">1</span>][<span class="hljs-number">1</span>])])  <span class="hljs-comment"># 上次的真值计算后加点扰动当作真值</span><br>        position_true.append(x_k[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>])<br>        speed_true.append(x_k[<span class="hljs-number">1</span>][<span class="hljs-number">0</span>])<br>        <span class="hljs-comment"># -----------------------生成观测值----------------------</span><br>        z_k = x_k + np.array([disturb(R[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>]), disturb(R[<span class="hljs-number">1</span>][<span class="hljs-number">1</span>])])  <span class="hljs-comment"># 真值叠加扰动当作观测值</span><br>        position_measure.append(z_k[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>])<br>        speed_measure.append(z_k[<span class="hljs-number">1</span>][<span class="hljs-number">0</span>])<br>        <span class="hljs-comment"># ---------------------kalman filter--------------------</span><br>        hx_prior_k = calc_prior_hx(A, hx_k_1, B, u_k_1)<br>        P_prior_k = calc_prior_P(A, P_k_1, Q)<br>        K_k = kalman_gain(P_prior_k, H, R)<br>        hx_k = calc_posterior_hx(hx_prior_k, K_k, z_k, H)  <span class="hljs-comment"># 估计值</span><br>        P_k = update_posterior_P(K_k, H, P_prior_k)<br>        position_prior_est.append(hx_prior_k[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>])<br>        speed_prior_est.append(hx_prior_k[<span class="hljs-number">1</span>][<span class="hljs-number">0</span>])<br>        position_posterior_est.append(hx_k[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>])<br>        speed_posterior_est.append(hx_k[<span class="hljs-number">1</span>][<span class="hljs-number">0</span>])<br>        <span class="hljs-comment"># ----------------------更新值，下次用---------------------</span><br>        hx_k_1 = hx_k<br>        P_k_1 = P_k<br><br>    <span class="hljs-comment"># 可视化显示</span><br>    <span class="hljs-keyword">if</span> <span class="hljs-literal">True</span>:<br>        fig, axs = plt.subplots(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>)<br>        axs[<span class="hljs-number">0</span>].plot(speed_true, <span class="hljs-string">&quot;-&quot;</span>, label=<span class="hljs-string">&quot;speed_true&quot;</span>, linewidth=<span class="hljs-number">1</span>)<br>        axs[<span class="hljs-number">0</span>].plot(speed_measure, <span class="hljs-string">&quot;-&quot;</span>, label=<span class="hljs-string">&quot;speed_measure&quot;</span>, linewidth=<span class="hljs-number">1</span>)<br>        axs[<span class="hljs-number">0</span>].plot(speed_prior_est, <span class="hljs-string">&quot;-&quot;</span>, label=<span class="hljs-string">&quot;speed_prior_est&quot;</span>, linewidth=<span class="hljs-number">1</span>)<br>        axs[<span class="hljs-number">0</span>].plot(speed_posterior_est, <span class="hljs-string">&quot;-&quot;</span>, label=<span class="hljs-string">&quot;speed_posterior_est&quot;</span>, linewidth=<span class="hljs-number">1</span>)<br>        axs[<span class="hljs-number">0</span>].set_title(<span class="hljs-string">&quot;speed&quot;</span>)<br>        axs[<span class="hljs-number">0</span>].set_xlabel(<span class="hljs-string">&#x27;k&#x27;</span>)  <span class="hljs-comment"># Add an x-label to the axes.</span><br>        axs[<span class="hljs-number">0</span>].legend()  <span class="hljs-comment"># Add a legend.</span><br><br>        axs[<span class="hljs-number">1</span>].plot(position_true, <span class="hljs-string">&quot;-&quot;</span>, label=<span class="hljs-string">&quot;position_true&quot;</span>, linewidth=<span class="hljs-number">1</span>)<br>        axs[<span class="hljs-number">1</span>].plot(position_measure, <span class="hljs-string">&quot;-&quot;</span>, label=<span class="hljs-string">&quot;position_measure&quot;</span>, linewidth=<span class="hljs-number">1</span>)<br>        axs[<span class="hljs-number">1</span>].plot(position_prior_est, <span class="hljs-string">&quot;-&quot;</span>, label=<span class="hljs-string">&quot;position_prior_est&quot;</span>, linewidth=<span class="hljs-number">1</span>)<br>        axs[<span class="hljs-number">1</span>].plot(position_posterior_est, <span class="hljs-string">&quot;-&quot;</span>, label=<span class="hljs-string">&quot;position_posterior_est&quot;</span>, linewidth=<span class="hljs-number">1</span>)<br>        axs[<span class="hljs-number">1</span>].set_title(<span class="hljs-string">&quot;position&quot;</span>)<br>        axs[<span class="hljs-number">1</span>].set_xlabel(<span class="hljs-string">&#x27;k&#x27;</span>)  <span class="hljs-comment"># Add an x-label to the axes.</span><br>        axs[<span class="hljs-number">1</span>].legend()  <span class="hljs-comment"># Add a legend.</span><br><br>        plt.show()<br><br></code></pre></td></tr></table></figure><h2 id="第六讲-拓展卡尔曼滤波器"><a href="#第六讲-拓展卡尔曼滤波器" class="headerlink" title="第六讲 拓展卡尔曼滤波器"></a>第六讲 拓展卡尔曼滤波器</h2><p>kalman filter 只能用于线性系统</p><p><img src="/images/%E5%8D%A1%E5%B0%94%E6%9B%BC%E6%BB%A4%E6%B3%A2.assets/image-20211122114739985.png" alt="image-20211122114739985"></p><p>正态分布的误差在非线性系统中就不再是正态分布了，需要做线性化泰勒展开</p><p><img src="/images/%E5%8D%A1%E5%B0%94%E6%9B%BC%E6%BB%A4%E6%B3%A2.assets/image-20211122115631993.png" alt="image-20211122115631993"></p><p><img src="/images/%E5%8D%A1%E5%B0%94%E6%9B%BC%E6%BB%A4%E6%B3%A2.assets/image-20211122120251925.png" alt="image-20211122120251925"></p><p>修改为 extended kalman filter</p><p><img src="/images/%E5%8D%A1%E5%B0%94%E6%9B%BC%E6%BB%A4%E6%B3%A2.assets/image-20211122120555423.png" alt="image-20211122120555423"></p>]]></content>
    
    
    <categories>
      
      <category>algorithm</category>
      
    </categories>
    
    
    <tags>
      
      <tag>kalman filter</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>坚果云选择性同步重拾</title>
    <link href="/2021/11/23/%E5%9D%9A%E6%9E%9C%E4%BA%91%E9%80%89%E6%8B%A9%E6%80%A7%E5%90%8C%E6%AD%A5%E9%87%8D%E6%8B%BE/"/>
    <url>/2021/11/23/%E5%9D%9A%E6%9E%9C%E4%BA%91%E9%80%89%E6%8B%A9%E6%80%A7%E5%90%8C%E6%AD%A5%E9%87%8D%E6%8B%BE/</url>
    
    <content type="html"><![CDATA[<h2 id="坚果云选择性同步重拾"><a href="#坚果云选择性同步重拾" class="headerlink" title="坚果云选择性同步重拾"></a>坚果云选择性同步重拾</h2><blockquote><p><strong>事出有因</strong></p></blockquote><p>最近一两年，坚果云为了强推云桥模式，持之以恒地对选择性同步功能做负优化，这里友情建议开除产品经理。不是说云桥模式没有价值，而是云桥模式和选择性忽略同步根本就是两个不同的用户需求。</p><p>插播吐槽一句，新版本的客户端UI真是丑得无与伦比，旧版本审美轻松甩新版本十条街。从实用性角度来说，新版本的界面宽度，你能不能让我拉得更窄一点，同步工具做好辅助工作就行了，每次重启app都蹦到桌面正中间，异常执着地把宽度加加加加加大，抢什么用户视野！？</p><p>之前一直使用的是老版本的坚果云，参见<a href="https://www.sohu.com/a/243396325_241268">搜狐新闻</a>上的教程做选择性同步。昨天坚果云竟然给我强制性地自动升级了，懒得重装旧版本，于是折腾一下，确保在必要时选择性同步功能还能使用。</p><blockquote><p><strong>操作方法</strong></p></blockquote><p>以前的选择性同步配置文件应该是在 <code>%APPDATA%\Nutstore\db</code> 目录下的，不过随着版本升级，现在 <code>db</code> 目录应该是已经没有了，这里直接使用Everything搜索选择性同步的配置文件 <code>customExtRules.conf</code> 。</p><p><img src="/images/%E5%9D%9A%E6%9E%9C%E4%BA%91%E9%80%89%E6%8B%A9%E6%80%A7%E5%90%8C%E6%AD%A5%E9%87%8D%E6%8B%BE.assets/20210506110435755.png" alt="Everything搜索结果"><br>使用记事本或者notepad++打开 <code>customExtRules.conf</code> ，添加自定义的忽略规则即可。以下是 <code>customExtRules.conf</code> 中自带的内容。如果使用Everything无法找到该文件，也可以尝试自己添加自定义配置文件放到程序文件夹下，<a href="https://blog.csdn.net/weixin_34168700/article/details/86331957">据说</a>能够生效，大家可以自行测试。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs txt"># 坚果云自定义同步规则<br># 详细使用说明: http://help.jianguoyun.com/?p=1825 <br><br><br># 示例:<br># 忽略所有扩展名为 .bak 的文件, 删除下一行行首的 &#x27;#&#x27; 即可 (保留行首空格不影响配置文件)<br># *.bak<br><br># 忽略 D:\work\test 文件夹, 删除下一行行首的 &#x27;#&#x27; 即可 (保留行首空格不影响配置文件)<br># D:\work\test<br><br># 强制同步所有扩展名为 .lock 的文件, 删除下一行行首的 &#x27;#&#x27; 即可 (保留行首空格不影响配置文件)<br># !*.lock<br><br># 如果 .lock 文件已经包含在选择性同步的路径中，则此类型文件不会被同步<br># 如果在配置文件中同时存在 *.lock 和 !*.lock，则此类型文件不会被同步<br>mode=blacklist<br><br># 配置开始<br><br>D:\测试\bbb.txt<br><br></code></pre></td></tr></table></figure><blockquote><p><strong>测试</strong></p></blockquote><p>友情提醒！<strong>先写好忽略规则配置之后再去创建文件做测试！创建文件前最好退出坚果云app</strong>！因为可能出现文件尚未重命名，就已经被坚果云同步到云盘的情况，对于已经被纳入同步列表的文件，即使重命名后与忽略列表匹配，也不会被忽略同步。</p><p>测试用例：<br><img src="/images/%E5%9D%9A%E6%9E%9C%E4%BA%91%E9%80%89%E6%8B%A9%E6%80%A7%E5%90%8C%E6%AD%A5%E9%87%8D%E6%8B%BE.assets/20210506111340723.png" alt="测试"><br>测试结果：<br><img src="/images/%E5%9D%9A%E6%9E%9C%E4%BA%91%E9%80%89%E6%8B%A9%E6%80%A7%E5%90%8C%E6%AD%A5%E9%87%8D%E6%8B%BE.assets/20210506111340728.png" alt="测试结果"></p><blockquote><p><strong>最后的最后</strong></p></blockquote><p>有人建议删除坚果云的 <code>update.exe</code> 文件以避免强制更新，这一步就根据自己需求操作吧，不是没有后期更新导致以上方法失效的可能性，不过出于对老用户配置的兼容性考虑，笔者认为上述方法短期内应该不会失效。当然也可以使用<strong>云桥模式</strong>备份一个安装包，有备无患嘛（滑稽.jpg）。</p><p>希望能够帮助到需要的朋友~</p>]]></content>
    
    
    <categories>
      
      <category>tools</category>
      
    </categories>
    
    
    <tags>
      
      <tag>坚果云</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LatexNote</title>
    <link href="/2021/11/23/LatexNote/"/>
    <url>/2021/11/23/LatexNote/</url>
    
    <content type="html"><![CDATA[<h1 id="Latex笔记"><a href="#Latex笔记" class="headerlink" title="Latex笔记"></a>Latex笔记</h1><h2 id="学习资源"><a href="#学习资源" class="headerlink" title="学习资源"></a>学习资源</h2><ul><li><a href="https://www.bilibili.com/video/BV1tg4y1B7f3">LaTex安装教程（TeXLive2020）</a></li><li><a href="https://www.bilibili.com/video/BV1s7411U7Pr">刘海洋 · LaTeX 不快速的入门 - 跟着大神学习最纯正的 LaTeX 知识</a></li><li><a href="https://www.bilibili.com/video/BV1RE411W7FS">2020 现代 LaTeX 讲座 - 曾祥东 - 最新鲜，最精准，最前沿 LaTeX 知识</a></li></ul><h2 id="安装配置"><a href="#安装配置" class="headerlink" title="安装配置"></a>安装配置</h2><p>不同平台上使用的latex发行版本有所差异，常见的发行版包括TexLive和MacTex。</p><ul><li><a href="https://www.tug.org/texlive/">TexLive</a> 适用于Windows和Unix平台</li><li><a href="https://www.tug.org/mactex/">MacTeX</a> 适用于MacOS平台</li><li><a href="https://cn.overleaf.com/">OverLeaf</a> 一个在线的LaTex编辑器</li></ul><p>我这里使用的是MacOS平台，故只能在MacTex下选择，而MacTex又有两个可以选择的版本。</p><ul><li><a href="https://www.tug.org/mactex/mactex-download.html">MacTex</a>，一个all-in-one的安装包，整个安装包大小超过4GB，涵盖了一系列的宏、语言配置、甚至一个简单的图形编辑界面。</li><li><a href="https://www.tug.org/mactex/morepackages.html">BasicTex</a>，一个精简浓缩的安装包，大小仅90M，需要自行配置latex编辑器，或者使用命令行操作。</li></ul><p>根据我个人的偏好，选择使用BasicTex，编辑器配合VSCode和LaTex Workshop使用，颜值和极客风俱备！</p><p>由于国外下载网站实在太慢了，这里可以选择使用<a href="https://mirrors.tuna.tsinghua.edu.cn/ctan/systems/mac/mactex/">清华源镜像</a>。也有人说可以通过brew来安装，但是教程有点老了，也可能是我用了中科大镜像的原因，brew里面搜不到basictex源，所以这里暂且按下不表。</p><p>官网下载BasicTex安装包后一路确认安装即可，值得注意的是，安装完成后，不会生成任何的app启动图标（MacTex会生成四五个冗杂的app启动图标）。通过以下命令检查是否安装完成！</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">latex -v<br>xetex -v<br>tlmgr --<span class="hljs-built_in">help</span><br></code></pre></td></tr></table></figure><p>如果没有报 <code>command not found</code> 的错误，则安装成功。</p><p>有个值得梳理的点，由于BasicTex安装后“没有任何文件生成”，我们对BasicTex的安装位置、安装内容一无所知，这肯定是不行的！关于这一点，官网的 <a href="http://www.tug.org/mactex/What_Is_Installed.pdf">What Is Installed</a> 有比较详细的介绍，我也在这上面花了不少心思，这里做个简单梳理。</p><p>安装程序执行完成后，所有的可执行文件都被放到了 <code>/Library/TeX/texbin</code> 目录下，并且将 <code>/Library/TeX/texbin</code> 添加到了 <code>PATH</code> 环境变量中。我找遍了所有能想到的配置文件路径，包括 <code>~/.zshrc</code>, <code>~/.bashrc</code>, <code>~/.bash_profile</code>, <code>/etc/zshrc</code>, <code>/etc/zprofile</code>, <code>/etc/bashrc</code>，都没能找到 <code>/Library/TeX/texbin</code> 是怎么被添加到 <code>PATH</code> 环境变量中去的。</p><p>最后还是在官方文档里面找到的答案，安装程序自动完成了两个配置，分别位于 <code>/etc/manpaths.d/TeX</code> 和 <code>/etc/paths.d/TeX</code>。BasicTex的环境变量就是通过 <code>/etc/paths.d/TeX</code> 来配置的。</p><blockquote><p><a href="https://www.cnblogs.com/EasonJim/p/9241436.html">Mac下的paths.d目录神奇用法</a></p></blockquote><p><code>paths.d</code> 的作用很简单，就是在里面创建一个文件，然后写上需要在全局命令行下用到的命令，直接配置一个目录即可。在 <code>/etc/profile</code> 下会有一个 <code>path_helper</code> 的工具，这个工具就是会读取 <code>/etc/paths.d</code> 目录下的文件中的路径，然后加载到环境变量 <code>$PTAH</code> 中去。</p><blockquote><p>关于手动安装宏包</p></blockquote><p>宏包的<a href="https://www.ctan.org/pkg/texdoc">下载网址</a></p><p>这里有几个介绍可以参考：</p><ul><li><a href="https://zhuanlan.zhihu.com/p/20084274">怎么安装/更新宏包？</a></li><li><a href="https://www.cnblogs.com/csucat/p/5142459.html">LaTeX手动安装宏包（package）以及生成帮助文档的整套流程</a></li><li><a href="https://zhuanlan.zhihu.com/p/43981639">[LaTeX 指南] 功能性宏包推荐</a></li></ul><p>个人实践案例：</p><p>安装完BasicTex之后发现果然自己“一贫如洗”，居然连个texdoc工具都没有，参考上面的文章自己安装了一下texdoc</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">tlmgr install texdoc<br></code></pre></td></tr></table></figure><blockquote><p><strong>另一个选择 —— MiKTeX</strong></p></blockquote><p>对于mac平台来说，直接使用MacTex实在是太占用硬盘空间了，更重要的是，会安装一堆可能你一辈子都用不上的宏包（尤其是launch pad里那几个碍眼的软件），这是无法忍受的。但是使用BasicTex又会面临另外一个问题，那就是作为一个fresh bird，我根本不知道应该安装哪些宏包，一旦编译报错，甚至无法定位出错原因，另外，频繁安装宏包也是相当的浪费时间。</p><p>对此，这里其实还有另外一个选择 —— <a href="https://miktex.org/">MikTeX</a>。MikTeX最大的优势是可以根据实际需求，在缺少依赖的宏包时才进行相关宏包的安装。早期的MikTeX其实只支持windows和linux系统，近些年才推出了mac平台的版本。关于TexLive和MixTeX这两个发行版的差异可以参考下面的文章：</p><ul><li><a href="https://www.texdev.net/2016/12/18/tex-on-windows-tex-live-versus-miktex-revisited/">TeX on Windows: TeX Live versus MiKTeX revisited</a></li><li><a href="https://www.cnblogs.com/liuliang1999/p/12656706.html">在Windows上使用TeX：TeX Live与MiKTeX的对比（译）</a></li></ul><p>MikTeX默认安装目录：<code>/Users/dogqizi/Library/Application\ Support/MiKTeX/texmfs</code>，其下又包含config、data、install三个目录，而插件目录位于 <code>install/tex/latex</code>。</p><h2 id="踩坑实录"><a href="#踩坑实录" class="headerlink" title="踩坑实录"></a>踩坑实录</h2><h3 id="macOS-latex-使用中文报错"><a href="#macOS-latex-使用中文报错" class="headerlink" title="macOS latex 使用中文报错"></a>macOS latex 使用中文报错</h3><blockquote><p>我的latex文稿：</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs latex">\documentclass&#123;article&#125;<br>\usepackage&#123;ctex&#125;<br>\begin&#123;document&#125;<br> ``Hello world!&quot; from \LaTeX. <br> <br> 你好，latex<br>\end&#123;document&#125;<br></code></pre></td></tr></table></figure><blockquote><p>报错信息</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-string">&quot;resource&quot;</span>: <span class="hljs-string">&quot;/fontset/ctex-fontset-macnew.def&quot;</span>,<br><br><span class="hljs-string">&quot;message&quot;</span>: <span class="hljs-string">&quot;Package fontspec: The font \&quot;Kaiti SC\n\&quot; cannot be found.\n&quot;</span>,<br><br><span class="hljs-string">&quot;message&quot;</span>: <span class="hljs-string">&quot;Font \&quot;Songti SC Light\&quot; does not contain requested\n(fontspec)\tScript \&quot;CJK\&quot;.\n&quot;</span>,<br></code></pre></td></tr></table></figure><blockquote><p>解决方法</p></blockquote><p><strong>局部文档解决</strong></p><p>先设置文档字体为nofonts，再手动指定系统中存在的字体名。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs latex">\documentclass[a4paper,nofonts]&#123;article&#125;<br><br>\usepackage&#123;ctex&#125;<br><br>\setCJKmainfont[BoldFont=&#123;STSongti-SC-Bold&#125;,ItalicFont=&#123;STSongti-SC-Light&#125;]&#123;STSongti-SC-Regular&#125;<br><br>\begin&#123;document&#125;<br> ``Hello world!&quot; from \LaTeX. <br><br> 你好，latex<br>\end&#123;document&#125;<br></code></pre></td></tr></table></figure><p><strong>系统全局解决</strong></p><p>将 <code>MiKTeX/texmfs/install/tex/latex/ctex/fontset/ctex-fontset-macnew.def</code> 中对应的字体名字修改为与自己系统中的名字一致！</p><p>参考资料：</p><ul><li><a href="https://www.zhihu.com/question/20210754">如何在 Mac 下的 LaTeX 中使用中文字体?</a></li><li><a href="https://blog.csdn.net/maoye/article/details/102691774">Tex中使用fontspec宏包之各种坑</a></li><li><a href="https://blog.csdn.net/weixin_44908818/article/details/108659018">macOS中LaTeX报错Package fontspec Error: The font “SimHei“ cannot be found</a></li><li><a href="https://www.jianshu.com/p/8f35c57901e3">Mac系统华文楷体在LaTeX中无法使用的解决</a></li></ul><h2 id="VSCode配置"><a href="#VSCode配置" class="headerlink" title="VSCode配置"></a>VSCode配置</h2><p>安装插件 <code>LaTex Workshop</code>。这个博客里面对于各项配置的作用讲得比较详细：<a href="https://zhuanlan.zhihu.com/p/166523064">Visual Studio Code (vscode)配置LaTeX</a></p><p>Command+Shift+P 打开控制盘，输入 <code>set json</code> 搜索，选择 <code>Preference: Open Settings (JSON)</code>，追加以下配置到现有配置的最外层大括号内。</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br></pre></td><td class="code"><pre><code class="hljs json">&#123;<br>    <span class="hljs-attr">&quot;latex-workshop.latex.tools&quot;</span>: [<br>        &#123;<br>            <span class="hljs-attr">&quot;name&quot;</span>: <span class="hljs-string">&quot;xelatex&quot;</span>,<br>            <span class="hljs-comment">// 如果没有配置全局环境变量，command填具体的工具路径，比如/usr/local/tex/bin/xelatex</span><br>            <span class="hljs-attr">&quot;command&quot;</span>: <span class="hljs-string">&quot;xelatex&quot;</span>,<br>            <span class="hljs-attr">&quot;args&quot;</span>: [<br>                <span class="hljs-string">&quot;-synctex=1&quot;</span>,<br>                <span class="hljs-string">&quot;-interaction=nonstopmode&quot;</span>,<br>                <span class="hljs-string">&quot;-file-line-error&quot;</span>,<br>                <span class="hljs-string">&quot;%DOCFILE%&quot;</span><br>            ]<br>        &#125;,<br>        &#123;<br>            <span class="hljs-attr">&quot;name&quot;</span>: <span class="hljs-string">&quot;pdflatex&quot;</span>,<br>            <span class="hljs-attr">&quot;command&quot;</span>: <span class="hljs-string">&quot;pdflatex&quot;</span>,<br>            <span class="hljs-attr">&quot;args&quot;</span>: [<br>                <span class="hljs-string">&quot;-synctex=1&quot;</span>,<br>                <span class="hljs-string">&quot;-interaction=nonstopmode&quot;</span>,<br>                <span class="hljs-string">&quot;-file-line-error&quot;</span>,<br>                <span class="hljs-string">&quot;%DOCFILE%&quot;</span><br>            ]<br>        &#125;,<br>        &#123;<br>            <span class="hljs-attr">&quot;name&quot;</span>: <span class="hljs-string">&quot;latexmk&quot;</span>,<br>            <span class="hljs-attr">&quot;command&quot;</span>: <span class="hljs-string">&quot;latexmk&quot;</span>,<br>            <span class="hljs-attr">&quot;args&quot;</span>: [<br>                <span class="hljs-string">&quot;-synctex=1&quot;</span>,<br>                <span class="hljs-string">&quot;-interaction=nonstopmode&quot;</span>,<br>                <span class="hljs-string">&quot;-file-line-error&quot;</span>,<br>                <span class="hljs-string">&quot;-pdf&quot;</span>,<br>                <span class="hljs-string">&quot;-outdir=%OUTDIR%&quot;</span>,<br>                <span class="hljs-string">&quot;%DOCFILE%&quot;</span><br>            ]<br>        &#125;,<br>        &#123;<br>            <span class="hljs-attr">&quot;name&quot;</span>: <span class="hljs-string">&quot;bibtex&quot;</span>,<br>            <span class="hljs-attr">&quot;command&quot;</span>: <span class="hljs-string">&quot;bibtex&quot;</span>,<br>            <span class="hljs-attr">&quot;args&quot;</span>: [<br>                <span class="hljs-string">&quot;%DOCFILE%&quot;</span><br>            ]<br>        &#125;<br>    ],<br>    <span class="hljs-attr">&quot;latex-workshop.latex.recipes&quot;</span>: [<br>        &#123;<br>            <span class="hljs-attr">&quot;name&quot;</span>: <span class="hljs-string">&quot;XeLaTeX&quot;</span>,<br>            <span class="hljs-attr">&quot;tools&quot;</span>: [<br>                <span class="hljs-string">&quot;xelatex&quot;</span><br>            ]<br>        &#125;,<br>        &#123;<br>            <span class="hljs-attr">&quot;name&quot;</span>: <span class="hljs-string">&quot;PDFLaTeX&quot;</span>,<br>            <span class="hljs-attr">&quot;tools&quot;</span>: [<br>                <span class="hljs-string">&quot;pdflatex&quot;</span><br>            ]<br>        &#125;,<br>        &#123;<br>            <span class="hljs-attr">&quot;name&quot;</span>: <span class="hljs-string">&quot;BibTeX&quot;</span>,<br>            <span class="hljs-attr">&quot;tools&quot;</span>: [<br>                <span class="hljs-string">&quot;bibtex&quot;</span><br>            ]<br>        &#125;,<br>        &#123;<br>            <span class="hljs-attr">&quot;name&quot;</span>: <span class="hljs-string">&quot;LaTeXmk&quot;</span>,<br>            <span class="hljs-attr">&quot;tools&quot;</span>: [<br>                <span class="hljs-string">&quot;latexmk&quot;</span><br>            ]<br>        &#125;,<br>        &#123;<br>            <span class="hljs-attr">&quot;name&quot;</span>: <span class="hljs-string">&quot;xelatex -&gt; bibtex -&gt; xelatex*2&quot;</span>,<br>            <span class="hljs-attr">&quot;tools&quot;</span>: [<br>                <span class="hljs-string">&quot;xelatex&quot;</span>,<br>                <span class="hljs-string">&quot;bibtex&quot;</span>,<br>                <span class="hljs-string">&quot;xelatex&quot;</span>,<br>                <span class="hljs-string">&quot;xelatex&quot;</span><br>            ]<br>        &#125;,<br>        &#123;<br>            <span class="hljs-attr">&quot;name&quot;</span>: <span class="hljs-string">&quot;pdflatex -&gt; bibtex -&gt; pdflatex*2&quot;</span>,<br>            <span class="hljs-attr">&quot;tools&quot;</span>: [<br>                <span class="hljs-string">&quot;pdflatex&quot;</span>,<br>                <span class="hljs-string">&quot;bibtex&quot;</span>,<br>                <span class="hljs-string">&quot;pdflatex&quot;</span>,<br>                <span class="hljs-string">&quot;pdflatex&quot;</span><br>            ]<br>        &#125;<br>    ],<br>    <span class="hljs-attr">&quot;latex-workshop.latex.clean.fileTypes&quot;</span>: [<br>        <span class="hljs-string">&quot;*.aux&quot;</span>,<br>        <span class="hljs-string">&quot;*.bbl&quot;</span>,<br>        <span class="hljs-string">&quot;*.blg&quot;</span>,<br>        <span class="hljs-string">&quot;*.idx&quot;</span>,<br>        <span class="hljs-string">&quot;*.ind&quot;</span>,<br>        <span class="hljs-string">&quot;*.lof&quot;</span>,<br>        <span class="hljs-string">&quot;*.lot&quot;</span>,<br>        <span class="hljs-string">&quot;*.out&quot;</span>,<br>        <span class="hljs-string">&quot;*.toc&quot;</span>,<br>        <span class="hljs-string">&quot;*.acn&quot;</span>,<br>        <span class="hljs-string">&quot;*.acr&quot;</span>,<br>        <span class="hljs-string">&quot;*.alg&quot;</span>,<br>        <span class="hljs-string">&quot;*.glg&quot;</span>,<br>        <span class="hljs-string">&quot;*.glo&quot;</span>,<br>        <span class="hljs-string">&quot;*.gls&quot;</span>,<br>        <span class="hljs-string">&quot;*.ist&quot;</span>,<br>        <span class="hljs-string">&quot;*.fls&quot;</span>,<br>        <span class="hljs-string">&quot;*.log&quot;</span>,<br>        <span class="hljs-string">&quot;*.fdb_latexmk&quot;</span><br>    ],<br>    <span class="hljs-attr">&quot;latex-workshop.view.pdf.viewer&quot;</span>: <span class="hljs-string">&quot;tab&quot;</span>,<br>    <span class="hljs-attr">&quot;latex-workshop.latex.autoBuild.run&quot;</span>: <span class="hljs-string">&quot;never&quot;</span>,<br>    <span class="hljs-attr">&quot;latex-workshop.showContextMenu&quot;</span>: <span class="hljs-literal">true</span>,<br>    <span class="hljs-attr">&quot;latex-workshop.intellisense.package.enabled&quot;</span>: <span class="hljs-literal">true</span>,<br>    <span class="hljs-attr">&quot;latex-workshop.message.error.show&quot;</span>  : <span class="hljs-literal">false</span>,<br>    <span class="hljs-attr">&quot;latex-workshop.message.warning.show&quot;</span>: <span class="hljs-literal">false</span>,<br>    <span class="hljs-attr">&quot;latex-workshop.view.pdf.internal.synctex.keybinding&quot;</span>: <span class="hljs-string">&quot;double-click&quot;</span>,<br>&#125;<br></code></pre></td></tr></table></figure><p>快捷键：</p><ul><li>option+command+B  生成PDF文档</li><li>option+command+V  预览PDF文档</li></ul>]]></content>
    
    
    <categories>
      
      <category>tools</category>
      
    </categories>
    
    
    <tags>
      
      <tag>latex</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Git笔记</title>
    <link href="/2021/10/20/Git%E7%AC%94%E8%AE%B0/"/>
    <url>/2021/10/20/Git%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h2 id="1-Git配置"><a href="#1-Git配置" class="headerlink" title="1 Git配置"></a>1 Git配置</h2><h3 id="1-1-配置级别及配置项"><a href="#1-1-配置级别及配置项" class="headerlink" title="1.1 配置级别及配置项"></a>1.1 配置级别及配置项</h3><blockquote><p>git配置级别主要有以下3类：</p></blockquote><ol><li><p>仓库级别 local 【优先级最高】 当前仓库下的.git/config文件中</p></li><li><p>用户级别 global【优先级次之】  windows当前用户目录的 .gitconfig 文件中</p></li><li><p>系统级别 system【优先级最低】  Git安装目录下的 etc/gitconfig 文件中</p></li></ol><blockquote><p>查看配置项</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs bash">git config -l  <span class="hljs-comment"># 查看git的所有配置信息</span><br>git config --<span class="hljs-built_in">local</span> -l   <span class="hljs-comment"># 查看仓库配置（必须要进入到具体仓库的目录下）</span><br>git config --global -l  <span class="hljs-comment"># 查看用户配置</span><br>git config --system -l  <span class="hljs-comment"># 查看系统配置</span><br><br><span class="hljs-comment"># 查看指定配置项的值</span><br><span class="hljs-comment"># 格式：git config [--local|--global|--system] --get section.key(默认是获取local配置中内容)</span><br>git config --global --get user.name  <span class="hljs-comment"># 查看用户名</span><br><br><span class="hljs-comment"># 新增一个配置项</span><br><span class="hljs-comment"># 格式: git config [--local|--global|--system] --add section.key value(默认是添加在local配置中)</span><br>git config --global --add user.name2 dogdog<br><br><span class="hljs-comment"># 修改一个配置项</span><br><span class="hljs-comment"># 格式: git config [--local|--global|--system] section.key value(默认是添加在local配置中)</span><br>git config --global user.name2 douglas<br><br><span class="hljs-comment"># 删除一个配置项</span><br><span class="hljs-comment"># 格式：git config [--local|--global|--system] --unset section.key</span><br>git config --global --<span class="hljs-built_in">unset</span> user.name2<br></code></pre></td></tr></table></figure><blockquote><p>编辑配置项</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">git config --<span class="hljs-built_in">local</span> -e   <span class="hljs-comment"># 编辑仓库级别配置文件</span><br>git config --global -e  <span class="hljs-comment"># 编辑用户级别配置文件</span><br>git config --system -e  <span class="hljs-comment"># 编辑系统级别配置文件</span><br></code></pre></td></tr></table></figure><blockquote><p>基础配置</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">git config --global --add user.name <span class="hljs-string">&quot;your_name&quot;</span><br>git config --global --add user.email <span class="hljs-string">&quot;your_email@gmail.com&quot;</span><br>git config --global init.defaultBranch main  <span class="hljs-comment"># 修改本地分支默认为main，大趋势了</span><br></code></pre></td></tr></table></figure><h3 id="1-2-配置SSH公钥"><a href="#1-2-配置SSH公钥" class="headerlink" title="1.2 配置SSH公钥"></a>1.2 配置SSH公钥</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cd</span> ~/.ssh  <span class="hljs-comment"># 进入指定目录</span><br>ssh-keygen  <span class="hljs-comment"># 生成公钥</span><br><span class="hljs-comment"># 得到id_rsa和id_rsa.pub两个文件</span><br><span class="hljs-comment"># 将id_rsa.pub的内容复制到github或者gitee的ssh公钥里面</span><br><span class="hljs-comment"># 对于“某些网站”，还需要在config中配置一下相关信息，例如：</span><br>Host git.code.oa.com<br>HostName git.code.oa.com<br>User username<br>Port 22<br>IdentityFile C:/Users/qizizhou/.ssh/id_rsa<br> <br>Host git.woa.com<br>HostName git.woa.com<br>User username<br>Port 22<br>IdentityFile C:/Users/qizizhou/.ssh/id_rsa<br></code></pre></td></tr></table></figure><h2 id="2-Git核心"><a href="#2-Git核心" class="headerlink" title="2 Git核心"></a>2 Git核心</h2><p>Git理论基础工作区域Git本地有三个工作区域：工作目录（Working Directory）、暂存区(Stage/Index)、资源库(Repository或Git Directory)。如果在加上远程的git仓库(Remote Directory)就可以分为四个工作区域。文件在这四个区域之间的转换关系如下：</p><ul><li>Workspace：工作区，就是你平时存放项目代码的地方；</li><li>Index / Stage：暂存区，用于临时存放你的改动，保存即将提交到文件列表信息；</li><li>Repository：仓库区（或本地仓库），就是安全存放数据的位置，这里面有你提交到所有版本的数据。其中HEAD指向最新放入仓库的版本；</li><li>Remote：远程仓库，托管代码的服务器，可以简单的认为是你项目组中的一台电脑用于远程数据交换。</li></ul><p><strong>Git的工作流程：</strong></p><p><img src="/images/Git%E7%AC%94%E8%AE%B0.assets/image-20200703105427321.png" alt="image-20200703105427321"></p><p><img src="/images/Git%E7%AC%94%E8%AE%B0.assets/image-20200703105727217.png" alt="image-20200703105727217"></p><blockquote><p>核心命令</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash">git init  <span class="hljs-comment"># 初始化一个仓库</span><br>git add xxx  <span class="hljs-comment"># 添加一个文件到暂存区</span><br>git status  <span class="hljs-comment"># 查看git“文件”状态</span><br>git commit -m <span class="hljs-string">&quot;comment&quot;</span>  <span class="hljs-comment"># 提交到本地仓库，并创建一个新的提交节点</span><br>git commit --amend  <span class="hljs-comment"># 用新提交覆盖前一个提交</span><br>git diff  <span class="hljs-comment"># 比较当前工作区和暂存区的文件“内容”</span><br></code></pre></td></tr></table></figure><p>注意：</p><ul><li><p>git diff 比较的是文件的内容，而非是否增加或减少了新的文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash">git diff  <span class="hljs-comment"># 不加任何参数，将工作区（未add的内容）和暂存区进行比较；</span><br>git diff HEAD  <span class="hljs-comment"># 将工作区与HEAD指针指向的commit进行比较，一般来说我们当前的改动就是在HEAD指向的commit的基础上进行改动；</span><br>git diff --cached  <span class="hljs-comment"># 将暂存区与当前commit进行比较；</span><br>git diff dev  <span class="hljs-comment"># 将工作区与目标分支的最新commit进行比较；</span><br>git diff [commitId_1] [commitId_2]  <span class="hljs-comment"># 将两个commit进行比较。</span><br></code></pre></td></tr></table></figure></li><li><p>git status 只显示文件的状态，不指明具体的变更内容</p></li></ul><h2 id="3-gitignore"><a href="#3-gitignore" class="headerlink" title="3 .gitignore"></a>3 .gitignore</h2><p>在**.gitignore**文件中设置相应的忽略规则，据此实现忽略指定文件的提交。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">*.txt              <span class="hljs-comment"># 忽略所有.txt结尾的文件</span><br>!lib.txt           <span class="hljs-comment"># 但是lib.txt除外</span><br>./temp/            <span class="hljs-comment"># 忽略temp目录下的所有文件</span><br>!./temp/hello.txt  <span class="hljs-comment"># 但是temp下的hello.txt除外</span><br></code></pre></td></tr></table></figure><h2 id="4-连接远程仓库"><a href="#4-连接远程仓库" class="headerlink" title="4 连接远程仓库"></a>4 连接远程仓库</h2><p>远程仓库必须事先建立~  注意，近年新创建的仓库，主分支全部==从master变成了main==。不过本地分支和远程分支的名字本来就不需要相同，所以建立恰当的追踪关系即可。</p><blockquote><p>方法一：推荐</p></blockquote><ul><li>先在远程创建一个仓库，clone下来</li><li>把clone下来的文件复制到本地已有的项目里面</li><li>在Idea中，本地项目自动完成和远程仓库的关联</li><li>（因为clone下来的.git文件中记录了远程仓库的信息）</li></ul><p>此方法对Github和Gitee同样有效</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 将远程的master分支和本地的master分支建立追踪关系</span><br><span class="hljs-comment"># 这样使用 git status 的时候就可以看到本地master和远程master哪个更新了</span><br>git branch --set-upstream-to=origin/master master<br></code></pre></td></tr></table></figure><blockquote><p>方法二：</p></blockquote><ul><li><p>在已有的项目中执行 git init 初始化git仓库</p></li><li><p>执行下面的命令关联远程已经存在的仓库</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 等同于方法一中将.git文件复制到现有的项目中来</span><br>git remote add origin https://gitee.com/qizidog/GitTest.git<br><br><span class="hljs-comment"># 如果clone的远程库已经设置过关联仓库了，需要通过其他命令修改关联仓库，具体方式通过帮助查看</span><br>git remote --<span class="hljs-built_in">help</span><br></code></pre></td></tr></table></figure></li></ul><h2 id="5-本地分支和远程分支"><a href="#5-本地分支和远程分支" class="headerlink" title="5 本地分支和远程分支"></a>5 本地分支和远程分支</h2><h3 id="5-1-branch操作"><a href="#5-1-branch操作" class="headerlink" title="5.1 branch操作"></a>5.1 branch操作</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs bash">git branch  <span class="hljs-comment"># 查看本地所有分支 </span><br>git branch -r  <span class="hljs-comment"># 查看远程所有分支，或者git remote, git remote -v</span><br>git branch -a  <span class="hljs-comment"># 查看本地和远程的所有分支</span><br><br>git branch &lt;branchname&gt;  <span class="hljs-comment"># 新建分支</span><br>git checkout &lt;branchname&gt;  <span class="hljs-comment"># 切换分支</span><br>git checkout -b &lt;branchname&gt;  <span class="hljs-comment"># 创建并切换到一个新的分支</span><br>git checkout -b &lt;local_branchname&gt; origin/&lt;remote_branchname&gt;  <span class="hljs-comment"># 创建一个新的分支并关联远程已经存在的分支</span><br>git branch -d &lt;branchname&gt;  <span class="hljs-comment"># 删除本地分支</span><br><br>git branch -m &lt;oldbranch&gt; &lt;newbranch&gt;  <span class="hljs-comment"># 重命名本地分支</span><br></code></pre></td></tr></table></figure><h3 id="5-2-fetch操作"><a href="#5-2-fetch操作" class="headerlink" title="5.2 fetch操作"></a>5.2 fetch操作</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">git fetch &lt;远程主机名&gt;  <span class="hljs-comment"># 将某个远程主机的更新全部取回本地</span><br>git fetch &lt;远程主机名&gt; &lt;分支名&gt;  <span class="hljs-comment"># 只取回远程特定分支的更新</span><br></code></pre></td></tr></table></figure><h3 id="5-3-pull操作"><a href="#5-3-pull操作" class="headerlink" title="5.3 pull操作"></a>5.3 pull操作</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">git pull &lt;远程主机名&gt; &lt;远程分支名&gt;:&lt;本地分支名&gt;  <span class="hljs-comment"># 将远程主机的某个分支的更新取回，并与本地指定的分支合并</span><br>git pull &lt;远程主机名&gt; &lt;远程分支名&gt;  <span class="hljs-comment"># 与当前分支合并时冒号后的部分可省略</span><br></code></pre></td></tr></table></figure><p>pull操作相当于fetch操作和merge操作的结合，以下两种写法等效：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 从远程拉取master分支，并与本地当前分支合并</span><br>git pull origin master<br><br>git fetch origin master<br>git merge &lt;FETCH_HEAD&gt;  <span class="hljs-comment"># 合并分支</span><br><span class="hljs-comment"># git log -p FETCH_HEAD  查看FETCH_HEAD的方法</span><br></code></pre></td></tr></table></figure><p>出现错误</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 报错：Git :fatal: refusing to merge unrelated histories 解决方式</span><br>git pull origin master --allow-unrelated-histories<br></code></pre></td></tr></table></figure><h3 id="5-4-push操作"><a href="#5-4-push操作" class="headerlink" title="5.4 push操作"></a>5.4 push操作</h3><ul><li><p>推送==指定的本地分支==到==指定的远程分支==</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 将本地某个分支推送到远程的指定分支</span><br>git push &lt;远程主机名&gt; &lt;本地分支名&gt;:&lt;远程分支名&gt;<br></code></pre></td></tr></table></figure></li><li><p>如果==省略远程分支名==，则表示将本地分支推送至与之存在”追踪关系”的远程分支（通常两者同名），如果该远程分支==不存在则会被新建==。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git push origin master<br></code></pre></td></tr></table></figure><p>上面命令表示，将本地的master分支推送到origin主机的master分支。如果后者不存在，则会被新建。</p></li><li><p>如果==省略本地分支名==，则表示删除指定的远程分支，因为这等同于推送一个空的本地分支到远程分支。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 慎用！删除远程仓库的分支（注意空格）</span><br>git push origin :master<br><span class="hljs-comment"># 等同于</span><br>git push origin --delete master<br></code></pre></td></tr></table></figure><p>上面命令表示删除origin主机的master分支。</p></li><li><p>如果==当前分支==与远程分支之间==存在追踪关系==，则本地分支和远程分支都可以省略。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git push origin<br></code></pre></td></tr></table></figure><p>上面命令表示，将当前分支推送到origin主机的对应分支。</p></li><li><p>如果==当前分支只有一个追踪分支==，那么主机名都可以省略。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git push<br></code></pre></td></tr></table></figure></li><li><p>如果当前分支==与多个远程主机存在追踪关系==，则可以使用==-u==选项指定一个==默认主机==，这样以后就可以不加任何参数使用git push。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git push -u origin master<br></code></pre></td></tr></table></figure><p>上面命令将本地的master分支推送到origin主机，同时指定origin为默认主机，后面就可以不加任何参数使用git push了。后面遇到过一点问题，本地分支和远程分支的名字不一样时，直接<code>git push</code>会失败，最好还是保持本地分支和远程分支名字一致。</p></li></ul><h3 id="5-5-关联远程仓库"><a href="#5-5-关联远程仓库" class="headerlink" title="5.5 关联远程仓库"></a>5.5 关联远程仓库</h3><p>一般来说，先建立本地仓库和远程仓库的联系，再建立本地分支和远程分支之间的追踪关系。</p><p>绑定远程仓库相关信息的命令均在<code>git remote</code>下，具体使用方式可通过<code>git remote -h</code>查看帮助文档。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs bash">(base) [dogqizi@MacDog qidb (master ✗)]$ git remote -h<br>usage: git remote [-v | --verbose]<br>   or: git remote add [-t &lt;branch&gt;] [-m &lt;master&gt;] [-f] [--tags | --no-tags] [--mirror=&lt;fetch|push&gt;] &lt;name&gt; &lt;url&gt;<br>   or: git remote rename &lt;old&gt; &lt;new&gt;<br>   or: git remote remove &lt;name&gt;<br>   or: git remote set-head &lt;name&gt; (-a | --auto | -d | --delete | &lt;branch&gt;)<br>   or: git remote [-v | --verbose] show [-n] &lt;name&gt;<br>   or: git remote prune [-n | --dry-run] &lt;name&gt;<br>   or: git remote [-v | --verbose] update [-p | --prune] [(&lt;group&gt; | &lt;remote&gt;)...]<br>   or: git remote set-branches [--add] &lt;name&gt; &lt;branch&gt;...<br>   or: git remote get-url [--push] [--all] &lt;name&gt;<br>   or: git remote set-url [--push] &lt;name&gt; &lt;newurl&gt; [&lt;oldurl&gt;]<br>   or: git remote set-url --add &lt;name&gt; &lt;newurl&gt;<br>   or: git remote set-url --delete &lt;name&gt; &lt;url&gt;<br><br>    -v, --verbose         be verbose; must be placed before a subcommand<br><br></code></pre></td></tr></table></figure><h3 id="5-6-建立追踪关系"><a href="#5-6-建立追踪关系" class="headerlink" title="5.6 建立追踪关系"></a>5.6 建立追踪关系</h3><p>建立追踪关系后可以简化push指令，也可以在git status时查看本地和远程进度的比较</p><p><strong>建立追踪关系的三种方式：</strong></p><ul><li><p>手动建立追踪关系</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git branch --set-upstream-to=&lt;远程主机名&gt;/&lt;远程分支名&gt; &lt;本地分支名&gt;<br></code></pre></td></tr></table></figure></li><li><p>push时建立追踪关系</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git push -u &lt;远程主机名&gt; &lt;本地分支名&gt;<br></code></pre></td></tr></table></figure></li><li><p>新建分支时建立跟踪关系</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git checkout -b &lt;本地分支名&gt; &lt;远程主机名&gt;/&lt;远程分支名&gt;<br></code></pre></td></tr></table></figure></li></ul><p><strong>查看追踪关系：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git branch -vv<br></code></pre></td></tr></table></figure><p><strong>取消追踪关系</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git branch --unset-upstream<br></code></pre></td></tr></table></figure><h3 id="5-7-stash操作"><a href="#5-7-stash操作" class="headerlink" title="5.7 stash操作"></a>5.7 stash操作</h3><p><strong><a href="https://www.cnblogs.com/fxwoniu/p/13823337.html">应用场景</a>：</strong></p><ol><li>当正在dev分支上开发某个项目，这时项目中出现一个bug，需要紧急修复，但是正在开发的内容只是完成一半，还不想提交，这时可以用git stash命令将修改的内容保存至堆栈区，然后顺利切换到hotfix分支进行bug修复，修复完成后，再次切回到dev分支，从堆栈中恢复刚刚保存的内容。</li><li>由于疏忽，本应该在dev分支开发的内容，却在master上进行了开发，需要重新切回到dev分支上进行开发，可以用git stash将内容保存至堆栈中，切回到dev分支后，再次恢复内容即可。</li></ol><p>总的来说，git stash命令的作用就是将目前还不想提交的但是已经修改的内容进行保存至堆栈中，后续可以在某个分支上恢复出堆栈中的内容。这也就是说，stash中的内容不仅仅可以恢复到原先开发的分支，也可以恢复到其他任意指定的分支上。git stash作用的范围包括工作区和暂存区中的内容，也就是说没有提交的内容都会保存至堆栈中。</p><p>（1）<strong>git stash</strong> save “save message” : 执行存储时，添加备注，方便查找，只有git stash 也要可以的，但查找时不方便识别。</p><p>（2）<strong>git stash list</strong> ：查看stash了哪些存储</p><p>（3）<strong>git stash show</strong> ：显示做了哪些改动，默认show第一个存储,如果要显示其他存贮，后面加stash@{$num}，比如第二个 git stash show stash@{1}</p><p>（4）<strong>git stash show -p</strong> : 显示第一个存储的改动，如果想显示其他存存储，命令：git stash show stash@{$num} -p ，比如第二个：git stash show stash@{1} -p</p><p>（5）<strong>git stash apply</strong> :应用某个存储,但不会把存储从存储列表中删除，默认使用第一个存储,即stash@{0}，如果要使用其他个，git stash apply stash@{$num} ， 比如第二个：git stash apply stash@{1} </p><p>（6）<strong>git stash pop</strong> ：命令恢复之前缓存的工作目录，将缓存堆栈中的对应stash删除，并将对应修改应用到当前的工作目录下,默认为第一个stash,即stash@{0}，如果要应用并删除其他stash，命令：git stash pop stash@{$num} ，比如应用并删除第二个：git stash pop stash@{1}</p><p>（7）<strong>git stash drop</strong> stash@{$num} ：丢弃stash@{$num}存储，从列表中删除这个存储</p><p>（8）<strong>git stash clear</strong> ：删除所有缓存的stash</p><p><strong>参考博客：</strong></p><ul><li><a href="https://www.cnblogs.com/fxwoniu/p/13823337.html">git stash 命令的应用场景及详解</a> </li><li><a href="https://www.cnblogs.com/zndxall/p/9586088.html">git stash 用法总结和注意点</a> </li><li><a href="https://blog.csdn.net/yzpbright/article/details/53789641">git如何不commit当前分支的修改而切换到其它分支</a> </li></ul><h3 id="5-8-clone"><a href="#5-8-clone" class="headerlink" title="5.8 clone"></a>5.8 clone</h3><p>下载某一个非常大的repository的时候，如果不是用来做开发，不需要把所有的历史版本信息都clone下来， –depth 1 可以指定只下载最近一次提交的记录，–branch指定只下载某一个指定的分支。如果不指定，一般情况git clone拿到的都是master分支。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git <span class="hljs-built_in">clone</span> https://github.com/ryanoasis/nerd-fonts.git --depth 1 --branch master<br></code></pre></td></tr></table></figure><p>nerd-fonts这个repository，即便只下载master分支最近一次提交，都有1G多。</p><p>如果需要clone多个分支，可以先在本地创建一个分支，然后再pull下来。</p><h2 id="6-版本回退"><a href="#6-版本回退" class="headerlink" title="6 版本回退"></a>6 版本回退</h2><blockquote><p>情况一：未使用 git add 缓存代码时</p></blockquote><p>实际上是从暂存区复制了一份代码来取代当前已经修改的代码</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 放弃单个文件修改,注意不要忘记中间的&quot;--&quot;,不写就成了检出分支了!</span><br>git checkout -- filepathname<br><span class="hljs-comment"># 放弃所有的文件修改</span><br>git checkout .<br></code></pre></td></tr></table></figure><blockquote><p>情况二：已经使用了 git add 缓存了代码</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 放弃指定文件的缓存</span><br>git reset HEAD filepathname<br><span class="hljs-comment"># 放弃所有的缓存</span><br>git reset HEAD . <br></code></pre></td></tr></table></figure><p>此命令仅撤销 git add 命令的操作。使用本命令后，本地的修改并不会消失，而是回到了情况一的状态。若要放弃本地的修改，需再执行情况一的操作。</p><blockquote><p>情况三：已经用 git commit 提交了代码</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 回退到上一次commit前的状态</span><br>git reset --hard HEAD^<br><span class="hljs-comment"># 回退到上上一次commit前的状态</span><br>git reset --hard HEAD^^<br><span class="hljs-comment"># 回退到100次commit前的状态</span><br>git reset --hard HEAD~100<br><span class="hljs-comment"># 回退到指定的版本（[commitId]是指定版本号的前几位）</span><br>git reset --hard [commitId]<br><br><span class="hljs-comment"># 下面三个用来对比着看</span><br>git reset [commitId] --sort，这是最弱的回滚方式，只改变commit信息，不影响暂存区和工作区；<br>git reset [commitId]，不携带参数时，默认只回滚暂存区，也就是把dks8v所在的信息复制到暂存区，但是不影响工作区；<br>git reset [commitId] --hard，这种方式则能回滚工作区和暂存区。<br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">git reflog  <span class="hljs-comment"># 查看历史版本信息</span><br>git reflog -n 5  <span class="hljs-comment"># 查看近5条历史版本信息</span><br>git <span class="hljs-built_in">log</span> --pretty=oneline<br></code></pre></td></tr></table></figure><p><strong>报错解决：<a href="https://blog.csdn.net/qq_40147863/article/details/84558452">git reset –hard HEAD^ 后显示 more?的解决方案</a></strong></p><blockquote><p>情况四：想撤销之前的某一版本，但是又想保留该目标版本后面的版本</p></blockquote><p>比如，我们commit了三个版本（版本一、版本二、 版本三），突然发现版本二不行（如：有bug），想要撤销版本二，但又不想影响撤销版本三的提交，就可以用 git revert 命令来反做版本二，生成新的版本四，这个版本四里会保留版本三的东西，但撤销了版本二的东西。</p><p><img src="/images/Git%E7%AC%94%E8%AE%B0.assets/image-20200930105306846.png" alt="image-20200930105306846"></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 反做指定的版本（xxxx是指定版本号的前几位）</span><br>git revert -n xxxx<br></code></pre></td></tr></table></figure><blockquote><p>情况五：修改 commit 的注释</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 修改完成提交的注释信息</span><br>git commit --amend<br></code></pre></td></tr></table></figure><ol><li>git commit –amend，会出现上一次提交时的comment（即vim模式下查看记录）</li><li>按Insert键进入编辑模式，改好后Esc，:wq!保存退出</li><li>git log 查看上一次 commit 的 comment 已经改好。</li></ol><h2 id="7-分支合并操作"><a href="#7-分支合并操作" class="headerlink" title="7 分支合并操作"></a>7 分支合并操作</h2><h3 id="merge"><a href="#merge" class="headerlink" title="merge"></a>merge</h3><p>Git的合并有许多策略，默认情况下Git会帮助我们挑选合适的策略，当然如果我们需要手动指定，可以使用：git merge -s [策略名称]，了解Git合并策略的原理可以使你对合并结果有一个准确的预期。</p><blockquote><p>Fast-forward</p></blockquote><p>Fast-forward是最简单的一种合并策略，如果dev分支是master分支的祖先节点，那么合并<code>git merge dev</code>的话，只会将dev指向master当前位置，Fast-forward是Git合并两个<strong>没有分叉</strong>的分支时的默认行为。</p><blockquote><p>Recursive</p></blockquote><p>Recursive是Git在合并两个<strong>有分叉</strong>的分支时的默认行为，简单的说，是递归的进行三路合并。</p><p><img src="/images/Git%E7%AC%94%E8%AE%B0.assets/image-20201226111818890.png" alt="image-20201226111818890"></p><p>这里出现了一个新名词——三路合并（three-way merge），也是我们接下来讲解的重点。我们先搞清楚合并的整体链路。</p><ul><li>首先dev分支的c5k8x与HEAD指向的sf22x，再加上它们的最近公共祖先a23c4先进行一次三路合并；</li><li>然后将合并后的结果拷贝到<strong>暂存区</strong>和<strong>工作区</strong>；</li><li>再然后产生一次新的提交，该提交的祖先为dev和原master；</li></ul><h3 id="分支合并的原理"><a href="#分支合并的原理" class="headerlink" title="分支合并的原理"></a>分支合并的原理</h3><p>首先，我们来看看两个文件如何合并：</p><p>下图所示为test.py中某一行的代码，如果我们要将A/B两个版本合并，就需要确定是A修改了B，还是B修改了A，亦或者两者都修改了，显然这种情况下分辨不出来。</p><p><img src="/images/Git%E7%AC%94%E8%AE%B0.assets/image-20201226111850253.png" alt="image-20201226111850253"></p><p>因此，为了实现两个文件的合并，我们引入<strong>三路合并</strong>：</p><p>如下图所示，很显然A与Base版本相同，B版本的修改比A版本新，因此将A/B合并后，得到的就是B版本。</p><p><img src="/images/Git%E7%AC%94%E8%AE%B0.assets/image-20201226111928389.png" alt="image-20201226111928389"></p><p>聪明的读者看完上面的例子，就会想到，要是A/B和Base都不一样怎么办？这就是接下来要讲的问题了。</p><h4 id="冲突"><a href="#冲突" class="headerlink" title="冲突"></a>冲突</h4><p>当出现下图这种情况时，一般就需要我们手动解决冲突了。</p><p><img src="/images/Git%E7%AC%94%E8%AE%B0.assets/image-20201226111954238.png" alt="image-20201226111954238"></p><p>也就是我们在合并代码时往往会看到的一种情况：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash">&lt;&lt;&lt;&lt;&lt;&lt;&lt; <span class="hljs-string">HEAD</span><br><span class="hljs-string">print(&quot;hello&quot;)</span><br><span class="hljs-string">=======</span><br><span class="hljs-string">print(&quot;fxxk&quot;)</span><br><span class="hljs-string">&gt;&gt;&gt;&gt;&gt;&gt;&gt; B</span><br></code></pre></td></tr></table></figure><p>对于新手而言，看到这个箭头可能有点摸不着头脑，到底哪个是哪个呢？其实分辨起来很简单，中间的<code>=======</code>是分隔符，到最上方的<code>&lt;&lt;&lt;&lt;&lt;&lt;</code>之间的内容，是HEAD版本，也就是当前的master分支，而到最下方<code>&gt;&gt;&gt;&gt;&gt;&gt;</code>之间的内容，则是分支B的，我们只需要删除箭头，保留所需要的版本即可：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;hello&quot;</span>)<br></code></pre></td></tr></table></figure><p>最终合并结果：</p><p><img src="/images/Git%E7%AC%94%E8%AE%B0.assets/image-20201226173717377.png" alt="image-20201226173717377"></p><h4 id="递归三路合并"><a href="#递归三路合并" class="headerlink" title="递归三路合并"></a>递归三路合并</h4><p>在实际的生产环境中，Git的分支往往非常繁杂，会导致合并A/B时，能找到多个A/B的共同祖先，而所谓的递归三路合并就是，对它们的共同祖先继续找共同祖先，直到找到唯一一个共同祖先为止，这样可以减少冲突的概率。</p><p><img src="/images/Git%E7%AC%94%E8%AE%B0.assets/image-20201226173818584.png" alt="image-20201226173818584"></p><p>如上图所示，我们要合并5和6，就需要先找到5/6的共同祖先——2和3，然后再继续找共同祖先——1，当我们找到唯一祖先时，开始递归三路合并，先对1、2、3进行三路合并，得到临时节点2’/B：</p><p><img src="/images/Git%E7%AC%94%E8%AE%B0.assets/image-20201226173839154.png" alt="image-20201226173839154"></p><p>接下来继续对2、5、6进行三路合并，得到7/C：</p><p><img src="/images/Git%E7%AC%94%E8%AE%B0.assets/image-20201226173903111.png" alt="image-20201226173903111"></p><h3 id="rebase"><a href="#rebase" class="headerlink" title="rebase"></a>rebase</h3><p>当我们处于dev分支，然后使用git rebase master时，可以理解为把dev分支上的部分在master分支后面重新提交了一遍（重演），具体看下图：</p><p><img src="/images/Git%E7%AC%94%E8%AE%B0.assets/image-20201226173929519.png" alt="image-20201226173929519"></p><p>首先找到dev分支和master分支的祖先a23c4，然后从a23c4到dev所在路径上的节点，都通过回放的方式插入到master之后，注意，这里“复制”的过程中，commitId是会改变的。同时，dev旧分支上的节点因为没有了引用则会被丢弃。</p><p><strong>⚠️该篇章内容源自某篇公众号推文，当时做笔记忘了附上文章出处，此处冒犯了，作者可联系我加上出处或删除内容～</strong></p><h2 id="8-Git提交规范"><a href="#8-Git提交规范" class="headerlink" title="8 Git提交规范"></a>8 Git提交规范</h2><h3 id="8-1-总体方案"><a href="#8-1-总体方案" class="headerlink" title="8.1 总体方案"></a>8.1 总体方案</h3><blockquote><p>目的</p></blockquote><ul><li><strong>统一团队 <code>Git commit</code> 日志标准，便于后续代码 review，版本发布以及日志自动化生成等等</strong>。</li><li><strong>统一团队的 Git 工作流，包括分支使用、tag 规范、issue 等</strong></li></ul><blockquote><p>Git commit 日志参考案例</p></blockquote><ul><li><a href="https://github.com/angular/angular">angular</a></li><li><a href="https://github.com/cpselvis/commit-message-test-project">commit-message-test-project</a></li><li><a href="https://github.com/istanbuljs/babel-plugin-istanbul">babel-plugin-istanbul</a></li><li><a href="https://github.com/conventional-changelog/conventional-changelog">conventional-changelog</a></li></ul><p><img src="/images/Git%E7%AC%94%E8%AE%B0.assets/image-20211018010338803.png" alt="image-20211018010338803"></p><h3 id="8-2-Git-commit日志基本规范"><a href="#8-2-Git-commit日志基本规范" class="headerlink" title="8.2 Git commit日志基本规范"></a>8.2 Git commit日志基本规范</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash">&lt;<span class="hljs-built_in">type</span>&gt;(&lt;scope&gt;): &lt;subject&gt;<br>&lt;BLANK LINE&gt;<br>&lt;body&gt;<br>&lt;BLANK LINE&gt;<br>&lt;footer&gt;<br></code></pre></td></tr></table></figure><blockquote><p><strong>type</strong></p></blockquote><p>type代表某次提交的类型，比如是修复一个bug还是增加一个新的feature。</p><ul><li>feat： 新增 feature</li><li>fix: 修复 bug</li><li>docs: 仅仅修改了文档，比如 README, CHANGELOG, CONTRIBUTE等等</li><li>style: 仅仅修改了空格、格式缩进、逗号等等，不改变代码逻辑</li><li>refactor: 代码重构，没有加新功能或者修复 bug</li><li>perf: 优化相关，比如提升性能、体验</li><li>test: 测试用例，包括单元测试、集成测试等</li><li>chore: 改变构建流程、或者增加依赖库、工具等</li><li>revert: 回滚到上一个版本</li></ul><blockquote><p><strong>scope</strong></p></blockquote><p><code>scope</code>用于说明 commit 影响的范围，比如数据层、控制层、视图层等等，视项目不同而不同。</p><blockquote><p><strong>subject</strong></p></blockquote><p><code>subject</code>是 commit 目的的简短描述，不超过50个字符。</p><ul><li>以动词开头，使用第一人称现在时，比如<code>change</code>，而不是<code>changed</code>或<code>changes</code></li><li>第一个字母小写</li><li>结尾不加句号（<code>.</code>）</li></ul><blockquote><p><strong>body</strong></p></blockquote><p>body 部分是对本次 commit 的详细描述，可以分成多行。下面是一个范例。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs bash">More detailed explanatory text, <span class="hljs-keyword">if</span> necessary.  Wrap it to <br>about 72 characters or so. <br><br>Further paragraphs come after blank lines.<br><br>- Bullet points are okay, too<br>- Use a hanging indent<br></code></pre></td></tr></table></figure><p>有两个注意点。</p><ul><li>使用第一人称现在时，比如使用<code>change</code>而不是<code>changed</code>或<code>changes</code>。</li><li>应该说明代码变动的动机，以及与以前行为的对比。</li></ul><blockquote><p><strong>footer</strong></p></blockquote><p>footer 部分只用于两种情况。</p><p><strong>（1）不兼容变动</strong></p><p>如果当前代码与上一个版本不兼容，则 Footer 部分以<code>BREAKING CHANGE</code>开头，后面是对变动的描述、以及变动理由和迁移方法。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs bash">BREAKING CHANGE: isolate scope bindings definition has changed.<br><br>    To migrate the code follow the example below:<br><br>    Before:<br><br>    scope: &#123;<br>      myAttr: <span class="hljs-string">&#x27;attribute&#x27;</span>,<br>    &#125;<br><br>    After:<br><br>    scope: &#123;<br>      myAttr: <span class="hljs-string">&#x27;@&#x27;</span>,<br>    &#125;<br><br>    The removed `inject` wasn<span class="hljs-string">&#x27;t generaly useful for directives so there should be no code using it.</span><br></code></pre></td></tr></table></figure><p><strong>（2）关闭 Issue</strong></p><p>如果当前 commit 针对某个issue，那么可以在 Footer 部分关闭这个 issue 。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">Closes <span class="hljs-comment">#234</span><br></code></pre></td></tr></table></figure><p>也可以一次关闭多个 issue 。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">Closes <span class="hljs-comment">#123, #245, #992</span><br></code></pre></td></tr></table></figure><p><strong>格式要求：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 标题行：50个字符以内，描述主要变更内容</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># 主体内容：更详细的说明文本，建议72个字符以内。 需要描述的信息包括:</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># * 为什么这个变更是必须的? 它可能是用来修复一个bug，增加一个feature，提升性能、可靠性、稳定性等等</span><br><span class="hljs-comment"># * 他如何解决这个问题? 具体描述解决问题的步骤</span><br><span class="hljs-comment"># * 是否存在副作用、风险? </span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># 尾部：如果需要的化可以添加一个链接到issue地址或者其它文档，或者关闭某个issue。</span><br></code></pre></td></tr></table></figure><p><strong>参考博客：</strong></p><ul><li><a href="https://github.com/feflow/git-commit-style-guide">git-commit-style-guide</a> </li><li><a href="https://www.cnblogs.com/daysme/p/7722474.html">Git 提交的正确姿势：Commit message 编写指南</a> </li></ul><h3 id="8-3-Git分支与版本发布规范"><a href="#8-3-Git分支与版本发布规范" class="headerlink" title="8.3 Git分支与版本发布规范"></a>8.3 Git分支与版本发布规范</h3><ul><li>基本原则：master为保护分支，不直接在master上进行代码修改和提交。</li><li>开发日常需求或者项目时，从master分支上checkout一个feature分支进行开发或者bugfix分支进行bug修复，功能测试完毕并且项目发布上线后，将feature分支合并到主干master，并且打Tag发布，最后删除开发分支。分支命名规范：<ul><li>分支版本命名规则：分支类型 _ 分支发布时间 _ 分支功能。比如：feat_20170401_fairy_flower</li><li>分支类型包括：feat、 fix、refactor三种类型，即新功能开发、bug修复和代码重构</li><li>时间使用年月日进行命名，不足2位补0</li><li>分支功能命名使用snake case命名法，即下划线命名。</li></ul></li><li>Tag包括3位版本，前缀使用v。比如v1.2.31。Tag命名规范：<ul><li>新功能开发使用第2位版本号，bug修复使用第3位版本号</li><li>核心基础库或者Node中间价可以在大版本发布请使用灰度版本号，在版本后面加上后缀，用中划线分隔。alpha或者belta后面加上次数，即第几次alpha：<ul><li>v2.0.0-alpha.1</li><li>v2.0.0-belta.1</li></ul></li></ul></li><li>版本正式发布前需要生成changelog文档，然后再发布上线。</li></ul><h3 id="8-4-commit模板"><a href="#8-4-commit模板" class="headerlink" title="8.4 commit模板"></a>8.4 commit模板</h3><p><em>事先说明，这里只是记录一下有这么一种配置方式，但是相比于下面的其他方式，该方式显得不太让人满意，推荐使用后面的其他配置方式。</em></p><p>为了更好地遵循Git Comment发布规范，可以在git的全局变量中配置一个commit模板，每次执行 <code>git commit</code> 指令（不携带其他参数）的时候，就会通过指定的编辑器打开这个模板，方便提交comment。通过以下方式配置的环境会记录在 <code>~/.gitconfig</code> 中，也可以直接修改该文件改变配置。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 指定使用的模板文件（我在家目录下放了一个名叫.git_commit_template的模板）</span><br>git config --global commit.template ~/.git_commit_template<br><span class="hljs-comment"># 指定使用的编辑器（默认就是vim，所以其实不指定也可以）</span><br>git config --global core.editor vim<br></code></pre></td></tr></table></figure><p><code>.git_commit_template</code>模板文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># &lt;type&gt;(&lt;scope&gt;): &lt;subject&gt;</span><br><br><span class="hljs-comment"># &lt;body&gt;</span><br><br><span class="hljs-comment"># &lt;footer&gt;</span><br></code></pre></td></tr></table></figure><h3 id="8-5-validate-commit-msg"><a href="#8-5-validate-commit-msg" class="headerlink" title="8.5 validate-commit-msg"></a>8.5 validate-commit-msg</h3><p><a href="https://www.npmjs.com/package/validate-commit-msg">validate-commit-msg</a>是一个托管在npm平台的工具包，用来约束git commit的comment规范。<del>似乎只是校验comment是否符合规范，但是并不会引导你去编写符合规范的comment。<strong>折腾了一段时间，感觉不是很符合我的预期，这里仅作记录。</strong></del>整理完最佳实践后又回过头来看了下这个接入方法，其实用的工具都是差不多的，只是README写的不详细，后端人员一下子理解不了。</p><p>接入方法参考<a href="https://github.com/cpselvis/commit-message-test-project">commit-message-test-project</a>项目。具体步骤如下：</p><ul><li>第一步：在工程跟目录下的package.json文件加入如下代码所示的scripts和dependencies内容，版本号为3位版本号（通过npm安装）。</li></ul><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs json">&#123;<br>    <span class="hljs-attr">&quot;name&quot;</span>: <span class="hljs-string">&quot;application-name&quot;</span>,<br>    <span class="hljs-attr">&quot;version&quot;</span>: <span class="hljs-string">&quot;0.1.0&quot;</span>,<br>    <span class="hljs-attr">&quot;scripts&quot;</span>: &#123;<br>        <span class="hljs-attr">&quot;commitmsg&quot;</span>: <span class="hljs-string">&quot;validate-commit-msg&quot;</span>,<br>        <span class="hljs-attr">&quot;commit&quot;</span>: <span class="hljs-string">&quot;git-cz &quot;</span>,<br>        <span class="hljs-attr">&quot;changelog&quot;</span>: <span class="hljs-string">&quot;conventional-changelog -p angular -i CHANGELOG.md -s -r 0&quot;</span><br>    &#125;,<br>    <span class="hljs-attr">&quot;devDependencies&quot;</span>: &#123;<br>        <span class="hljs-attr">&quot;commitizen&quot;</span>: <span class="hljs-string">&quot;^2.3.0&quot;</span>,<br>        <span class="hljs-attr">&quot;validate-commit-msg&quot;</span>: <span class="hljs-string">&quot;^2.11.1&quot;</span>,<br>        <span class="hljs-attr">&quot;conventional-changelog-cli&quot;</span>: <span class="hljs-string">&quot;^1.2.0&quot;</span>,<br>        <span class="hljs-attr">&quot;husky&quot;</span>: <span class="hljs-string">&quot;^0.13.1&quot;</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>第二步：在工程根目录新建.vcmrc文件，并且文件内容为</li></ul><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs json">&#123;<br>    <span class="hljs-attr">&quot;helpMessage&quot;</span>: <span class="hljs-string">&quot;\nPlease fix your commit message (and consider using https://www.npmjs.com/package/commitizen)\n&quot;</span>,<br>    <span class="hljs-attr">&quot;types&quot;</span>: [<br>        <span class="hljs-string">&quot;feat&quot;</span>,<br>        <span class="hljs-string">&quot;fix&quot;</span>,<br>        <span class="hljs-string">&quot;docs&quot;</span>,<br>        <span class="hljs-string">&quot;style&quot;</span>,<br>        <span class="hljs-string">&quot;refactor&quot;</span>,<br>        <span class="hljs-string">&quot;perf&quot;</span>,<br>        <span class="hljs-string">&quot;test&quot;</span>,<br>        <span class="hljs-string">&quot;chore&quot;</span>,<br>        <span class="hljs-string">&quot;revert&quot;</span><br>    ],<br>    <span class="hljs-attr">&quot;warnOnFail&quot;</span>: <span class="hljs-literal">false</span>,<br>    <span class="hljs-attr">&quot;autoFix&quot;</span>: <span class="hljs-literal">false</span><br>&#125;<br></code></pre></td></tr></table></figure><p><strong>接入后的操作流程</strong></p><ul><li>第一步：创建一个feature分支或者bugfix分支</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ git checkout -b feature_infinite_load    <span class="hljs-comment"># 切换到一个feature分支或者bug fix分支</span><br></code></pre></td></tr></table></figure><ul><li>第二步：将代码提交到本地Git仓库，并填写符合要求的Commit message格式</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ git add .<br>$ git commit                               <span class="hljs-comment"># 此处不要加任何参数，比如-m</span><br></code></pre></td></tr></table></figure><ul><li>第三步：将代码同步到远程Git仓库</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ git push origin feature_infinite_load    <span class="hljs-comment"># 将修改发布到远程仓库 </span><br></code></pre></td></tr></table></figure><ul><li>第四步：自动生成changelog，并打Tag发布</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ tnpm run changelog             <span class="hljs-comment"># 使用npm script中的changlog命令直接从git元数据生成日志。</span><br>$ git tag v0.1.0<br>$ git push origin v0.1.0<br></code></pre></td></tr></table></figure><h3 id="8-6-Git-Commit-Template"><a href="#8-6-Git-Commit-Template" class="headerlink" title="8.6 Git Commit Template"></a>8.6 Git Commit Template</h3><p>上面的操作和配置还有有点复杂，而且不是那么智能，在<strong>idea</strong>中可以安装<strong>Git Commit Template</strong>插件，通过该插件可以根据提示填写commit信息，由插件负责组织commit comment的格式。</p><p><img src="/images/Git%E7%AC%94%E8%AE%B0.assets/image-20211018190648255.png" alt="image-20211018190648255.png"></p><p>这种方式的话，直接填空就行了，不过只能在idea中使用（或者别的IDE），稍有不足。</p><h3 id="8-7-最佳实践"><a href="#8-7-最佳实践" class="headerlink" title="8.7 最佳实践"></a>8.7 最佳实践</h3><p>🙏感谢 @前端左小白 整理该内容，并且在我寻求最佳实践的同一天发布了bilibili教学视频，对我帮助很大。</p><ul><li><a href="https://www.bilibili.com/video/BV193411C7XE">git commit 最佳实践，commitizen + husky + commitlint 规范化校验</a> </li><li><a href="https://github.com/zuoxiaobai/commitizen-practice-demo">commitizen-practice-demo</a> </li></ul><p>整个最佳实践分为3个部分，分别是：</p><ol><li>commitizen引导式comment填写</li><li>husky+commitlint强制性规范校验</li><li>standard-version生成changelog。</li></ol><p>由于我并不是前端工程师，强迫症导致不喜欢在工程目录留存一些多余的文件/目录，所以后面设计的各项插件，我都尽可能做全局安装+配置，只有部分配置文件保留在工程目录下。</p><blockquote><p>commitizen引导式comment填写</p></blockquote><p><a href="https://github.com/commitizen/cz-cli">commitizen</a> 是一个 cli 工具，用于规范化 git commit 信息。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># commitizen全局安装+全局配置（装机后单用户只需操作一次）</span><br>npm install -g commitizen  <span class="hljs-comment"># 安装规范化提交插件</span><br><span class="hljs-built_in">echo</span> <span class="hljs-string">&#x27;&#123;&quot;path&quot;: &quot;cz-conventional-changelog&quot;&#125;&#x27;</span> &gt; ~/.czrc  <span class="hljs-comment"># 配置</span><br></code></pre></td></tr></table></figure><p>安装完成后，以后使用 <code>git cz</code> 指令代替 <code>git commit</code> 做提交，即可开启引导式的comment填写！</p><p><strong>特殊的fix类型提交</strong></p><p>当选择的 <code>type</code> 是 <code>fix</code> 的时候，引导指令会询问是否有issues受本次提交的影响，如果有的话，可以填写fix相关issues的编号，这样就能够自动在github上回复或关闭该issue。</p><p>此外，在 <code>short description</code> 中如果带上了issue编号的话，会自动被加上超链接，这个挺不错的，建议直接在 <code>short description</code> 的最后用一个小括号带上issue编号就好，例如 <code>this is a short description (#123)</code>。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs bash">zuo@zmac comitizen-practice-demo % git cz<br>cz-cli@4.2.4, cz-conventional-changelog@3.2.0<br><br><span class="hljs-comment"># ? Select the type of change that you&#x27;re committing: fix:      A bug fix</span><br><span class="hljs-comment"># ? What is the scope of this change (e.g. component or file name): (press enter to skip) public</span><br><span class="hljs-comment"># ? Write a short, imperative tense description of the change (max 87 chars):</span><br><span class="hljs-comment">#  (28) auto close github issue test</span><br><span class="hljs-comment"># ? Provide a longer description of the change: (press enter to skip)</span><br> <br><span class="hljs-comment"># ? Are there any breaking changes? No</span><br><span class="hljs-comment"># ? Does this change affect any open issues? Yes</span><br><span class="hljs-comment"># ? If issues are closed, the commit requires a body. Please enter a longer description of the commit itself:</span><br><span class="hljs-comment">#  try to fix issue 2, just a msg</span><br><span class="hljs-comment"># ? Add issue references (e.g. &quot;fix #123&quot;, &quot;re #123&quot;.):</span><br><span class="hljs-comment">#  fix #2</span><br><span class="hljs-comment"># [main 146e7b9] fix(public): auto close github issue test</span><br><span class="hljs-comment">#  1 file changed, 1 insertion(+)</span><br><span class="hljs-comment"># zuo@zmac comitizen-practice-demo % </span><br></code></pre></td></tr></table></figure><blockquote><p>husky+commitlint强制性规范校验</p></blockquote><p>和上面提到的Git Commit Template插件类似，commitizen终归是防君子不防小人，如果有人直接使用 <code>commit -m&#39;some comments&#39;</code> 命令提交commit，仍然能够提交不符合规范的commit comment。因此通过<a href="https://github.com/conventional-changelog/commitlint">commitlint</a>来强制性的约束comment必须符合<a href="https://www.conventionalcommits.org/en/v1.0.0/">conventional commits</a>规范（其实和validate-commit-msg做的事情是一样的，但这个配置少一点）。</p><p>这里面commitlint只起到规范校验的作用，而git commit后执行commitlint规范校验的行为是通过<a href="https://github.com/typicode/husky">husky</a>钩子来实现的，husky保证commitlint规范校验在git commit指令键入之后被执行。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># commitlint、husky全局安装（装机后单用户只需操作一次）</span><br>npm install -g @commitlint/cli @commitlint/config-conventional<br>npm install -g husky<br><br><span class="hljs-comment"># commitlint全局配置（装机后单用户只需操作一次）</span><br><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;module.exports = &#123;extends: [&#x27;@commitlint/config-conventional&#x27;]&#125;&quot;</span> &gt; ~/.commitlintrc.js<br><br><span class="hljs-comment"># 以下操作每个工程创建后都需要执行一次</span><br><span class="hljs-comment"># Configure commitlint to use conventional config 舍弃该配置，用全局配置</span><br><span class="hljs-comment"># echo &quot;module.exports = &#123;extends: [&#x27;@commitlint/config-conventional&#x27;]&#125;&quot; &gt; commitlint.config.js</span><br><br><span class="hljs-comment"># 生成 husky git hooks</span><br>npx husky install<br><br><span class="hljs-comment"># 添加 git commit 钩子</span><br>npx husky add .husky/commit-msg <span class="hljs-string">&#x27;npx --no-install commitlint --edit &quot;$1&quot;&#x27;</span><br></code></pre></td></tr></table></figure><p>有一个小问题，使用commitlint之后，如果再通过IDEA的commit窗口提交代码，会报错。。说找不到commitlint。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">Commit failed with error<br>0 file committed, 1 file failed to commit: feat: 测试<br>not found: commitlint<br>husky - commit-msg hook exited with code 127 (error)<br></code></pre></td></tr></table></figure><p>检查了一下，和commitlint是否使用全局配置没有关系，暂时没有比较好的解决方式，有两种妥协的处理方法：</p><ol><li>以后都不使用IDEA的commit窗口提交代码，全在命令行提交；</li><li>IDEA的工程就不做husky钩子配置了，也就是说，什么配置都不用做，但是必须使用以下两种方式提交代码：<ul><li>用Git Commit Template插件来生成comment然后再通过commit窗口提交；</li><li>使用commitizen从命令行提交。</li></ul></li></ol><p>当然还是推荐第二种方法啦，连配置都不用做了，自己约束好自己问题不大。</p><blockquote><p>standard-version生成changelog</p></blockquote><p><a href="https://github.com/conventional-changelog/standard-version">standard-version</a>是一个用来控制版本发布的工具。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># standard-version全局安装（装机后单用户只需操作一次）</span><br>npm install -g standard-version<br></code></pre></td></tr></table></figure><p>使用说明：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 查看帮助文档</span><br>npx standard-version --<span class="hljs-built_in">help</span><br><span class="hljs-comment"># 发布第一个版本</span><br>npx standard-version --first-release<br><br><span class="hljs-comment"># 0.4.1</span><br>npx standard-version <span class="hljs-comment"># 0.4.1 =&gt; 0.4.2</span><br>npx standard-version -- --prerelease <span class="hljs-comment"># 0.4.2 to 0.4.3-0</span><br>npx standard-version <span class="hljs-comment"># 0.4.3-0 to 0.4.3</span><br>npx standard-version -- --prerelease alpha <span class="hljs-comment"># 0.4.3 to 0.4.4-alpha.0</span><br><br><span class="hljs-comment"># patch、minor、major</span><br>npx standard-version --release-as minor  <span class="hljs-comment"># 0.4.4-alpha.0 to 0.5.0</span><br>npx standard-version --release-as patch <span class="hljs-comment"># 0.5.0 to 0.5.1</span><br>npx standard-version --release-as major <span class="hljs-comment"># 0.5.1 to 1.0.0</span><br>npx standard-version --release-as prepatch <span class="hljs-comment"># 1.0.0 to 1.0.1-0</span><br>npx standard-version --release-as preminor <span class="hljs-comment"># 1.0.1-0 to 1.1.0-0</span><br>npx standard-version --release-as premajor <span class="hljs-comment"># 1.1.0-0 to 2.0.0-0</span><br><br><span class="hljs-comment"># 手动指定版本</span><br>npx standard-version --release-as 2.1.3-alpha.1 <span class="hljs-comment"># 2.0.0-0 to 2.1.3-alpha.1</span><br><span class="hljs-comment"># ✔ bumping version in package.json from 2.0.0-0 to 2.1.3-alpha.1</span><br><span class="hljs-comment"># ✔ bumping version in package-lock.json from 2.0.0-0 to 2.1.3-alpha.1</span><br><span class="hljs-comment"># ✔ tagging release v2.1.3-alpha.1</span><br><br>npx standard-version <span class="hljs-comment"># 2.1.3-alpha.1 to 2.2.0</span><br></code></pre></td></tr></table></figure><p>标签和版本号不会在 <code>git push</code> 的时候自动推送到github，需要单独手动推送。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git push --tags  <span class="hljs-comment"># 推送上面的标签和版本号到github</span><br></code></pre></td></tr></table></figure><p>注意，不是每一次commit都应该生成一次tag，而是应该在有一个较为完整的改动/新增完成之后（可能涉及到众多的commit），才统一发布一个tag/release。在每次 <code>git cz</code> 之后，根据type以及一些其他因素的不同，<code>npx standard-version</code> 会自动调整版本发布的编号，比如一次fix一般版本号+0.0.1，默认一般+0.1.0，如果有重大feature则+1.0.0，大致是这么个规律，后面需要可以再深入研究一下。</p><p>执行<code>npx standard-version</code> 之后会追加信息到changelog文档，并且自动单独做一次commit提交。</p><h2 id="9-常用License"><a href="#9-常用License" class="headerlink" title="9 常用License"></a>9 常用License</h2><blockquote><p>GPL</p></blockquote><p>GPL 是 GNU General Public License(GNU 通用公共许可证)的缩写形式。</p><ol><li>任何一套软件，只要其中使用了受 GPL 协议保护的第三方软件的源程序，并向非开发人员发布时，软件本身也就自动成为受 GPL 保护并且约束的实体。也就是说，此时它必须开放源代码。</li><li>允许去掉所有原作的版权信息，只要你保持开源，并且随源代码、二进制版附上 GPL 的许可证就行，让后人可以很明确地得知此软件的授权信息。GPL 精髓就是，使软件在完整开源的情况下，尽可能让使用者得到自由发挥的空间，使软件得到更快更好的发展。</li><li>无论软件以何种形式发布，都必须同时附上源代码。</li><li>开发或维护遵循 GPL 协议开发的软件的公司或个人，可以对使用者收取一定的服务费用。但必须无偿提供软件的完整源代码，不得将源代码与服务做捆绑或任何变相捆绑销售。</li></ol><blockquote><p>LGPL</p></blockquote><p>LGPL 是 GNU Lesser General Public License (GNU 宽通用公共许可证)的缩写形式。</p><p><strong>GPL和LGPL对比</strong></p><ul><li>基于 GPL 的软件允许商业化销售，但不允许封闭源代码。如果您对遵循GPL的软件进行任何改动和/或再次开发并予以发布，则您的产品必须继承 GPL 协议，不允许封闭源代码。</li><li>基于 LGPL 的软件也允许商业化销售，但不允许封闭源代码。如果您对遵循 LGPL 的软件进行任何改动和/或再次开发并予以发布，则您的产品必须继承LGPL协议，不允许封闭源代码。但是如果您的程序对遵循 LGPL 的软件进行任何连接、调用而不是包含，则允许封闭源代码。</li></ul><blockquote><p>BSD</p></blockquote><p>BSD开源协议是一个给于使用者很大自由的协议。基本上使用者可以自由的使用，修改源代码，也可以将修改后的代码作为==开源或者专有软件==再发布。</p><p>当使用了BSD协议的代码，或者以BSD协议代码为基础做二次开发自己的产品时，需要满足三个条件：</p><ul><li>如果再发布的产品中包含源代码，则在源代码中必须带有==原来代码==中的BSD协议；</li><li>如果再发布的只是二进制类库/软件，则需要在类库/软件的文档和版权声明中包含原来代码中的BSD协议；</li><li>不可以用开源代码的作者/机构名字和原来产品的名字做市场推广。</li></ul><p>因此，很多公司企业在选择开源软件的时候都首选BSD协议，因为可以完全控制这些第三方的代码，而且在必要的时候可以进行修改或者二次开发。</p><blockquote><p>MIT</p></blockquote><p>MIT是和BSD一样宽范的许可协议，作者只想保留版权,而无任何其他了限制。也就是说，你必须在你的发行版里包含原许可协议的声明，无论你是以二进制发布的还是以源代码发布的。</p><blockquote><p>Apache License</p></blockquote><p>Apache Licence是著名的非盈利开源组织Apache采用的协议。该协议和BSD类似，同样鼓励代码共享和尊重原作者的著作权，同样允许代码修改，再发布(作为开源或商业软件)。需要满足的条件也和BSD类似：</p><p>需要给代码的用户一份Apache Licence；如果你修改了代码，需要在被修改的文件中说明；在延伸的代码中（修改和有源代码衍生的代码中）需要带有原来代码中的协议，商标，专利声明和其他原来作者规定需要包含的说明；如果再发布的产品中包含一个Notice文件，则在Notice文件中需要带有Apache Licence。你可以在Notice中增加自己的许可，但不可以表现为对Apache Licence构成更改。</p><p><img src="/images/Git%E7%AC%94%E8%AE%B0.assets/image-20210825100118391.png" alt="image-20210825100118391"></p>]]></content>
    
    
    <categories>
      
      <category>general</category>
      
    </categories>
    
    
    <tags>
      
      <tag>project</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Spring注解驱动开发笔记</title>
    <link href="/2021/10/13/Spring%E6%B3%A8%E8%A7%A3%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0/"/>
    <url>/2021/10/13/Spring%E6%B3%A8%E8%A7%A3%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="Spring注解驱动开发笔记"><a href="#Spring注解驱动开发笔记" class="headerlink" title="Spring注解驱动开发笔记"></a>Spring注解驱动开发笔记</h1><h2 id="1-一切的起点"><a href="#1-一切的起点" class="headerlink" title="1 一切的起点"></a>1 一切的起点</h2><h3 id="1-1-pom父依赖"><a href="#1-1-pom父依赖" class="headerlink" title="1.1 pom父依赖"></a>1.1 pom父依赖</h3><blockquote><p><strong>pom.xml</strong></p></blockquote><ul><li>spring-boot-dependencies：核心依赖在父工程中</li><li>我们在写或者引入一些Springboot依赖的时候，不需要指定版本，就因为有这些版本仓库</li></ul><p>1、其中它主要是依赖一个父项目，主要是管理项目的资源过滤及插件</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">parent</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-parent<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.3.1.RELEASE<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">relativePath</span>/&gt;</span> <br>    <span class="hljs-comment">&lt;!-- lookup parent from repository --&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">parent</span>&gt;</span><br></code></pre></td></tr></table></figure><p>2、点进去，发现还有一个父依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">parent</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-dependencies<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.3.1.RELEASE<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">parent</span>&gt;</span><br></code></pre></td></tr></table></figure><p>3、这里才是真正管理SpringBoot应用里面所有依赖版本的地方，SpringBoot的版本控制中心；</p><p><strong>4、以后我们导入依赖默认是不需要写版本；但是如果导入的包没有在依赖中管理着就需要手动配置版本了；</strong></p><h3 id="1-2-spring-boot-starter"><a href="#1-2-spring-boot-starter" class="headerlink" title="1.2 spring-boot-starter"></a>1.2 spring-boot-starter</h3><ul><li><p>依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure></li><li><p><strong>springboot-boot-starter-xxx</strong>，说白了就是Springboot的启动场景</p></li><li><p>比如<strong>spring-boot-starter-web</strong>，他就会帮我们自动导入web的所有依赖</p></li><li><p>springboot会将所有的功能场景，都变成一个个的启动器</p></li><li><p>我们要使用什么功能，就只需要找到对应的启动器就好了<code>start</code></p></li><li><p><a href="https://docs.spring.io/spring-boot/docs/current/reference/html/using-spring-boot.html#using-boot-starter">官方的所有starter</a></p></li></ul><h3 id="1-3-SpringBootApplication"><a href="#1-3-SpringBootApplication" class="headerlink" title="1.3 @SpringBootApplication"></a>1.3 @SpringBootApplication</h3><blockquote><h4 id="默认的主启动类"><a href="#默认的主启动类" class="headerlink" title="默认的主启动类"></a>默认的主启动类</h4></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//@SpringBootApplication 来标注一个主程序类</span><br><span class="hljs-comment">//说明这是一个Spring Boot应用</span><br><span class="hljs-meta">@SpringBootApplication</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SpringbootApplication</span> </span>&#123;<br>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>     <span class="hljs-comment">//以为是启动了一个方法，没想到启动了一个服务</span><br>      SpringApplication.run(SpringbootApplication.class, args);<br>   &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>但是，一个简单的启动类并不简单，我们来分析一下这些注解都干了什么。</p><blockquote><h4 id="拆分注解（-SpringBootApplication）"><a href="#拆分注解（-SpringBootApplication）" class="headerlink" title="拆分注解（@SpringBootApplication）"></a>拆分注解（@SpringBootApplication）</h4></blockquote><p><img src="/images/Spring%E6%B3%A8%E8%A7%A3%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0.assets/Snipaste_2021-10-13_16-37-28.png"></p><ul><li><p>作用：标注在某个类上说明这个类是SpringBoot的主配置；</p></li><li><p>SpringBoot就应该运行这个类的main方法来启动SpringBoot应用；</p></li><li><p>进入这个注解：可以看到上面还有很多其他注解</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@SpringBootConfiguration</span><br><span class="hljs-meta">@EnableAutoConfiguration</span><br><span class="hljs-meta">@ComponentScan(</span><br><span class="hljs-meta">    excludeFilters = &#123;</span><br><span class="hljs-meta">        @Filter(type = FilterType.CUSTOM, classes = &#123;TypeExcludeFilter.class&#125;), </span><br><span class="hljs-meta">        @Filter(type = FilterType.CUSTOM, classes = &#123;AutoConfigurationExcludeFilter.class&#125;)</span><br><span class="hljs-meta">    &#125;</span><br><span class="hljs-meta">)</span><br><span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> SpringBootApplication &#123;<br>    <span class="hljs-comment">// ......</span><br>&#125;<br></code></pre></td></tr></table></figure></li></ul><p>==<strong>@ComponentScan</strong>==</p><ul><li>这个注解在Spring中很重要，它对应XML配置中的元素。</li><li>作用：自动扫描并加载符合条件的组件或者bean，将这个bean定义加载到IOC容器中。</li></ul><p>==<strong>@SpringBootConfiguration</strong>==</p><ul><li><p>作用：SpringBoot的配置类，标注在某个类上，表示这是一个SpringBoot的配置类；</p></li><li><p>我们继续进去这个注解查看</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 点进去得到下面的 @Component</span><br><span class="hljs-meta">@Configuration</span><br><span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> SpringBootConfiguration &#123;&#125;<br><br><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> Configuration &#123;&#125;<br></code></pre></td></tr></table></figure></li><li><p>这里的 <strong>@Configuration</strong>，说明这是一个spring的配置类，配置类就是对应Spring的xml 配置文件；</p></li><li><p><strong>@Component</strong> 这就说明，启动类本身也是Spring中的一个组件而已，负责启动应用</p></li><li><p>我们回到 SpringBootApplication 注解中继续看。</p></li></ul><p>==<strong>@EnableAutoConfiguration</strong>==</p><ul><li><p><strong>开启自动配置功能</strong></p><ul><li><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@AutoConfigurationPackage</span><br><span class="hljs-meta">@Import(&#123;AutoConfigurationImportSelector.class&#125;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> EnableAutoConfiguration &#123;<br>    <span class="hljs-comment">// ......</span><br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>以前我们需要自己配置的东西，而现在SpringBoot可以自动帮我们配置；</p></li><li><p>@EnableAutoConfiguration告诉SpringBoot开启自动配置功能，这样自动配置才能生效；</p></li></ul><p>点进注解接续查看：</p></li><li><p><strong>@AutoConfigurationPackage ：自动配置包</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Import(&#123;Registrar.class&#125;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> AutoConfigurationPackage &#123;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><strong>@import</strong>：Spring底层注解@import，给容器中导入一个组件</li><li><strong>Registrar.class</strong> 作用：实现了ImportBeanDefinitionRegistrar接口，自动配置包注册，将主启动类的所在包及包下面所有子包里面的所有组件扫描到Spring容器 ；</li><li>这个分析完了，退到上一步，继续看</li></ul></li><li><p><strong>@Import({AutoConfigurationImportSelector.class}) ：给容器导入组件 ；</strong></p><ul><li><strong>AutoConfigurationImportSelector</strong>：自动配置导入选择器，那么它会导入哪些组件的选择器呢？我们点击去这个类看源码：</li></ul></li><li><p>获取所有的配置：==List&lt;String&gt; configurations = this.getCandidateConfigurations(annotationMetadata, attributes);==</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">protected</span> List&lt;String&gt; <span class="hljs-title">getCandidateConfigurations</span><span class="hljs-params">(AnnotationMetadata metadata, AnnotationAttributes attributes)</span> </span>&#123;<br>    <span class="hljs-comment">// 和下面的方法对应</span><br>    List&lt;String&gt; configurations = SpringFactoriesLoader.loadFactoryNames(<span class="hljs-keyword">this</span>.getSpringFactoriesLoaderFactoryClass(), <span class="hljs-keyword">this</span>.getBeanClassLoader());<br><br>    Assert.notEmpty(configurations, <span class="hljs-string">&quot;No auto configuration classes found in META-INF/spring.factories. If you are using a custom packaging, make sure that file is correct.&quot;</span>);<br>    <span class="hljs-keyword">return</span> configurations;<br>&#125;<br><br><span class="hljs-comment">//  这里的getSpringFactoriesLoaderFactoryClass()方法</span><br><span class="hljs-comment">//  和上面的类的方法loadFactoryNames里面的第一个参数对应</span><br><span class="hljs-comment">//  返回的就是我们最开始看的启动自动导入配置文件的注解类；EnableAutoConfiguration</span><br><span class="hljs-keyword">protected</span> Class&lt;?&gt; getSpringFactoriesLoaderFactoryClass() &#123;<br>    <span class="hljs-keyword">return</span> EnableAutoConfiguration.class;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>这个方法<code>getCandidateConfigurations()</code>又调用了 <code>SpringFactoriesLoader</code> 类的<code>loadFactoryNames</code>静态方法，我们进入<code>SpringFactoriesLoader</code>类loadFactoryNames() 方法，获取所有的加载配置</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> List&lt;String&gt; <span class="hljs-title">loadFactoryNames</span><span class="hljs-params">(Class&lt;?&gt; factoryClass, <span class="hljs-meta">@Nullable</span> ClassLoader classLoader)</span> </span>&#123;<br>    String factoryClassName = factoryClass.getName();<br>    <span class="hljs-comment">//这里它又调用了 loadSpringFactories 方法</span><br>    <span class="hljs-keyword">return</span> (List)loadSpringFactories(classLoader).getOrDefault(factoryClassName, Collections.emptyList());<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>我们继续点击查看 loadSpringFactories 方法</p><ul><li><p>项目资源：<code>META-INF/spring.factories</code></p></li><li><p>系统资源：<code>META-INF/spring.factories</code></p></li><li><p>从这些资源中配置了所有的nextElement（自动配置），封装成properties</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//将所有的资源加载到配置类中（将下面的抽离出来分析，第15行）</span><br>Properties properties = PropertiesLoaderUtils.loadProperties(resource);<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Map&lt;String, List&lt;String&gt;&gt; loadSpringFactories(<span class="hljs-meta">@Nullable</span> ClassLoader classLoader) &#123;<br>    <span class="hljs-comment">//获得classLoader，我们返回可以看到这里得到的就是EnableAutoConfiguration标注的类本身</span><br>    MultiValueMap&lt;String, String&gt; result = (MultiValueMap)cache.get(classLoader);<br>    <span class="hljs-keyword">if</span> (result != <span class="hljs-keyword">null</span>) &#123;<br>        <span class="hljs-keyword">return</span> result;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-comment">//去获取一个资源 &quot;META-INF/spring.factories&quot;</span><br>            Enumeration&lt;URL&gt; urls = classLoader != <span class="hljs-keyword">null</span> ? classLoader.getResources(<span class="hljs-string">&quot;META-INF/spring.factories&quot;</span>) : ClassLoader.getSystemResources(<span class="hljs-string">&quot;META-INF/spring.factories&quot;</span>);<br>            LinkedMultiValueMap result = <span class="hljs-keyword">new</span> LinkedMultiValueMap();<br>            <span class="hljs-comment">//判断有没有更多的元素，将读取到的资源循环遍历，封装成为一个Properties</span><br>            <span class="hljs-keyword">while</span>(urls.hasMoreElements()) &#123;<br>                URL url = (URL)urls.nextElement();<br>                UrlResource resource = <span class="hljs-keyword">new</span> UrlResource(url);<br>                Properties properties = PropertiesLoaderUtils.loadProperties(resource);<br>                Iterator var6 = properties.entrySet().iterator();<br>                <span class="hljs-keyword">while</span>(var6.hasNext()) &#123;<br>                    Entry&lt;?, ?&gt; entry = (Entry)var6.next();<br>                    String factoryClassName = ((String)entry.getKey()).trim();<br>                    String[] var9 = StringUtils.commaDelimitedListToStringArray((String)entry.getValue());<br>                    <span class="hljs-keyword">int</span> var10 = var9.length;<br>                    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> var11 = <span class="hljs-number">0</span>; var11 &lt; var10; ++var11) &#123;<br>                        String factoryName = var9[var11];<br>                        result.add(factoryClassName, factoryName.trim());<br>                    &#125;<br>                &#125;<br>            &#125;<br>            cache.put(classLoader, result);<br>            <span class="hljs-keyword">return</span> result;<br>        &#125; <span class="hljs-keyword">catch</span> (IOException var13) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalArgumentException(<span class="hljs-string">&quot;Unable to load factories from location [META-INF/spring.factories]&quot;</span>, var13);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>发现一个多次出现的文件：spring.factories，全局搜索它</p></li></ul></li></ul><blockquote><h4 id="spring-factories"><a href="#spring-factories" class="headerlink" title="spring.factories"></a><strong>spring.factories</strong></h4></blockquote><p>我们根据源头打开spring.factories，看到了很多自动配置的文件；这就是自动配置根源所在。</p><p><img src="/images/Spring%E6%B3%A8%E8%A7%A3%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0.assets/1595415587435.png" alt="1595415587435"></p><p>每一个这样的 xxxAutoConfiguration类都是容器中的一个<strong>组件，都加入到容器中；用他们来做自动配置；</strong></p><blockquote><h4 id="案例说明"><a href="#案例说明" class="headerlink" title="案例说明"></a><strong>案例说明</strong></h4></blockquote><p>我们以<strong>HttpEncodingAutoConfiguration（Http编码自动配置）</strong>为例解释自动配置原理；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//表示这是一个配置类，和以前编写的配置文件一样，也可以给容器中添加组件；</span><br><span class="hljs-meta">@Configuration</span> <br><br><span class="hljs-comment">//启动指定类的ConfigurationProperties功能；</span><br><span class="hljs-comment">//进入这个HttpProperties查看，将配置文件中对应的值和HttpProperties绑定起来；</span><br><span class="hljs-comment">//并把HttpProperties加入到ioc容器中</span><br><span class="hljs-meta">@EnableConfigurationProperties(&#123;HttpProperties.class&#125;)</span> <br><br><span class="hljs-comment">//Spring底层@Conditional注解</span><br>  <span class="hljs-comment">//根据不同的条件判断，如果满足指定的条件，整个配置类里面的配置就会生效；</span><br>  <span class="hljs-comment">//这里的意思就是判断当前应用是否是web应用，如果是，当前配置类生效</span><br><span class="hljs-meta">@ConditionalOnWebApplication(</span><br><span class="hljs-meta">    type = Type.SERVLET</span><br><span class="hljs-meta">)</span><br><br><span class="hljs-comment">//判断当前项目有没有这个类CharacterEncodingFilter；SpringMVC中进行乱码解决的过滤器；</span><br><span class="hljs-meta">@ConditionalOnClass(&#123;CharacterEncodingFilter.class&#125;)</span><br><br><span class="hljs-comment">//判断配置文件中是否存在某个配置：spring.http.encoding.enabled；</span><br><span class="hljs-comment">//如果不存在，判断也是成立的</span><br><span class="hljs-comment">//即使我们配置文件中不配置pring.http.encoding.enabled=true，也是默认生效的；</span><br><span class="hljs-meta">@ConditionalOnProperty(</span><br><span class="hljs-meta">    prefix = &quot;spring.http.encoding&quot;,</span><br><span class="hljs-meta">    value = &#123;&quot;enabled&quot;&#125;,</span><br><span class="hljs-meta">    matchIfMissing = true</span><br><span class="hljs-meta">)</span><br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HttpEncodingAutoConfiguration</span> </span>&#123;<br>    <span class="hljs-comment">//他已经和SpringBoot的配置文件映射了</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Encoding properties;<br>    <span class="hljs-comment">//只有一个有参构造器的情况下，参数的值就会从容器中拿</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">HttpEncodingAutoConfiguration</span><span class="hljs-params">(HttpProperties properties)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.properties = properties.getEncoding();<br>    &#125;<br><br>    <span class="hljs-comment">//给容器中添加一个组件，这个组件的某些值需要从properties中获取</span><br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-meta">@ConditionalOnMissingBean</span> <span class="hljs-comment">//判断容器没有这个组件？</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> CharacterEncodingFilter <span class="hljs-title">characterEncodingFilter</span><span class="hljs-params">()</span> </span>&#123;<br>        CharacterEncodingFilter filter = <span class="hljs-keyword">new</span> OrderedCharacterEncodingFilter();<br>        filter.setEncoding(<span class="hljs-keyword">this</span>.properties.getCharset().name());<br>    filter.setForceRequestEncoding(<span class="hljs-keyword">this</span>.properties.shouldForce(org.springframework.boot.autoconfigure.http.HttpProperties.Encoding.Type.REQUEST));<br>        filter.setForceResponseEncoding(<span class="hljs-keyword">this</span>.properties.shouldForce(org.springframework.boot.autoconfigure.http.HttpProperties.Encoding.Type.RESPONSE));<br>        <span class="hljs-keyword">return</span> filter;<br>    &#125;<br>    <span class="hljs-comment">//。。。。。。。</span><br>&#125;<br></code></pre></td></tr></table></figure><p><strong>一句话总结 ：根据当前不同的条件判断，决定这个配置类是否生效</strong></p><ul><li><p>一但这个配置类生效；这个配置类就会给容器中添加各种组件；</p></li><li><p>这些组件的属性是从对应的properties类中获取的，这些类里面的每一个属性又是和配置文件绑定的；</p></li><li><p>所有在配置文件中能配置的属性都是在xxxxProperties类中封装着；</p></li><li><p>配置文件能配置什么就可以参照某个功能对应的这个属性类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//从配置文件中获取指定的值和bean的属性进行绑定</span><br><span class="hljs-meta">@ConfigurationProperties(prefix = &quot;spring.http&quot;)</span> <br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HttpProperties</span> </span>&#123;<br>    <span class="hljs-comment">// .....</span><br>&#125;<br></code></pre></td></tr></table></figure></li></ul><p>我们去配置文件里面试试前缀，看提示</p><p><img src="/images/Spring%E6%B3%A8%E8%A7%A3%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0.assets/1595493884773.png" alt="1595493884773"></p><p>所以，自动配置真正实现是从classpath中搜寻所有的<code>META-INF/spring.factories</code>配置文件，并将其中对应的 <code>org.springframework.boot.autoconfigure</code>. 包下的配置项，通过反射实例化为对应标注了<code> @Configuration的JavaConfig</code>形式的IOC容器配置类，然后将这些都汇总成为一个实例并加载到IOC容器中。</p><p><strong>结论</strong></p><ol><li>SpringBoot在启动的时候从类路径下的<code>META-INF/spring.factories</code>中获取<code>EnableAutoConfiguration</code>指定的值</li><li>将这些值作为自动配置类导入容器，自动配置类就生效，帮我们进行自动配置工作；</li><li>以前我们需要自动配置的东西，现在springboot帮我们做了</li><li>整合JavaEE，整体解决方案和自动配置的东西都在<code>springboot-autoconfigure</code>的jar包中；</li><li>它会把所有需要导入的组件，以类名的方式返回，这些组件就会被添加到容器中</li><li>它会给容器中导入非常多的自动配置类 （xxxAutoConfiguration）, 就是给容器中导入这个场景需要的所有组件，并自动配置xxxProperties；</li><li>有了自动配置类，免去了我们手动编写配置注入功能组件等的工作；</li><li>springboot配置文件到底能写什么？怎么写？有两种查看方式：<ul><li><a href="https://docs.spring.io/spring-boot/docs/2.3.1.RELEASE/reference/html/appendix-application-properties.html#core-properties">官网配置详解</a></li><li>找到对应的xxxProperties类，查看源码</li></ul></li></ol><h3 id="1-4-main方法"><a href="#1-4-main方法" class="headerlink" title="1.4 main方法"></a>1.4 main方法</h3><p><strong><a href="https://www.bilibili.com/video/BV19K4y1L7MT?p=84">视频教程</a></strong> </p><p>SpringApplication.run方法主要分两部分，一是SpringApplication的实例化，二是run方法的执行。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@SpringBootApplication</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Springboot01HellowordApplication</span> </span>&#123;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>       <span class="hljs-comment">// 该方法返回一个ConfigurableApplicationContext对象</span><br> <span class="hljs-comment">// 参数一：应用入口的类； 参数二：命令行参数  </span><br>        SpringApplication.run(Springboot01HellowordApplication.class, args);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>整体流程：</strong></p><ul><li><p>创建 <strong>SpringApplication</strong></p></li><li><ul><li>保存一些信息。</li><li>判定当前应用的类型。ClassUtils。Servlet</li></ul></li><li><ul><li>==bootstrappers==：<strong>初始启动引导器</strong>（<code>List&lt;Bootstrapper&gt;</code>）：去<strong>spring.factories</strong>文件中找org.springframework.boot.==Bootstrapper==</li><li>找 ==ApplicationContextInitializer==；去<strong>spring.factories</strong> 找 <strong>==ApplicationContextInitializer==</strong></li></ul></li><li><ul><li><ul><li>List&lt;ApplicationContextInitializer&lt;?&gt;&gt; <strong>initializers</strong></li></ul></li></ul></li><li><ul><li><strong>找</strong> ==ApplicationListener== 应用监听器。去<strong>spring.factories</strong> 找 <strong>==ApplicationListener==</strong></li></ul></li><li><ul><li><ul><li>List&lt;ApplicationListener&lt;?&gt;&gt; <strong>listeners</strong></li></ul></li></ul></li><li><p>运行 <strong>SpringApplication</strong></p></li><li><ul><li><strong>StopWatch</strong></li><li><strong>记录应用的启动时间</strong></li></ul></li><li><ul><li><strong>创建引导上下文（Context环境）createBootstrapContext()</strong></li></ul></li><li><ul><li><ul><li>获取到所有之前的 ==bootstrappers==挨个执行 intitialize() 来完成对引导启动器上下文环境设置</li></ul></li></ul></li><li><ul><li>让当前应用进入<strong>headless</strong>模式。<strong>java.awt.headless</strong></li><li><strong>获取所有</strong> ==RunListener==（运行监听器）【为了方便所有Listener进行事件感知】</li></ul></li><li><ul><li><ul><li>getSpringFactoriesInstances 去<strong>spring.factories</strong> 找 ==<strong>SpringApplicationRunListener</strong>==</li></ul></li></ul></li><li><ul><li>遍历 <strong>SpringApplicationRunListener</strong> 调用 starting 方法；</li></ul></li><li><ul><li><ul><li>==相当于通知所有感兴趣系统正在启动过程的人，项目正在 starting。==</li></ul></li></ul></li><li><ul><li>保存命令行参数；ApplicationArguments</li><li>准备环境 prepareEnvironment（）;</li></ul></li><li><ul><li><ul><li>返回或者创建基础环境信息对象。<strong>StandardServletEnvironment</strong></li><li><strong>配置环境信息对象。</strong></li></ul></li></ul></li><li><ul><li><ul><li><ul><li><strong>读取所有的配置源的配置属性值。</strong></li></ul></li></ul></li></ul></li><li><ul><li><ul><li>绑定环境信息</li><li>监听器调用 listener.environmentPrepared()；通知所有的监听器当前环境准备完成</li></ul></li></ul></li><li><ul><li>创建IOC容器（createApplicationContext（））</li></ul></li><li><ul><li><ul><li>根据项目类型（Servlet）创建容器，</li><li>当前会创建 <strong>AnnotationConfigServletWebServerApplicationContext</strong></li></ul></li></ul></li><li><ul><li><strong>准备ApplicationContext IOC容器的基本信息</strong>  <strong>prepareContext()</strong></li></ul></li><li><ul><li><ul><li>保存环境信息</li><li>IOC容器的后置处理流程。</li></ul></li></ul></li><li><ul><li><ul><li>应用初始化器；applyInitializers；</li></ul></li></ul></li><li><ul><li><ul><li><ul><li>遍历所有的 ==ApplicationContextInitializer== 。调用 <strong>initialize.。来对ioc容器进行初始化扩展功能</strong></li><li>遍历所有的 listener 调用 <strong>contextPrepared</strong>。EventPublishRunListenr；通知所有的监听器<strong>contextPrepared</strong></li></ul></li></ul></li></ul></li><li><ul><li><ul><li><strong>所有的监听器 调用</strong> <strong>contextLoaded。通知所有的监听器</strong> <strong>contextLoaded；</strong></li></ul></li></ul></li><li><ul><li><strong>刷新IOC容器。</strong>refreshContext</li></ul></li><li><ul><li><ul><li>创建容器中的所有组件（参见Bean的完整生命周期）</li></ul></li></ul></li><li><ul><li>容器刷新完成后工作？afterRefresh</li><li>所有监听 器 调用 listeners.<strong>started</strong>(context); <strong>通知所有的监听器</strong> <strong>started</strong></li></ul></li><li><ul><li><strong>调用所有runners；</strong>callRunners()</li></ul></li><li><ul><li><ul><li><strong>获取容器中的</strong> <strong>==ApplicationRunner==</strong> </li><li><strong>获取容器中的</strong> <strong>==CommandLineRunner==</strong></li></ul></li></ul></li><li><ul><li><ul><li><strong>合并所有runner并且按照@Order进行排序</strong></li><li><strong>遍历所有的runner。调用 run</strong> <strong>方法</strong></li></ul></li></ul></li><li><ul><li><strong>如果以上有异常，</strong></li></ul></li><li><ul><li><ul><li><strong>调用Listener 的 failed</strong></li></ul></li></ul></li><li><ul><li><strong>调用所有监听器的 running 方法</strong>  listeners.running(context); <strong>通知所有的监听器</strong> <strong>running</strong> </li><li><strong>running如果有问题。继续通知 failed 。调用所有 Listener 的 failed；通知所有的监听器 failed</strong></li></ul></li></ul><p><img src="/images/Spring%E6%B3%A8%E8%A7%A3%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0.assets/image-20201127220232413.png" alt="image-20201127220232413"></p><h2 id="2-Bean对象注入容器"><a href="#2-Bean对象注入容器" class="headerlink" title="2 Bean对象注入容器"></a>2 Bean对象注入容器</h2><p>在SpringBoot中将对象注入到容器中有多种方法。</p><h3 id="2-1-ComponentScan"><a href="#2-1-ComponentScan" class="headerlink" title="2.1 @ComponentScan"></a>2.1 @ComponentScan</h3><p>通过@ComponentScan自动扫包+组件标注注解（@Component/@Controller/@Service/@Repository）实现。</p><p>@ComponentScan可以指定include/exclude某些类，具体的规则通过@Filter参数指定。在Java8中@ComponentScan可以重复标记。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@ComponentScan(value=&quot;com.meimeixia&quot;, includeFilters=&#123;</span><br><span class="hljs-meta">   /* type：指定你要排除的规则，是按照注解进行排除，还是按照给定的类型进行排除，还是按照正则表达式进行排除，等等</span><br><span class="hljs-meta">* classes：我们需要Spring在扫描时，只包含@Controller注解标注的类</span><br><span class="hljs-meta">*/</span><br><span class="hljs-meta">    @Filter(type=FilterType.ANNOTATION, classes=&#123;Controller.class&#125;)</span><br><span class="hljs-meta">&#125;, useDefaultFilters=false)</span> <span class="hljs-comment">// value指定要扫描的包</span><br><span class="hljs-meta">@ComponentScan(value=&quot;com.meimeixia&quot;, includeFilters=&#123;</span><br><span class="hljs-meta">   /* type：指定你要排除的规则，是按照注解进行排除，还是按照给定的类型进行排除，还是按照正则表达式进行排除，等等</span><br><span class="hljs-meta">* classes：我们需要Spring在扫描时，只包含@Service注解标注的类</span><br><span class="hljs-meta">*/</span><br><span class="hljs-meta">    @Filter(type=FilterType.ANNOTATION, classes=&#123;Service.class&#125;)</span><br><span class="hljs-meta">&#125;, useDefaultFilters=false)</span> <span class="hljs-comment">// value指定要扫描的包</span><br></code></pre></td></tr></table></figure><p>如果不是Java8，但又需要设置多个条件，可以使用如下方式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@ComponentScans(value=&#123;</span><br><span class="hljs-meta">    @ComponentScan(value=&quot;com.meimeixia&quot;, includeFilters=&#123;</span><br><span class="hljs-meta">       /* type：指定你要排除的规则，是按照注解进行排除，还是按照给定的类型进行排除，还是按照正则表达式进行排除，等等</span><br><span class="hljs-meta">* classes：我们需要Spring在扫描时，只包含@Controller注解标注的类</span><br><span class="hljs-meta">*/</span><br><span class="hljs-meta">        @Filter(type=FilterType.ANNOTATION, classes=&#123;Controller.class&#125;)</span><br><span class="hljs-meta">    &#125;, useDefaultFilters=false), // value指定要扫描的包</span><br><span class="hljs-meta">    @ComponentScan(value=&quot;com.meimeixia&quot;, includeFilters=&#123;</span><br><span class="hljs-meta">       /* type：指定你要排除的规则，是按照注解进行排除，还是按照给定的类型进行排除，还是按照正则表达式进行排除，等等</span><br><span class="hljs-meta">* classes：我们需要Spring在扫描时，只包含@Service注解标注的类</span><br><span class="hljs-meta">*/</span><br><span class="hljs-meta">        @Filter(type=FilterType.ANNOTATION, classes=&#123;Service.class&#125;)</span><br><span class="hljs-meta">    &#125;, useDefaultFilters=false) // value指定要扫描的包</span><br><span class="hljs-meta">&#125;)</span><br></code></pre></td></tr></table></figure><p>这种注入方式只适用于自己写的类，对于自己写的类，可以在类上面加上组件标注注解，但是对于引用的别人的类，该方法就无法使用。</p><p><strong>@Filter使用进阶</strong></p><p>Filter支持以下5种类型：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">FilterType</span> </span>&#123;<br>    <span class="hljs-comment">// 被标记注解的类型、类的class类型、ASPECTJ表达式、正则表达式、自定义类型</span><br>    ANNOTATION, ASSIGNABLE_TYPE, ASPECTJ, REGEX, CUSTOM;<br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">FilterType</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-comment">/* compiled code */</span> &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>前两种类型很好理解，重点讲CUSTOM类型的用法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@ComponentScan(value=&quot;com.meimeixia&quot;, includeFilters=&#123;</span><br><span class="hljs-meta">   /*</span><br><span class="hljs-meta">* type：指定你要排除的规则，是按照注解进行排除，还是按照给定的类型进行排除，还是按照正则表达式进行排除，等等</span><br><span class="hljs-meta">*/</span><br><span class="hljs-meta">   // 指定新的过滤规则，这个过滤规则是我们自个自定义的，过滤规则就是由我们这个自定义的MyTypeFilter类返回true或者false来代表匹配还是没匹配</span><br><span class="hljs-meta">@Filter(type=FilterType.CUSTOM, classes=&#123;MyTypeFilter.class&#125;)</span><br><span class="hljs-meta">&#125;, useDefaultFilters=false)</span>  <span class="hljs-comment">// value指定要扫描的包</span><br></code></pre></td></tr></table></figure><p>自定义过滤规则类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyTypeFilter</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">TypeFilter</span> </span>&#123;<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 参数：</span><br><span class="hljs-comment"> * metadataReader：读取到的当前正在扫描的类的信息</span><br><span class="hljs-comment"> * metadataReaderFactory：可以获取到其他任何类的信息的（工厂）</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">match</span><span class="hljs-params">(MetadataReader metadataReader, MetadataReaderFactory metadataReaderFactory)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br><span class="hljs-comment">// 获取当前类注解的信息</span><br>AnnotationMetadata annotationMetadata = metadataReader.getAnnotationMetadata();<br><span class="hljs-comment">// 获取当前正在扫描的类的类信息，比如说它的类型是什么啊，它实现了什么接口啊之类的</span><br>ClassMetadata classMetadata = metadataReader.getClassMetadata();<br><span class="hljs-comment">// 获取当前类的资源信息，比如说类的路径等信息</span><br>Resource resource = metadataReader.getResource();<br><span class="hljs-comment">// 获取当前正在扫描的类的类名</span><br>String className = classMetadata.getClassName();<br>System.out.println(<span class="hljs-string">&quot;---&gt;&quot;</span> + className);<br><span class="hljs-comment">// 现在来指定一个规则</span><br><span class="hljs-keyword">if</span> (className.contains(<span class="hljs-string">&quot;er&quot;</span>)) &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>; <span class="hljs-comment">// 只要类名包含“er”，就会被包含在容器中（无需被@Component标注）</span><br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2-2-Bean"><a href="#2-2-Bean" class="headerlink" title="2.2 @Bean"></a>2.2 @Bean</h3><p>使用@Configuration和@Bean注解，手动构建对象，并把它注入到容器中去。被@Configuration标记的配置类相当于Spring中的<code>bean.xml</code>文件，@Bean则相当于<code>&lt;bean&gt;</code>标签。</p><p>使用这种方式，被@Configuration标记的配置类也会被注入到容器中去。</p><ul><li>用@Bean给容器中添加组件，<strong>方法名</strong>就是组件的id，返回类型就是组件类型，返回值就是组件在容器中的实例。</li><li>被@Configuration标记的配置类的id就是该配置类的类名（首字母自动转为小写，不是全类名）。</li></ul><p>以下是@Configuration的使用案例，<code>proxyBeanMethods</code>属性用来设置Full模式与Lite模式</p><ul><li>配置类组件之间无依赖关系用Lite模式加速容器启动过程，减少判断</li><li>配置类组件之间有依赖关系，方法会被调用得到之前单实例组件，用Full模式</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// ####################Configuration使用示例######################</span><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 1、配置类里面使用<span class="hljs-doctag">@Bean</span>标注在方法上给容器注册组件，默认也是单实例的</span><br><span class="hljs-comment"> * 2、配置类本身也是组件</span><br><span class="hljs-comment"> * 3、proxyBeanMethods：代理bean的方法</span><br><span class="hljs-comment"> *      Full(proxyBeanMethods = true)、【保证每个<span class="hljs-doctag">@Bean</span>方法被调用多少次返回的组件都是单实例的】</span><br><span class="hljs-comment"> *      Lite(proxyBeanMethods = false)【每个<span class="hljs-doctag">@Bean</span>方法被调用多少次返回的组件都是新创建的】</span><br><span class="hljs-comment"> *      组件依赖必须使用Full模式默认。其他默认是Lite模式</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@Configuration(proxyBeanMethods = false)</span> <span class="hljs-comment">//告诉SpringBoot这是一个配置类 == 配置文件</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyConfig</span> </span>&#123;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * Full:外部无论对配置类中的这个组件注册方法调用多少次获取的都是之前注册容器中的单实例对象</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Bean</span> <span class="hljs-comment">//给容器中添加组件。以方法名作为组件的id。返回类型就是组件类型。返回的值，就是组件在容器中的实例</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> User <span class="hljs-title">user01</span><span class="hljs-params">()</span></span>&#123;<br>        User zhangsan = <span class="hljs-keyword">new</span> User(<span class="hljs-string">&quot;zhangsan&quot;</span>, <span class="hljs-number">18</span>);<br>        <span class="hljs-comment">//user组件依赖了Pet组件</span><br>        zhangsan.setPet(tomcatPet());<br>        <span class="hljs-keyword">return</span> zhangsan;<br>    &#125;<br><br>    <span class="hljs-meta">@Bean(&quot;tom&quot;)</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Pet <span class="hljs-title">tomcatPet</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Pet(<span class="hljs-string">&quot;tomcat&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// ##################@Configuration测试代码如下#####################</span><br><span class="hljs-meta">@SpringBootConfiguration</span><br><span class="hljs-meta">@EnableAutoConfiguration</span><br><span class="hljs-meta">@ComponentScan(&quot;com.atguigu.boot&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MainApplication</span> </span>&#123;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        <span class="hljs-comment">//1、返回我们IOC容器</span><br>        ConfigurableApplicationContext run = SpringApplication.run(MainApplication.class, args);<br><br>        <span class="hljs-comment">//2、查看容器里面的组件</span><br>        String[] names = run.getBeanDefinitionNames();<br>        <span class="hljs-keyword">for</span> (String name : names) &#123;<br>            System.out.println(name);<br>        &#125;<br><br>        <span class="hljs-comment">//3、从容器中获取组件</span><br>        Pet tom01 = run.getBean(<span class="hljs-string">&quot;tom&quot;</span>, Pet.class);<br>        Pet tom02 = run.getBean(<span class="hljs-string">&quot;tom&quot;</span>, Pet.class);<br>        System.out.println(<span class="hljs-string">&quot;组件：&quot;</span>+(tom01 == tom02));  <span class="hljs-comment">// true</span><br><br>        <span class="hljs-comment">//4、com.atguigu.boot.config.MyConfig$$EnhancerBySpringCGLIB$$51f1e1ca@1654a892</span><br>        MyConfig bean = run.getBean(MyConfig.class);<br>        System.out.println(bean);<br><br>        <span class="hljs-comment">//如果@Configuration(proxyBeanMethods = true)代理对象调用方法。SpringBoot总会检查这个组件是否在容器中有。</span><br>        <span class="hljs-comment">//保持组件单实例</span><br>        User user = bean.user01();<br>        User user1 = bean.user01();<br>        System.out.println(user == user1);<br><br>        User user01 = run.getBean(<span class="hljs-string">&quot;user01&quot;</span>, User.class);<br>        Pet tom = run.getBean(<span class="hljs-string">&quot;tom&quot;</span>, Pet.class);<br><br>        System.out.println(<span class="hljs-string">&quot;用户的宠物：&quot;</span>+(user01.getPet() == tom)); <span class="hljs-comment">// true/false与proxyBeanMethods有关</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>@Scope</strong></p><p>默认@Bean使用的是Singleton单例模式，每次获取的都是同一个对象，并且是饿汉式加载，可以使用@Scope修改为Prototype，每次获取对象均不同，该模式下会启用懒汉式加载。</p><p><strong>@Lazy</strong></p><p>使用该注解会将单例模式的Bean修改为懒加载模式。</p><h3 id="2-3-Import"><a href="#2-3-Import" class="headerlink" title="2.3 @Import"></a>2.3 @Import</h3><p><strong>简单Import</strong></p><p>也可以使用@Import注解注入bean到容器中去.</p><p>@Import注解接收一个Class[]，被注入bean的id默认是导入类的<code>全类名</code>，bean默认使用无参构造做初始化。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * @Import(&#123;User.class, DBHelper.class&#125;)</span><br><span class="hljs-comment"> * 给容器中自动创建出这两个类型的组件、默认组件的名字就是全类名</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@Import(&#123;User.class, DBHelper.class&#125;)</span><br><span class="hljs-meta">@Configuration(proxyBeanMethods = false)</span> <span class="hljs-comment">//告诉SpringBoot这是一个配置类 == 配置文件</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyConfig</span> </span>&#123;<br>    <br>&#125;<br></code></pre></td></tr></table></figure><p><strong>ImportSelector</strong></p><p>可以自己创建一个类，并且实现 <code>ImportSelector</code> 接口，重写 <code>ImportSelector</code> 的 <code>selectImports</code> 方法，<code>selectImports</code> 方法返回的是需要被注入类的全类名，然后把这个自己创建的类加入@Import的数组中。</p><p>被注入bean的名字默认是导入类的<code>全类名</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Import(TestImportSelector.class)</span>  <span class="hljs-comment">// 通过@ImportSelector注入</span><br><span class="hljs-meta">@Configuration</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TestConfiguration</span> </span>&#123;<br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">StrBean</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;this is a string&quot;</span>;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TestImportSelector</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">ImportSelector</span> </span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> String[] selectImports(AnnotationMetadata annotationMetadata) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> String[]&#123;<span class="hljs-string">&quot;qizi.Main&quot;</span>&#125;;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Predicate&lt;String&gt; <span class="hljs-title">getExclusionFilter</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>ImportBeanDefinitionRegistrar</strong></p><p>自己创建一个类，继承<code>ImportBeanDefinitionRegistrar</code>并重写方法，手动注册beanDefinition，可以自定义bean的id名。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 使用ImportBeanDefinitionRegistrar注入</span><br><span class="hljs-meta">@Import(&#123;TestImportSelector.class, TestImportBeanDefinitionRegistrar.class&#125;)</span><br><span class="hljs-meta">@Configuration</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TestConfiguration</span> </span>&#123;<br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">StrBean</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;this is a string&quot;</span>;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TestImportBeanDefinitionRegistrar</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">ImportBeanDefinitionRegistrar</span> </span>&#123;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> importingClassMetadata 当前类的注解</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> registry beandefinition注册类</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">registerBeanDefinitions</span><span class="hljs-params">(AnnotationMetadata importingClassMetadata, BeanDefinitionRegistry registry)</span> </span>&#123;<br>        registry.registerBeanDefinition(<span class="hljs-string">&quot;diy_hashmap_id&quot;</span>, <span class="hljs-keyword">new</span> RootBeanDefinition(HashMap.class));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2-4-Conditional"><a href="#2-4-Conditional" class="headerlink" title="2.4 @Conditional"></a>2.4 @Conditional</h3><p>有一个专门的注解叫@Conditional，需要和@Configuration等注解配合使用。可以根据自己指定的类来决定是否加载被标记类到IOC容器，必须是@Conditional指定的条件成立，才给容器中添加组件，配置配里面的所有内容才生效。</p><p>也有一些已经封装好的条件装配注解：当满足ConditionalOn指定的条件时，才进行组件注入。</p><table><thead><tr><th>@ConditionalOn扩展注解</th><th>作用(判断是否满足当前指定条件)</th></tr></thead><tbody><tr><td>@ConditionalOnJava</td><td>系统的java版本是否符合要求</td></tr><tr><td>@ConditionalOnJava</td><td>容器中存在指定Bean</td></tr><tr><td>@ConditionalOnMissingBean</td><td>容器中不存在指定Bean</td></tr><tr><td>@ConditionalOnExpression</td><td>满足SpEL表达式指定</td></tr><tr><td>@ConditionalOnClass</td><td>系统中有指定的类</td></tr><tr><td>@ConditionalOnMissingClass</td><td>系统中没有指定的类</td></tr><tr><td>@ConditionalOnSingleCandidate</td><td>容器中只有一个指定的Bean，或者这个Bean是首选Bean</td></tr><tr><td>@ConditionalOnProperty</td><td>系统中指定的属性是否有指定的值</td></tr><tr><td>@ConditionalOnResource</td><td>类路径下是否存在指定资源文件</td></tr><tr><td>@ConditionalOnWebApplication</td><td>当前是web环境</td></tr><tr><td>@ConditionalOnNotWebApplication</td><td>当前不是web环境</td></tr><tr><td>@ConditionalOnJndi</td><td>JNDI存在指定项</td></tr></tbody></table><p><strong>那么多的自动配置类，必须在一定的条件下才能生效；也就是说，我们加载了这么多的配置类，但不是所有的都生效了。</strong></p><blockquote><p><strong>自动配置类是否生效</strong></p></blockquote><p>我们可以在application.properties通过启用 <code>debug=true</code>属性；在控制台打印自动配置报告，这样我们就可以很方便的知道哪些自动配置类生效；</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-comment"># 开启springboot的调试类</span><br><span class="hljs-attr">debug</span>=<span class="hljs-string">true</span><br></code></pre></td></tr></table></figure><ul><li>Positive matches:（自动配置类启用的：正匹配）</li><li>Negative matches:（没有启动，没有匹配成功的自动配置类：负匹配）</li><li>Unconditional classes: （没有条件的类）</li><li>【演示：查看输出的日志】</li></ul><h3 id="2-5-ImportResource"><a href="#2-5-ImportResource" class="headerlink" title="2.5 @ImportResource"></a>2.5 @ImportResource</h3><p>考虑到部分存量代码是用Spring时代的xml方法配置的，为了兼容历史代码，可以使用@ImportResource注解指定bean.xml配置的路径，加载xml配置中的bean。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@ImportResource(&quot;classpath:beans.xml&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyConfig</span> </span>&#123;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2-6-FactoryBean"><a href="#2-6-FactoryBean" class="headerlink" title="2.6 FactoryBean"></a>2.6 FactoryBean</h3><p>一般情况下，Spring是通过反射机制利用bean的class属性指定实现类来实例化bean的。在某些情况下，实例化bean过程比较复杂，如果按照传统的方式，那么则需要在标签中提供大量的配置信息，配置方式的灵活性是受限的，这时采用编码的方式可以得到一个更加简单的方案。Spring为此提供了一个org.springframework.bean.factory.FactoryBean的工厂类接口，用户可以通过实现该接口定制实例化bean的逻辑。</p><p>FactoryBean接口对于Spring框架来说占有非常重要的地位，Spring自身就提供了70多个FactoryBean接口的实现。它们隐藏了实例化一些复杂bean的细节，给上层应用带来了便利。从Spring 3.0开始，FactoryBean开始支持泛型，即接口声明改为<code>FactoryBean&lt;T&gt;</code>的形式。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">FactoryBean</span> &lt;<span class="hljs-title">T</span>&gt; </span>&#123;<br>    String OBJECT_TYPE_ATTRIBUTE = <span class="hljs-string">&quot;factoryBeanObjectType&quot;</span>;<br><br>    <span class="hljs-meta">@Nullable</span><br>    <span class="hljs-function">T <span class="hljs-title">getObject</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception</span>;  <span class="hljs-comment">// 返回由FactoryBean创建的bean实例</span><br><br>    <span class="hljs-meta">@Nullable</span><br>    java.lang.Class&lt;?&gt; getObjectType();  <span class="hljs-comment">// 返回bean实例对象的类型</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">default</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isSingleton</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-comment">/* compiled code */</span> &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>需要注意的是：当配置文件中标签的class属性配置的实现类是FactoryBean时，通过 getBean()方法返回的不是FactoryBean本身，而是FactoryBean#getObject()方法所返回的对象，相当于FactoryBean#getObject()代理了getBean()方法。如果确实需要获取FactoryBean，使用时需要在context#getBean的beanid前面加上一个<code>&amp;</code>符号。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ColorFactoryBean</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">FactoryBean</span>&lt;<span class="hljs-title">Color</span>&gt; </span>&#123;<br><br><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> Color <span class="hljs-title">getObject</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;  <span class="hljs-comment">// 返回一个Color对象到容器中</span><br>System.out.println(<span class="hljs-string">&quot;ColorFactoryBean...getObject...&quot;</span>);<br><span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Color();<br>&#125;<br><br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> Class&lt;?&gt; getObjectType() &#123;  <span class="hljs-comment">// 返回这个对象的类型</span><br><span class="hljs-keyword">return</span> Color.class;<br>&#125;<br><br><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isSingleton</span><span class="hljs-params">()</span> </span>&#123;  <span class="hljs-comment">// 是否为单例</span><br><span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>&#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MainConfig</span></span>&#123;<br>    <span class="hljs-meta">@Bean</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> ColorFactoryBean <span class="hljs-title">colorFactoryBean</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> ColorFactoryBean();<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>测试</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testImport</span><span class="hljs-params">()</span> </span>&#123;<br>    AnnotationConfigApplicationContext applicationContext = <span class="hljs-keyword">new</span> AnnotationConfigApplicationContext(MainConfig2.class);<br>    String[] definitionNames = applicationContext.getBeanDefinitionNames();<br>    <span class="hljs-keyword">for</span> (String name : definitionNames) &#123;<br>        System.out.println(name);  <span class="hljs-comment">// 会看到有一个definitionName叫colorFactoryBean</span><br>    &#125;<br>    <br>    <span class="hljs-comment">// 工厂bean获取的是调用getObject方法创建的对象</span><br>    Object bean2 = applicationContext.getBean(<span class="hljs-string">&quot;colorFactoryBean&quot;</span>);<br>    System.out.println(<span class="hljs-string">&quot;bean的类型：&quot;</span> + bean2.getClass());  <span class="hljs-comment">// 实际上这个colorFactoryBean是Color.class类型</span><br><br>    <span class="hljs-comment">// 获取FactoryBean对象本省</span><br>    Object bean4 = applicationContext.getBean(<span class="hljs-string">&quot;&amp;colorFactoryBean&quot;</span>);<br>    System.out.println(bean4.getClass());  <span class="hljs-comment">// FactoryBean.class</span><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="3-Bean常用拓展点"><a href="#3-Bean常用拓展点" class="headerlink" title="3 Bean常用拓展点"></a>3 Bean常用拓展点</h2><h3 id="3-1-初始化和销毁"><a href="#3-1-初始化和销毁" class="headerlink" title="3.1 初始化和销毁"></a>3.1 初始化和销毁</h3><p>如果是使用XML配置文件的方式配置bean的话，那么可以在标签中指定bean的初始化和销毁方法，如下所示。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;person&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.meimeixia.bean.Person&quot;</span> <span class="hljs-attr">init-method</span>=<span class="hljs-string">&quot;init&quot;</span> <span class="hljs-attr">destroy-method</span>=<span class="hljs-string">&quot;destroy&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;age&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;18&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;name&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;liayun&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br></code></pre></td></tr></table></figure><p>这里，需要注意的是，在我们自己写的Person类中，需要存在init()方法和destroy()方法。而且Spring中还规定，这里的init()方法和destroy()方法必须是<strong>无参方法</strong>，但可以抛出异常。</p><p><strong>@Bean注解指定</strong></p><p>可以通过@Bean注解的两个参数指定初始化和销毁方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MainConfigOfLifeCycle</span> </span>&#123;<br><span class="hljs-meta">@Bean(initMethod=&quot;init&quot;, destroyMethod=&quot;destroy&quot;)</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> Car <span class="hljs-title">car</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Car();  <span class="hljs-comment">// Car类中需要提供名叫init和destory的两个方法</span><br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>初始化方法和销毁方法的调用时机？</p><ul><li>初始化方法调用的时机：对象创建完成，如果对象中存在一些属性，并且这些属性也都赋好值之后，那么就会调用bean的初始化方法。对于单实例bean来说，在Spring容器创建完成后，Spring容器会自动调用bean的初始化方法；对于多实例bean来说，在每次获取bean对象的时候，调用bean的初始化方法。</li><li>销毁方法调用的时机：对于单实例bean来说，在容器关闭的时候，会调用bean的销毁方法；对于多实例bean来说，Spring容器不会管理这个bean，也就不会自动调用这个bean的销毁方法了。不过，用户可以手动调用多实例bean的销毁方法。</li></ul><p><strong>实现InitializingBean和DisposableBean接口</strong></p><p>如果不使用@Bean指定初始化和销毁方法，也可以实现InitializingBean、DisposableBean这两个接口，这样也能实现指定初始化和销毁方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Cat</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">InitializingBean</span>, <span class="hljs-title">DisposableBean</span> </span>&#123;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Cat</span><span class="hljs-params">()</span> </span>&#123;<br>System.out.println(<span class="hljs-string">&quot;cat constructor...&quot;</span>);<br>&#125;<br>    <br>    <span class="hljs-meta">@Override</span>  <span class="hljs-comment">// 会在bean创建完成，并且属性都赋好值以后进行调用</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">afterPropertiesSet</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>System.out.println(<span class="hljs-string">&quot;cat afterPropertiesSet...&quot;</span>);<br>&#125;<br><br><span class="hljs-meta">@Override</span>  <span class="hljs-comment">// 会在容器关闭的时候进行调用</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">destroy</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>System.out.println(<span class="hljs-string">&quot;cat destroy...&quot;</span>);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>@PostConstruct和@PreDestroy注解</strong></p><p>@PostConstruct和@PreDestroy是Java依据JSR-250规范定义的两个注解。</p><ul><li>Constructor（构造方法）→@Autowired（依赖注入）→@PostConstruct（注释的方法）</li><li>调用destroy()方法→@PreDestroy→destroy()方法→bean销毁</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Dog</span> </span>&#123;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Dog</span><span class="hljs-params">()</span> </span>&#123;<br>System.out.println(<span class="hljs-string">&quot;dog constructor...&quot;</span>);<br>&#125;<br><br><span class="hljs-meta">@PostConstruct</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">init</span><span class="hljs-params">()</span> </span>&#123;  <span class="hljs-comment">// 在对象创建完成并且属性赋值完成之后调用</span><br>System.out.println(<span class="hljs-string">&quot;dog...@PostConstruct...&quot;</span>);<br>&#125;<br><br><span class="hljs-meta">@PreDestroy</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">destory</span><span class="hljs-params">()</span> </span>&#123;  <span class="hljs-comment">// 在容器销毁（移除）对象之前调用</span><br>System.out.println(<span class="hljs-string">&quot;dog...@PreDestroy...&quot;</span>);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="3-2-BeanPostProcessor"><a href="#3-2-BeanPostProcessor" class="headerlink" title="3.2 BeanPostProcessor"></a>3.2 BeanPostProcessor</h3><p>BeanPostProcessor后置处理器。<strong>Spring容器中的每一个bean对象初始化前后，都会执行BeanPostProcessor接口的实现类中的这两个方法</strong>。</p><p>postProcessBeforeInitialization方法会在bean实例化和==属性设置之后，自定义初始化方法之前==被调用，而postProcessAfterInitialization方法会在自定义==初始化方法执行之后==被调用。当容器中存在多个BeanPostProcessor的实现类时，会按照它们在容器中注册的顺序执行。对于自定义的BeanPostProcessor实现类，还可以让其实现Ordered接口自定义排序。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Component</span> <span class="hljs-comment">// 将后置处理器加入到容器中，这样Spring就能让它工作了</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyBeanPostProcessor</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">BeanPostProcessor</span> </span>&#123;<br><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">postProcessBeforeInitialization</span><span class="hljs-params">(Object bean, String beanName)</span> <span class="hljs-keyword">throws</span> BeansException </span>&#123;<br>System.out.println(<span class="hljs-string">&quot;postProcessBeforeInitialization...&quot;</span> + beanName + <span class="hljs-string">&quot;=&gt;&quot;</span> + bean);<br><span class="hljs-keyword">return</span> bean;<br>&#125;<br><br><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">postProcessAfterInitialization</span><span class="hljs-params">(Object bean, String beanName)</span> <span class="hljs-keyword">throws</span> BeansException </span>&#123;<br>System.out.println(<span class="hljs-string">&quot;postProcessAfterInitialization...&quot;</span> + beanName + <span class="hljs-string">&quot;=&gt;&quot;</span> + bean);<br><span class="hljs-keyword">return</span> bean;<br>&#125;<br>    <br>    <span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getOrder</span><span class="hljs-params">()</span> </span>&#123;  <span class="hljs-comment">// 自定义后置处理器排序</span><br><span class="hljs-keyword">return</span> <span class="hljs-number">3</span>;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="3-3-XxxAware接口"><a href="#3-3-XxxAware接口" class="headerlink" title="3.3 XxxAware接口"></a>3.3 XxxAware接口</h3><p>XxxAware使用案例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 以Red类为例来讲解ApplicationContextAware接口、BeanNameAware接口以及EmbeddedValueResolverAware接口</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Red</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">ApplicationContextAware</span>, <span class="hljs-title">BeanNameAware</span>, <span class="hljs-title">EmbeddedValueResolverAware</span> </span>&#123;<br><br><span class="hljs-keyword">private</span> ApplicationContext applicationContext;<br><br><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setApplicationContext</span><span class="hljs-params">(ApplicationContext applicationContext)</span> <span class="hljs-keyword">throws</span> BeansException </span>&#123;<br>System.out.println(<span class="hljs-string">&quot;传入的IOC：&quot;</span> + applicationContext);<br><span class="hljs-keyword">this</span>.applicationContext = applicationContext;<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 参数name：IOC容器创建当前对象时，为这个对象起的名字</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setBeanName</span><span class="hljs-params">(String name)</span> </span>&#123;<br>System.out.println(<span class="hljs-string">&quot;当前bean的名字：&quot;</span> + name);<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 参数resolver：IOC容器启动时会自动地将这个String值的解析器传递过来给我们</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setEmbeddedValueResolver</span><span class="hljs-params">(StringValueResolver resolver)</span> </span>&#123;<br>String resolveStringValue = resolver.resolveStringValue(<span class="hljs-string">&quot;你好，$&#123;os.name&#125;，我的年龄是#&#123;20*18&#125;&quot;</span>);<br>System.out.println(<span class="hljs-string">&quot;解析的字符串：&quot;</span> + resolveStringValue);<br>&#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>XxxAware接口的底层原理是由XxxAwareProcessor实现类实现的，每一个XxxAware接口都有它自己对应的XxxAwareProcessor实现类。 例如，以ApplicationContextAware接口为例，ApplicationContextAware接口的底层原理就是由ApplicationContextAwareProcessor类实现的。从ApplicationContextAwareProcessor类的源码可以看出，其实现了BeanPostProcessor接口，本质上是一个后置处理器。</p><h3 id="3-4-AOP使用及原理"><a href="#3-4-AOP使用及原理" class="headerlink" title="3.4 AOP使用及原理"></a>3.4 AOP使用及原理</h3><p><strong>引入AOP依赖</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-aspects<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>4.3.12.RELEASE<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><p><strong>定义目标类</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MathCalculator</span> </span>&#123;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">div</span><span class="hljs-params">(<span class="hljs-keyword">int</span> i, <span class="hljs-keyword">int</span> j)</span> </span>&#123;<br>System.out.println(<span class="hljs-string">&quot;MathCalculator...div...&quot;</span>);<br><span class="hljs-keyword">return</span> i / j;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>定义切面类</strong></p><p>AOP中的通知方法及其对应的注解与含义如下：</p><ul><li>前置通知（对应的注解是@Before）：在目标方法运行之前运行</li><li>后置通知（对应的注解是@After）：在目标方法运行结束之后运行，无论目标方法是正常结束还是异常结束都会执行</li><li>返回通知（对应的注解是@AfterReturning）：在目标方法正常返回之后运行</li><li>异常通知（对应的注解是@AfterThrowing）：在目标方法运行出现异常之后运行</li><li>环绕通知（对应的注解是@Around）：动态代理，我们可以直接手动推进目标方法运行</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Aspect</span>  <span class="hljs-comment">// 告诉Spring当前类是一个切面类</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LogAspects</span> </span>&#123;<br>    <br>    <span class="hljs-comment">// 如果切入点表达式都一样的情况下，那么我们可以抽取出一个公共的切入点表达式</span><br><span class="hljs-meta">@Pointcut(&quot;execution(public int com.meimeixia.aop.MathCalculator.*(..))&quot;)</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">pointCut</span><span class="hljs-params">()</span> </span>&#123;&#125;<br><br><span class="hljs-comment">// @Before：在目标方法（即div方法）运行之前切入，public int com.meimeixia.aop.MathCalculator.div(int, int)这一串就是切入点表达式，指定在哪个方法切入</span><br><span class="hljs-comment">// @Before(&quot;public int com.meimeixia.aop.MathCalculator.*(..)&quot;)</span><br>    <span class="hljs-meta">@Before(&quot;pointCut()&quot;)</span>  <span class="hljs-comment">// 抽取公用的切点</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">logStart</span><span class="hljs-params">(JoinPoint joinPoint)</span> </span>&#123;<br>Object[] args = joinPoint.getArgs(); <span class="hljs-comment">// 拿到参数列表，即目标方法运行需要的参数列表</span><br>System.out.println(joinPoint.getSignature().getName() + <span class="hljs-string">&quot;运行......@Before，参数列表是：&#123;&quot;</span> + Arrays.asList(args) + <span class="hljs-string">&quot;&#125;&quot;</span>);<br>&#125;<br><br><span class="hljs-comment">// 在目标方法（即div方法）结束时被调用</span><br><span class="hljs-comment">// @After(&quot;public int com.meimeixia.aop.MathCalculator.*(..)&quot;)</span><br>    <span class="hljs-meta">@After(&quot;pointCut()&quot;)</span>  <span class="hljs-comment">// 抽取公用的切点</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">logEnd</span><span class="hljs-params">(JoinPoint joinPoint)</span> </span>&#123;<br><span class="hljs-comment">// System.out.println(&quot;除法结束......@After&quot;);</span><br>System.out.println(joinPoint.getSignature().getName() + <span class="hljs-string">&quot;结束......@After&quot;</span>);<br>&#125;<br><br><span class="hljs-comment">// 在目标方法（即div方法）正常返回了，有返回值，被调用</span><br><span class="hljs-comment">// @AfterReturning(&quot;public int com.meimeixia.aop.MathCalculator.*(..)&quot;)</span><br>    <span class="hljs-meta">@AfterReturning(&quot;pointCut()&quot;)</span>  <span class="hljs-comment">// 抽取公用的切点</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">logReturn</span><span class="hljs-params">(JoinPoint joinPoint, Object result)</span> </span>&#123; <span class="hljs-comment">// 一定要注意：JoinPoint这个参数要写，一定不能写到后面，它必须出现在参数列表的第一位，否则Spring也是无法识别的，就会报错</span><br>System.out.println(joinPoint.getSignature().getName() + <span class="hljs-string">&quot;正常返回......@AfterReturning，运行结果是：&#123;&quot;</span> + result + <span class="hljs-string">&quot;&#125;&quot;</span>);<br>&#125;<br><br><span class="hljs-comment">// 在目标方法（即div方法）出现异常，被调用</span><br><span class="hljs-comment">// @AfterThrowing(&quot;public int com.meimeixia.aop.MathCalculator.*(..)&quot;)</span><br>    <span class="hljs-meta">@AfterThrowing(&quot;pointCut()&quot;)</span>  <span class="hljs-comment">// 抽取公用的切点</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">logException</span><span class="hljs-params">()</span> </span>&#123;<br>System.out.println(<span class="hljs-string">&quot;除法出现异常......异常信息：&#123;&#125;&quot;</span>);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>开启基于注解的AOP模式</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@EnableAspectJAutoProxy</span><br><span class="hljs-meta">@Configuration</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MainConfigOfAOP</span> </span>&#123;<br><br><span class="hljs-comment">// 将业务逻辑类（目标方法所在类）加入到容器中</span><br><span class="hljs-meta">@Bean</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> MathCalculator <span class="hljs-title">calculator</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> MathCalculator();<br>&#125;<br><br><span class="hljs-comment">// 将切面类加入到容器中</span><br><span class="hljs-meta">@Bean</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> LogAspects <span class="hljs-title">logAspects</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> LogAspects();<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>AOP底层原理</strong></p><p>最后，我们还需要对AOP原理做一个简单的总结，完美结束对其研究的旅程。</p><ol><li><p>利用@EnableAspectJAutoProxy注解来开启AOP功能</p></li><li><p>这个AOP功能是怎么开启的呢？主要是通过@EnableAspectJAutoProxy注解向IOC容器中注册一个AnnotationAwareAspectJAutoProxyCreator组件来做到这点的</p></li><li><p>AnnotationAwareAspectJAutoProxyCreator组件是一个后置处理器</p></li><li><p>该后置处理器是怎么工作的呢？在IOC容器创建的过程中，我们就能清楚地看到这个后置处理器是如何创建以及注册的，以及它的工作流程。</p><ol><li><p>首先，在创建IOC容器的过程中，会调用refresh()方法来刷新容器，而在刷新容器的过程中有一步是来注册后置处理器的，如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">registerBeanPostProcessors(beanFactory); <span class="hljs-comment">// 注册后置处理器，在这一步会创建AnnotationAwareAspectJAutoProxyCreator对象</span><br></code></pre></td></tr></table></figure><p>其实，这一步会为所有后置处理器都创建对象。</p></li><li><p>在刷新容器的过程中还有一步是来完成BeanFactory的初始化工作的，如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">finishBeanFactoryInitialization(beanFactory); <span class="hljs-comment">// 完成BeanFactory的初始化工作。所谓的完成BeanFactory的初始化工作，其实就是来创建剩下的单实例bean的。</span><br></code></pre></td></tr></table></figure><p>很显然，剩下的单实例bean自然就包括MathCalculator（业务逻辑类）和LogAspects（切面类）这两个bean，因此这两个bean就是在这儿被创建的。</p><ol><li>创建业务逻辑组件和切面组件</li><li>在这两个组件创建的过程中，最核心的一点就是AnnotationAwareAspectJAutoProxyCreator（后置处理器）会来拦截这俩组件的创建过程</li><li>怎么拦截呢？主要就是在组件创建完成之后，判断组件是否需要增强。如需要，则会把切面里的通知方法包装成增强器，然后再为业务逻辑组件创建一个代理对象。我们也认真仔细探究过了，在为业务逻辑组件创建代理对象的时候，使用的是cglib来创建动态代理的。当然了，如果业务逻辑类有实现接口，那么就使用jdk来创建动态代理。一旦这个代理对象创建出来了，那么它里面就会有所有的增强器。这个代理对象创建完以后，IOC容器也就创建完了。接下来，便要来执行目标方法了。</li></ol></li></ol></li><li><p>执行目标方法</p><ol><li>此时，其实是代理对象来执行目标方法</li><li>使用CglibAopProxy类的intercept()方法来拦截目标方法的执行，拦截的过程如下：<ol><li>得到目标方法的拦截器链，所谓的拦截器链其实就是每一个通知方法又被包装为了方法拦截器，即MethodInterceptor</li><li>利用拦截器的链式机制（责任链模式），依次进入每一个拦截器中进行执行</li><li>最终，整个的执行效果就会有两套：（据说Spring5中下面的拦截顺序有调整）<ul><li>目标方法正常执行：前置通知→目标方法→后置通知→返回通知</li><li>目标方法出现异常：前置通知→目标方法→后置通知→异常通知</li></ul></li></ol></li></ol></li></ol><h3 id="3-5-声明式事务"><a href="#3-5-声明式事务" class="headerlink" title="3.5 声明式事务"></a>3.5 声明式事务</h3><p><strong>添加c3p0数据源、MySQL数据库驱动以及spring-jdbc的依赖</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>c3p0<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>c3p0<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>0.9.1.2<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>mysql<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>mysql-connector-java<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>5.1.44<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-jdbc<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>4.3.12.RELEASE<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><p>引入spring-jdbc模块后就可以用Spring提供的JDBC模板（即JdbcTemplate）来操作数据库，从而简化对数据库的操作以及事务控制。</p><p><strong>配置类bean注册</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@EnableTransactionManagement</span> <span class="hljs-comment">// 开启基于注解的事务管理功能的</span><br><span class="hljs-meta">@ComponentScan(&quot;com.meimeixia.tx&quot;)</span><br><span class="hljs-meta">@Configuration</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TxConfig</span> </span>&#123;<br><span class="hljs-meta">@Bean</span>  <span class="hljs-comment">// 注册c3p0数据源</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> DataSource <span class="hljs-title">dataSource</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>ComboPooledDataSource dataSource = <span class="hljs-keyword">new</span> ComboPooledDataSource();<br>dataSource.setUser(<span class="hljs-string">&quot;root&quot;</span>);<br>dataSource.setPassword(<span class="hljs-string">&quot;liayun&quot;</span>);<br>dataSource.setDriverClass(<span class="hljs-string">&quot;com.mysql.jdbc.Driver&quot;</span>);<br>dataSource.setJdbcUrl(<span class="hljs-string">&quot;jdbc:mysql://localhost:3306/test&quot;</span>);<br><span class="hljs-keyword">return</span> dataSource;<br>&#125;<br><br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> JdbcTemplate <span class="hljs-title">jdbcTemplate</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>        JdbcTemplate jdbcTemplate = <span class="hljs-keyword">new</span> JdbcTemplate(dataSource());<br>        <span class="hljs-keyword">return</span> jdbcTemplate;<br>    &#125;<br>    <br>    <span class="hljs-meta">@Bean</span>  <span class="hljs-comment">// 注册事务管理器</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> PlatformTransactionManager <span class="hljs-title">platformTransactionManager</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> DataSourceTransactionManager(dataSource());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>测试</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Repository</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserDao</span> </span>&#123;<br><span class="hljs-meta">@Autowired</span><br><span class="hljs-keyword">private</span> JdbcTemplate jdbcTemplate;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">insert</span><span class="hljs-params">()</span> </span>&#123;<br>String sql = <span class="hljs-string">&quot;insert into `tbl_user`(username, age) values(?, ?)&quot;</span>;<br>String username = UUID.randomUUID().toString().substring(<span class="hljs-number">0</span>, <span class="hljs-number">5</span>);<br>jdbcTemplate.update(sql, username, <span class="hljs-number">19</span>); <span class="hljs-comment">// 增删改都来调用这个方法</span><br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Service</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserService</span> </span>&#123;<br><span class="hljs-meta">@Autowired</span><br><span class="hljs-keyword">private</span> UserDao userDao;<br><br>    <span class="hljs-meta">@Transactional</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">insertUser</span><span class="hljs-params">()</span> </span>&#123;<br>        userDao.insert();<br>        <span class="hljs-comment">// otherDao.other(); // 该方法中的业务逻辑势必不会像现在这么简单，肯定还会调用其他dao的方法</span><br>        System.out.println(<span class="hljs-string">&quot;插入完成...&quot;</span>);<br>        <span class="hljs-keyword">int</span> i = <span class="hljs-number">10</span> / <span class="hljs-number">0</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>声明式事务的原理</strong></p><p>首先，使用AutoProxyRegistrar向Spring容器里面注册一个后置处理器，这个后置处理器会负责给我们包装代理对象。然后，使用ProxyTransactionManagementConfiguration（配置类）再向Spring容器里面注册一个事务增强器，此时，需要用到事务拦截器。最后，代理对象执行目标方法，在这一过程中，便会执行到当前Spring容器里面的拦截器链，而且每次在执行目标方法时，如果出现了异常，那么便会利用事务管理器进行回滚事务，如果执行过程中一切正常，那么则会利用事务管理器提交事务。</p><p><strong>分析细节：<a href="https://liayun.blog.csdn.net/article/details/111872692">Spring注解驱动开发第35讲——声明式事务原理的源码分析</a></strong> </p><h3 id="3-6-BeanFactoryPostProcessor"><a href="#3-6-BeanFactoryPostProcessor" class="headerlink" title="3.6 BeanFactoryPostProcessor"></a>3.6 BeanFactoryPostProcessor</h3><p>与bean实例的后置处理器BeanPostProcessor相似，BeanFactoryPostProcessor是BeanFactory（创建bean的工厂）的后置处理器。</p><p>BeanFactoryPostProcessor是Spring提供的一个增强点，该增强点的增强时机是<strong>“在BeanFactory标准初始化之后，所有的beanDefinition已经保存加载到BeanFactory中，但是bean的实例还未被创建，可以来定制和修改BeanFactory里面的一些内容”</strong>。</p><p>可以通过实现<code>BeanFactoryPostProcessor</code>接口来自定义自己的bean工厂后置处理器。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyBeanFactoryPostProcessor</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">BeanFactoryPostProcessor</span> </span>&#123;<br><br><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">postProcessBeanFactory</span><span class="hljs-params">(ConfigurableListableBeanFactory beanFactory)</span> <span class="hljs-keyword">throws</span> BeansException </span>&#123;<br>System.out.println(<span class="hljs-string">&quot;MyBeanFactoryPostProcessor...postProcessBeanFactory...&quot;</span>); <span class="hljs-comment">// 这个时候我们所有的bean还没被创建</span><br>                                                                              <span class="hljs-comment">// 但是我们可以看一下通过Spring给我们传过来的这个beanFactory，我们能拿到什么</span><br><span class="hljs-keyword">int</span> count = beanFactory.getBeanDefinitionCount(); <span class="hljs-comment">// 我们能拿到有几个bean定义</span><br>String[] names = beanFactory.getBeanDefinitionNames(); <span class="hljs-comment">// 除此之外，我们还能拿到每一个bean定义的名字</span><br>System.out.println(<span class="hljs-string">&quot;当前BeanFactory中有&quot;</span> + count + <span class="hljs-string">&quot;个Bean&quot;</span>);<br>System.out.println(Arrays.asList(names));<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>分析细节：<a href="https://liayun.blog.csdn.net/article/details/113103870">Spring注解驱动开发第36讲——从源码角度理解BeanFactoryPostProcessor的原理</a></strong> </p><h3 id="3-7-BeanDefinitionRegistryPostProcessor"><a href="#3-7-BeanDefinitionRegistryPostProcessor" class="headerlink" title="3.7 BeanDefinitionRegistryPostProcessor"></a>3.7 BeanDefinitionRegistryPostProcessor</h3><p><code>BeanDefinitionRegistryPostProcessor</code>是<code>BeanFactoryPostProcessor</code>的子接口，同样也是Spring提供的一个增强点。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">BeanDefinitionRegistryPostProcessor</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">BeanFactoryPostProcessor</span></span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">postProcessBeanDefinitionRegistry</span><span class="hljs-params">(BeanDefinitionRegistry registry)</span> <span class="hljs-keyword">throws</span> BeansException</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>BeanDefinitionRegistryPostProcessor的切入时机是在所有bean定义信息将要被加载，但是bean实例还未创建的时候</strong>。</p><p>即：BeanDefinitionRegistryPostProcessor ➡️ 加载beanDefinition ➡️ BeanFactoryPostProcessor</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyBeanDefinitionRegistryPostProcessor</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">BeanDefinitionRegistryPostProcessor</span> </span>&#123;<br><br><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">postProcessBeanFactory</span><span class="hljs-params">(ConfigurableListableBeanFactory beanFactory)</span> <span class="hljs-keyword">throws</span> BeansException </span>&#123;<br>System.out.println(<span class="hljs-string">&quot;MyBeanDefinitionRegistryPostProcessor...bean的数量：&quot;</span> + beanFactory.getBeanDefinitionCount());<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 这个BeanDefinitionRegistry就是Bean定义的保存中心，这个注册中心里面存储了所有的bean定义信息</span><br><span class="hljs-comment"> * BeanFactory就是按照BeanDefinitionRegistry里面保存的每一个bean定义信息来创建bean实例</span><br><span class="hljs-comment"> * bean定义信息包括有：这个bean是单例的还是多例的、bean的类型是什么以及bean的id是什么。</span><br><span class="hljs-comment"> * 也就是说，这些信息都是存在BeanDefinitionRegistry里面的。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">postProcessBeanDefinitionRegistry</span><span class="hljs-params">(BeanDefinitionRegistry registry)</span> <span class="hljs-keyword">throws</span> BeansException </span>&#123;<br><span class="hljs-comment">// TODO Auto-generated method stub</span><br>System.out.println(<span class="hljs-string">&quot;postProcessBeanDefinitionRegistry...bean的数量：&quot;</span> + registry.getBeanDefinitionCount());<br><span class="hljs-comment">// 除了查看bean的数量之外，我们还可以给容器里面注册一些bean，我们以前也简单地用过</span><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * 第一个参数：我们将要给容器中注册的bean的名字</span><br><span class="hljs-comment"> * 第二个参数：BeanDefinition对象</span><br><span class="hljs-comment"> */</span><br><span class="hljs-comment">// RootBeanDefinition beanDefinition = new RootBeanDefinition(Blue.class); // 现在我准备给容器中添加一个Blue对象</span><br><span class="hljs-comment">// 咱们也可以用另外一种办法，即使用BeanDefinitionBuilder这个构建器生成一个BeanDefinition对象，很显然，这两种方法的效果都是一样的</span><br>AbstractBeanDefinition beanDefinition = BeanDefinitionBuilder.rootBeanDefinition(Blue.class).getBeanDefinition();<br>registry.registerBeanDefinition(<span class="hljs-string">&quot;hello&quot;</span>, beanDefinition);<br>&#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><p><strong>BeanDefinitionRegistryPostProcessor组件执行原理小结</strong></p><ol><li>创建IOC容器</li><li>创建IOC容器时，要调用一个刷新方法，即refresh方法</li><li>从IOC容器中获取到所有的BeanDefinitionRegistryPostProcessor组件，并依次触发它们的postProcessBeanDefinitionRegistry方法，然后再来触发它们的postProcessBeanFactory方法</li><li>再来从IOC容器中获取到所有的BeanFactoryPostProcessor组件，并依次触发它们的postProcessBeanFactory方法</li></ol><p><strong>分析细节：<a href="https://liayun.blog.csdn.net/article/details/113781809">Spring注解驱动开发第37讲——BeanDefinitionRegistryPostProcessor执行原理</a></strong> </p><h3 id="3-8-ApplicationListener"><a href="#3-8-ApplicationListener" class="headerlink" title="3.8 ApplicationListener"></a>3.8 ApplicationListener</h3><p>ApplicationListener是Spring提供的基于观察者模式实现的应用监听器。当有指定的事件发生时，就会触发对应的监听器，执行onApplicationEvent方法。该接口中带的泛型就是我们要监听的事件。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">ApplicationListener</span> &lt;<span class="hljs-title">E</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">ApplicationEvent</span>&gt; <span class="hljs-keyword">extends</span> <span class="hljs-title">EventListener</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">onApplicationEvent</span><span class="hljs-params">(E e)</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>案例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyApplicationListener</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">ApplicationListener</span>&lt;<span class="hljs-title">ApplicationEvent</span>&gt; </span>&#123;<br><br><span class="hljs-comment">// 当容器中发布此事件以后，下面这个方法就会被触发</span><br><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onApplicationEvent</span><span class="hljs-params">(ApplicationEvent event)</span> </span>&#123;<br>System.out.println(<span class="hljs-string">&quot;收到事件：&quot;</span> + event);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>Spring默认的四个事件：</strong></p><ul><li>ContextClosedEvent  容器关闭事件</li><li>ContextRefreshedEvent  容器刷新事件</li><li>ContextStartedEvent  容器开始事件</li><li>ContextStoppedEvent  容器停止事件</li></ul><p><strong>发布自定义事件</strong></p><ol><li>写一个监听器来监听某个事件。当然了，监听的这个事件必须是ApplicationEvent及其子类。</li><li>把监听器加入到容器中，这样Spring才能知道有这样一个监听器。</li><li>只要容器中有相关事件发布，那么我们就能监听到这个事件。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">IOCTest_Ext</span> </span>&#123;<br><br><span class="hljs-meta">@Test</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span> </span>&#123;<br>AnnotationConfigApplicationContext applicationContext = <span class="hljs-keyword">new</span> AnnotationConfigApplicationContext(ExtConfig.class);  <span class="hljs-comment">// 触发容器开始事件</span><br><br>        applicationContext.publishEvent(<span class="hljs-keyword">new</span> ApplicationEvent(<span class="hljs-keyword">new</span> String(<span class="hljs-string">&quot;diy事件&quot;</span>)));<br>        <br>applicationContext.close();  <span class="hljs-comment">// 触发容器关闭事件</span><br>&#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><p><strong>事件监听机制原理</strong></p><ol><li>IOC容器启动过程中，通过在refresh()方法中调用registerListeners()方法，将所有的监听器注册到事件派发器中去</li><li>事件发布时，首先获取到事件派发器，遍历所有监听器，向所有符合条件的监听器派发事件</li><li>监听器获取到事件后执行onApplicationEvent方法</li></ol><h3 id="3-9-EventListener"><a href="#3-9-EventListener" class="headerlink" title="3.9 @EventListener"></a>3.9 @EventListener</h3><p>除了通过实现ApplicationListener接口完成事件监听以外，还可以通过使用@EventListener注解，让任意方法都能监听事件。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Service</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserService</span> </span>&#123;<br><br>    <span class="hljs-comment">// @EventListener(classes=ApplicationEvent.class)</span><br>    <span class="hljs-meta">@EventListener(classes=&#123;ApplicationEvent.class&#125;)</span>  <span class="hljs-comment">// 可以指定监听多个事件</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">listen</span><span class="hljs-params">()</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;UserService...监听到的事件：&quot;</span> + event);<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><p><strong>@EventListener注解原理</strong></p><p>Spring会使用EventListenerMethodProcessor这个处理器来解析方法上的@EventListener注解。</p><p>EventListenerMethodProcessor实现了一个接口，叫SmartInitializingSingleton，这个接口有一个afterSingletonsInstantiated方法，该方法是在所有的单实例bean已经全部被创建完以后才会被执行。</p><p>在创建好所有的单实例bean后，判断每一个bean对象是否是SmartInitializingSingleton这个接口类型的，如果是，那么便调用它里面的afterSingletonsInstantiated方法，而该方法就是SmartInitializingSingleton接口中定义的方法。</p><h2 id="4-完整生命周期小结"><a href="#4-完整生命周期小结" class="headerlink" title="4 完整生命周期小结"></a>4 完整生命周期小结</h2><p><strong>1、prepareRefresh();  刷新前的预处理</strong></p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><span class="hljs-bullet">1.</span> initPropertySources()初始化一些属性设置;子类自定义个性化的属性设置方法；<br><span class="hljs-bullet">2.</span> getEnvironment().validateRequiredProperties();检验属性的合法等<br><span class="hljs-bullet">3.</span> earlyApplicationEvents= new LinkedHashSet<span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">ApplicationEvent</span>&gt;</span></span>(); 保存容器中的一些早期的事件<br></code></pre></td></tr></table></figure><p><strong>2、obtainFreshBeanFactory();  获取BeanFactory</strong></p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><span class="hljs-bullet">1.</span> refreshBeanFactory();刷新【创建】BeanFactory；<br><span class="hljs-bullet">-</span> 创建了一个this.beanFactory = new DefaultListableBeanFactory();<br><span class="hljs-bullet">-</span> 设置id；<br><span class="hljs-bullet">2.</span> getBeanFactory();返回刚才GenericApplicationContext创建的BeanFactory对象；<br><span class="hljs-bullet">3.</span> 将创建的BeanFactory【DefaultListableBeanFactory】返回；<br></code></pre></td></tr></table></figure><p><strong>3、prepareBeanFactory(beanFactory);  BeanFactory的预准备工作（BeanFactory进行一些设置）</strong></p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><span class="hljs-bullet">1.</span> 设置BeanFactory的类加载器、支持表达式解析器...2. 添加部分BeanPostProcessor【ApplicationContextAwareProcessor】3. 设置忽略的自动装配的接口EnvironmentAware、EmbeddedValueResolverAware、xxx；4. 注册可以解析的自动装配；我们能直接在任何组件中自动注入：- BeanFactory、ResourceLoader、ApplicationEventPublisher、ApplicationContext5. 添加BeanPostProcessor【ApplicationListenerDetector】6. 添加编译时的AspectJ；7. 给BeanFactory中注册一些能用的组件；    - environment【ConfigurableEnvironment】、    - systemProperties【Map<span class="xml">&lt;String, Object&gt;</span>】、    - systemEnvironment【Map<span class="xml">&lt;String, Object&gt;</span>】<br></code></pre></td></tr></table></figure><p><strong>4、postProcessBeanFactory(beanFactory);  BeanFactory准备工作完成后进行的后置处理工作</strong></p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><span class="hljs-bullet">-</span> 子类通过重写这个方法来在BeanFactory创建并预准备完成以后做进一步的设置<br></code></pre></td></tr></table></figure><p>==以上是BeanFactory的创建及预准备工作==</p><p><strong>5、invokeBeanFactoryPostProcessors(beanFactory);  执行BeanFactoryPostProcessor的方法</strong></p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs markdown">BeanFactoryPostProcessor：BeanFactory的后置处理器。在BeanFactory标准初始化之后执行的；<br>两个接口：BeanFactoryPostProcessor、BeanDefinitionRegistryPostProcessor<br><span class="hljs-bullet">1.</span> 先执行BeanDefinitionRegistryPostProcessor<br><span class="hljs-bullet">    -</span> 获取所有的BeanDefinitionRegistryPostProcessor；<br><span class="hljs-bullet">    -</span> 看先执行实现了PriorityOrdered优先级接口的BeanDefinitionRegistryPostProcessor、<br><span class="hljs-code">    postProcessor.postProcessBeanDefinitionRegistry(registry)</span><br><span class="hljs-code">    - 在执行实现了Ordered顺序接口的BeanDefinitionRegistryPostProcessor；</span><br><span class="hljs-code">    postProcessor.postProcessBeanDefinitionRegistry(registry)</span><br><span class="hljs-code">    - 最后执行没有实现任何优先级或者是顺序接口的BeanDefinitionRegistryPostProcessors；</span><br><span class="hljs-code">    postProcessor.postProcessBeanDefinitionRegistry(registry)</span><br><span class="hljs-code">2. 加载BeanDefinition</span><br><span class="hljs-code">3. 再执行BeanFactoryPostProcessor的方法</span><br><span class="hljs-code">- 获取所有的BeanFactoryPostProcessor</span><br><span class="hljs-code">    - 看先执行实现了PriorityOrdered优先级接口的BeanFactoryPostProcessor、</span><br><span class="hljs-code">postProcessor.postProcessBeanFactory()</span><br><span class="hljs-code">- 在执行实现了Ordered顺序接口的BeanFactoryPostProcessor；</span><br><span class="hljs-code">postProcessor.postProcessBeanFactory()</span><br><span class="hljs-code">- 最后执行没有实现任何优先级或者是顺序接口的BeanFactoryPostProcessor；</span><br><span class="hljs-code">postProcessor.postProcessBeanFactory()</span><br></code></pre></td></tr></table></figure><p><strong>6、registerBeanPostProcessors(beanFactory);  注册BeanPostProcessor(Bean的后置处理器)【 intercept bean creation】</strong></p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><span class="hljs-bullet">-</span> 不同接口类型的BeanPostProcessor；在Bean创建前后的执行时机是不一样的<br><span class="hljs-bullet">    -</span> BeanPostProcessor、<br><span class="hljs-bullet">    -</span> DestructionAwareBeanPostProcessor、<br><span class="hljs-bullet">    -</span> InstantiationAwareBeanPostProcessor、<br><span class="hljs-bullet">    -</span> SmartInstantiationAwareBeanPostProcessor、<br><span class="hljs-bullet">    -</span> MergedBeanDefinitionPostProcessor【internalPostProcessors】、<br><span class="hljs-code"></span><br><span class="hljs-code">1. 获取所有的 BeanPostProcessor;后置处理器都默认可以通过PriorityOrdered、Ordered接口来执行优先级</span><br><span class="hljs-code">2. 先注册PriorityOrdered优先级接口的BeanPostProcessor；</span><br><span class="hljs-code">把每一个BeanPostProcessor；添加到BeanFactory中</span><br><span class="hljs-code">    beanFactory.addBeanPostProcessor(postProcessor);</span><br><span class="hljs-code">3. 再注册Ordered接口的</span><br><span class="hljs-code">4. 最后注册没有实现任何优先级接口的</span><br><span class="hljs-code">5. 最终注册MergedBeanDefinitionPostProcessor；</span><br><span class="hljs-code">6. 注册一个ApplicationListenerDetector；来在Bean创建完成后检查是否是ApplicationListener，如果是，applicationContext.addApplicationListener((ApplicationListener&lt;?&gt;) bean);</span><br></code></pre></td></tr></table></figure><p><strong>7、initMessageSource();  初始化MessageSource组件(做国际化功能；消息绑定，消息解析)</strong></p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><span class="hljs-bullet">1.</span> 获取BeanFactory<br><span class="hljs-bullet">2.</span> 看容器中是否有id为messageSource的，类型是MessageSource的组件<br><span class="hljs-bullet">-</span> 如果有赋值给messageSource，如果没有自己创建一个DelegatingMessageSource；<br><span class="hljs-bullet">-</span> MessageSource：取出国际化配置文件中的某个key的值；能按照区域信息获取；<br><span class="hljs-bullet">3.</span> 把创建好的MessageSource注册在容器中，以后获取国际化配置文件的值的时候，可以自动注入MessageSource；<br><span class="hljs-bullet">-</span> beanFactory.registerSingleton(MESSAGE<span class="hljs-emphasis">_SOURCE_</span>BEAN<span class="hljs-emphasis">_NAME, this.messageSource);</span><br><span class="hljs-emphasis">- MessageSource.getMessage(String code, Object[] args, String defaultMessage, Locale locale);</span><br></code></pre></td></tr></table></figure><p><strong>8、initApplicationEventMulticaster();  初始化事件派发器</strong></p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><span class="hljs-bullet">1.</span> 获取BeanFactory<br><span class="hljs-bullet">2.</span> 从BeanFactory中获取applicationEventMulticaster的ApplicationEventMulticaster；<br><span class="hljs-bullet">3.</span> 如果上一步没有配置；创建一个SimpleApplicationEventMulticaster<br><span class="hljs-bullet">4.</span> 将创建的ApplicationEventMulticaster添加到BeanFactory中，以后其他组件直接自动注入<br></code></pre></td></tr></table></figure><p><strong>9、onRefresh();  留给子容器（子类）</strong></p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><span class="hljs-bullet">-</span> 子类重写这个方法，在容器刷新的时候可以自定义逻辑；<br></code></pre></td></tr></table></figure><p><strong>10、registerListeners();  从容器中将所有项目里面的ApplicationListener注册到事件派发器</strong></p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><span class="hljs-bullet">1.</span> 从容器中拿到所有的ApplicationListener<br><span class="hljs-bullet">2.</span> 将每个监听器添加到事件派发器中；<br><span class="hljs-bullet">-</span> getApplicationEventMulticaster().addApplicationListenerBean(listenerBeanName);<br><span class="hljs-bullet">3.</span> 派发之前步骤产生的事件；<br></code></pre></td></tr></table></figure><p><strong>11、finishBeanFactoryInitialization(beanFactory);  初始化所有剩下的单实例bean</strong></p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs markdown">beanFactory.preInstantiateSingletons();  初始化后剩下的单实例bean<br><span class="hljs-bullet">1.</span> 获取容器中的所有Bean，依次进行初始化和创建对象<br><span class="hljs-bullet">2.</span> 获取Bean的定义信息；RootBeanDefinition<br><span class="hljs-bullet">3.</span> Bean不是抽象的，是单实例的，不是懒加载；<br><span class="hljs-code">1）、判断是否是FactoryBean；是否是实现FactoryBean接口的Bean；</span><br><span class="hljs-code">2）、不是工厂Bean。利用getBean(beanName);创建对象</span><br><span class="hljs-code">0、getBean(beanName)； ioc.getBean();</span><br><span class="hljs-code">1、doGetBean(name, null, null, false);</span><br><span class="hljs-code">2、先获取缓存中保存的单实例Bean。如果能获取到说明这个Bean之前被创建过（所有创建过的单实例Bean都会被缓存起来）</span><br><span class="hljs-code">从private final Map&lt;String, Object&gt; singletonObjects = new ConcurrentHashMap&lt;String, Object&gt;(256);获取的</span><br><span class="hljs-code">3、缓存中获取不到，开始Bean的创建对象流程；</span><br><span class="hljs-code">4、标记当前bean已经被创建</span><br><span class="hljs-code">5、获取Bean的定义信息；</span><br><span class="hljs-code">6、【获取当前Bean依赖的其他Bean;如果有按照getBean()把依赖的Bean先创建出来；】</span><br><span class="hljs-code">7、启动单实例Bean的创建流程；</span><br><span class="hljs-code">1）、createBean(beanName, mbd, args);</span><br><span class="hljs-code">2）、Object bean = resolveBeforeInstantiation(beanName, mbdToUse);让BeanPostProcessor先拦截返回代理对象；</span><br><span class="hljs-code">【InstantiationAwareBeanPostProcessor】：提前执行；</span><br><span class="hljs-code">先触发：postProcessBeforeInstantiation()；</span><br><span class="hljs-code">如果有返回值：触发postProcessAfterInitialization()；</span><br><span class="hljs-code">3）、如果前面的InstantiationAwareBeanPostProcessor没有返回代理对象；调用4）</span><br><span class="hljs-code">4）、Object beanInstance = doCreateBean(beanName, mbdToUse, args);创建Bean</span><br><span class="hljs-code"> 1）、【创建Bean实例】；createBeanInstance(beanName, mbd, args);</span><br><span class="hljs-code"> 利用工厂方法或者对象的构造器创建出Bean实例；</span><br><span class="hljs-code"> 2）、applyMergedBeanDefinitionPostProcessors(mbd, beanType, beanName);</span><br><span class="hljs-code"> 调用MergedBeanDefinitionPostProcessor的postProcessMergedBeanDefinition(mbd, beanType, beanName);</span><br><span class="hljs-code"> 3）、【Bean属性赋值】populateBean(beanName, mbd, instanceWrapper);</span><br><span class="hljs-code"> 赋值之前：</span><br><span class="hljs-code"> 1）、拿到InstantiationAwareBeanPostProcessor后置处理器；</span><br><span class="hljs-code"> postProcessAfterInstantiation()；</span><br><span class="hljs-code"> 2）、拿到InstantiationAwareBeanPostProcessor后置处理器；</span><br><span class="hljs-code"> postProcessPropertyValues()；</span><br><span class="hljs-code"> =====赋值之前：=====</span><br><span class="hljs-code"> 3）、应用Bean属性的值；为属性利用setter方法等进行赋值；</span><br><span class="hljs-code"> applyPropertyValues(beanName, mbd, bw, pvs);</span><br><span class="hljs-code"> 4）、【Bean初始化】initializeBean(beanName, exposedObject, mbd);</span><br><span class="hljs-code"> 1）、【执行Aware接口方法】invokeAwareMethods(beanName, bean);执行xxxAware接口的方法</span><br><span class="hljs-code"> BeanNameAware\BeanClassLoaderAware\BeanFactoryAware</span><br><span class="hljs-code"> 2）、【执行后置处理器初始化之前】applyBeanPostProcessorsBeforeInitialization(wrappedBean, beanName);</span><br><span class="hljs-code"> BeanPostProcessor.postProcessBeforeInitialization（）;</span><br><span class="hljs-code"> 3）、【执行初始化方法】invokeInitMethods(beanName, wrappedBean, mbd);</span><br><span class="hljs-code"> 1）、是否是InitializingBean接口的实现；执行接口规定的初始化；</span><br><span class="hljs-code"> 2）、是否自定义初始化方法；</span><br><span class="hljs-code"> 4）、【执行后置处理器初始化之后】applyBeanPostProcessorsAfterInitialization</span><br><span class="hljs-code"> BeanPostProcessor.postProcessAfterInitialization()；</span><br><span class="hljs-code"> 5）、注册Bean的销毁方法；</span><br><span class="hljs-code">5）、将创建的Bean添加到缓存中singletonObjects；</span><br><span class="hljs-code">ioc容器就是这些Map；很多的Map里面保存了单实例Bean，环境信息。。。。；</span><br><span class="hljs-code"></span><br>所有Bean都利用getBean创建完成以后；<br><span class="hljs-bullet">1.</span> 检查所有的Bean是否是SmartInitializingSingleton接口的；如果是；就执行afterSingletonsInstantiated();<br></code></pre></td></tr></table></figure><p><strong>12、finishRefresh();  完成BeanFactory的初始化创建工作、IOC容器就创建完成</strong></p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><span class="hljs-bullet">1.</span> initLifecycleProcessor();初始化和生命周期有关的后置处理器；LifecycleProcessor<br><span class="hljs-bullet">-</span> 默认从容器中找是否有lifecycleProcessor的组件【LifecycleProcessor】；如果没有，new DefaultLifecycleProcessor();<br><span class="hljs-bullet">-</span> 加入到容器；<br><span class="hljs-bullet">-</span> 写一个LifecycleProcessor的实现类，可以在BeanFactory<br><span class="hljs-bullet">-</span> void onRefresh();<br><span class="hljs-bullet">-</span> void onClose();<br><span class="hljs-bullet">2.</span> getLifecycleProcessor().onRefresh();<br><span class="hljs-bullet">-</span> 拿到前面定义的生命周期处理器（BeanFactory）；回调onRefresh()；<br><span class="hljs-bullet">3.</span> publishEvent(new ContextRefreshedEvent(this));发布容器刷新完成事件；<br><span class="hljs-bullet">4.</span> liveBeansView.registerApplicationContext(this);<br></code></pre></td></tr></table></figure><p><img src="/images/Spring%E6%B3%A8%E8%A7%A3%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0.assets/image-20210409173738495.png" alt="image-20210409173738495"></p><p><strong>总结：</strong></p><ol><li>Spring容器在启动的时候，先会保存所有注册进来的Bean的定义信息；<ul><li>xml注册bean；<code>&lt;bean&gt;</code></li><li>注解注册Bean；@Service、@Component、@Bean、xxx</li></ul></li><li>Spring容器会合适的时机创建这些Bean<ul><li>用到这个bean的时候；利用getBean创建bean；创建好以后保存在容器中；</li><li>统一创建剩下所有的bean的时候；finishBeanFactoryInitialization()；</li></ul></li><li>后置处理器；BeanPostProcessor<ul><li>每一个bean创建完成，都会使用各种后置处理器进行处理；来增强bean的功能；<ul><li>AutowiredAnnotationBeanPostProcessor:处理自动注入</li><li>AnnotationAwareAspectJAutoProxyCreator:来做AOP功能；</li><li>…</li></ul></li><li>增强的功能注解：<ul><li>AsyncAnnotationBeanPostProcessor</li><li>…</li></ul></li></ul></li><li>事件驱动模型；<ul><li>ApplicationListener；事件监听；</li><li>ApplicationEventMulticaster；事件派发：</li></ul></li></ol>]]></content>
    
    
    <categories>
      
      <category>java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>spring</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CMake笔记</title>
    <link href="/2021/10/02/CMake%E7%AC%94%E8%AE%B0/"/>
    <url>/2021/10/02/CMake%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h2 id="CMake"><a href="#CMake" class="headerlink" title="CMake"></a>CMake</h2><p><strong>以下内容大部分出自：<a href="https://mp.weixin.qq.com/s?__biz=MzIwMjU3NDI5Ng==&mid=2247484014&idx=1&sn=6a004394e0ba98e19f4b0c620d1b8c13&scene=19#wechat_redirect">基于VSCode和CMake进行C/C++开发「第六讲」CMake</a></strong> </p><p><strong>前言</strong>：</p><ul><li><strong>CMake</strong>是一个<strong>跨平台</strong>的安装<strong>编译工具</strong>，可以用<strong>简单</strong>的语句来描述<strong>所有平台</strong>的安装(编译过程)。</li><li>CMake可以说已经成为<strong>大部分C++开源项目标配</strong></li></ul><!-- more --><h3 id="Cross-platform-development"><a href="#Cross-platform-development" class="headerlink" title="Cross-platform development"></a>Cross-platform development</h3><p>Let’s assume you have some cross-platform project with C++ code shared along different platforms/IDEs. Say you use <code>Visual Studio</code> on Windows, <code>Xcode</code> on OSX and <code>Makefile</code> for Linux:</p><p><img src="/images/C++%E5%9F%BA%E7%A1%80.assets/image-20210627162600154.png"></p><p>What you will do if you want to add new <code>bar.cpp</code> source file? You have to add it to every tool you use:</p><p><img src="/images/C++%E5%9F%BA%E7%A1%80.assets/image-20210627162621215.png"></p><p>To keep the environment consistent you have to do the similar update several times. And the most important thing is that you have to do it <strong>manually</strong> (arrow marked with a red color on the diagram in this case). Of course such approach is error prone and not flexible.</p><p>CMake solve this design flaw by adding extra step to development process. You can describe your project in <code>CMakeLists.txt</code> file and use CMake to generate tools you currently interested in using cross-platform CMake code:</p><p><img src="/images/C++%E5%9F%BA%E7%A1%80.assets/image-20210627162641617.png"></p><p>Same action - adding new <code>bar.cpp</code> file, will be done in <strong>one step</strong> now:</p><p><img src="/images/C++%E5%9F%BA%E7%A1%80.assets/image-20210627162712443.png"></p><p>Note that the bottom part of the diagram <strong>was not changed</strong>. I.e. you still can keep using your favorite tools like <code>Visual Studio/msbuild</code>, <code>Xcode/xcodebuild</code> and <code>Makefile/make</code>!</p><h3 id="语法特性介绍"><a href="#语法特性介绍" class="headerlink" title="语法特性介绍"></a>语法特性介绍</h3><ul><li><p><strong>基本语法格式：指令(参数 1 参数 2…)</strong></p></li><li><ul><li>参数使用<strong>括弧</strong>括起</li><li>参数之间使用<strong>空格</strong>或<strong>分号</strong>分开</li></ul></li><li><p><strong>指令是大小写无关的，参数和变量是大小写相关的</strong></p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cmake"><span class="hljs-keyword">set</span>(HELLO hello.cpp)<br><span class="hljs-keyword">add_executable</span>(hello main.cpp hello.cpp)<br><span class="hljs-keyword">ADD_EXECUTABLE</span>(hello main.cpp <span class="hljs-variable">$&#123;HELLO&#125;</span>)<br></code></pre></td></tr></table></figure></li><li><p><strong>变量使用${}方式取值，但是在 IF 控制语句中是直接使用变量名</strong></p></li></ul><h3 id="重要指令和CMake常用变量"><a href="#重要指令和CMake常用变量" class="headerlink" title="重要指令和CMake常用变量"></a>重要指令和CMake常用变量</h3><h4 id="重要指令"><a href="#重要指令" class="headerlink" title="重要指令"></a>重要指令</h4><ul><li><p><strong>cmake_minimum_required</strong> <strong>- 指定CMake的最小版本要求</strong></p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cmake"><span class="hljs-comment"># CMake最小版本要求为2.8.3</span><br><span class="hljs-keyword">cmake_minimum_required</span>(VERSION <span class="hljs-number">2.8</span>.<span class="hljs-number">3</span>)<br></code></pre></td></tr></table></figure></li><li><ul><li>语法：<strong>cmake_minimum_required(VERSION versionNumber [FATAL_ERROR])</strong></li></ul></li><li><p><strong>project</strong> <strong>- 定义工程名称，并可指定工程支持的语言</strong> </p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cmake"><span class="hljs-comment"># 指定工程名为HELLOWORLD</span><br><span class="hljs-keyword">project</span>(HELLOWORLD)<br></code></pre></td></tr></table></figure></li><li><ul><li>语法：<strong>project(projectname [CXX] [C] [Java])</strong></li></ul></li><li><p><strong>set</strong> <strong>- 显式的定义变量</strong> </p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cmake"><span class="hljs-comment"># 定义SRC变量，其值为sayhello.cpp hello.cpp</span><br><span class="hljs-keyword">set</span>(SRC sayhello.cpp hello.cpp)<br></code></pre></td></tr></table></figure></li><li><ul><li>语法：<strong>set(VAR [VALUE] [CACHE TYPE DOCSTRING [FORCE]])</strong></li></ul></li><li><p><strong>include_directories - 向工程添加多个特定的头文件搜索路径</strong> —&gt;相当于指定g++编译器的-I参数</p><p><a href="https://blog.csdn.net/weixin_39393741/article/details/85070299">include_directories和find_package</a> </p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cmake"><span class="hljs-comment"># 将/usr/include/myincludefolder 和 ./include 添加到头文件搜索路径</span><br><span class="hljs-keyword">include_directories</span>(/usr/<span class="hljs-keyword">include</span>/myincludefolder ./<span class="hljs-keyword">include</span>)<br></code></pre></td></tr></table></figure></li><li><ul><li>语法：<strong>include_directories([AFTER|BEFORE] [SYSTEM] dir1 dir2 …)</strong></li></ul></li><li><p><strong>link_directories</strong> <strong>- 向工程添加多个特定的库文件搜索路径</strong> —&gt;相当于指定g++编译器的-L参数</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cmake"><span class="hljs-comment"># 将/usr/lib/mylibfolder 和 ./lib 添加到库文件搜索路径</span><br><span class="hljs-keyword">link_directories</span>(/usr/lib/mylibfolder ./lib)<br></code></pre></td></tr></table></figure></li><li><ul><li>语法：link_directories(dir1 dir2 …) </li></ul></li><li><p><strong>add_library</strong> <strong>- 生成库文件</strong></p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cmake"><span class="hljs-comment"># 通过变量 SRC 生成 libhello.so 共享库</span><br><span class="hljs-keyword">add_library</span>(hello SHARED <span class="hljs-variable">$&#123;SRC&#125;</span>)<br></code></pre></td></tr></table></figure></li><li><ul><li>语法：<strong>add_library(libname [SHARED|STATIC|MODULE] [EXCLUDE_FROM_ALL] source1 source2 … sourceN)</strong></li></ul></li><li><p><strong>add_compile_options</strong> - 添加编译参数</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cmake"><span class="hljs-comment"># 添加编译参数 -Wall -std=c++11</span><br><span class="hljs-keyword">add_compile_options</span>(-Wall -std=c++<span class="hljs-number">11</span> -O2)<br></code></pre></td></tr></table></figure></li><li><ul><li>语法：<strong>add_compile_options(</strong></li></ul></li><li><p><strong>add_executable</strong> <strong>- 生成可执行文件</strong></p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cmake"><span class="hljs-comment"># 编译main.cpp生成可执行文件main</span><br><span class="hljs-keyword">add_executable</span>(main main.cpp)<br></code></pre></td></tr></table></figure></li><li><ul><li>语法：<strong>add_library(exename source1 source2 … sourceN)</strong></li></ul></li><li><p><strong>target_link_libraries</strong> - 为 target 添加需要链接的共享库  —&gt;相同于指定g++编译器-l参数</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cmake"><span class="hljs-comment"># 将hello动态库文件链接到可执行文件main</span><br><span class="hljs-keyword">target_link_libraries</span>(main hello)<br></code></pre></td></tr></table></figure></li><li><ul><li>语法：<strong>target_link_libraries(target library1library2…)</strong></li></ul></li><li><p><strong>add_subdirectory - 向当前工程添加存放源文件的子目录，并可以指定中间二进制和目标二进制存放的位置</strong></p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cmake"><span class="hljs-comment"># 添加src子目录，src中需有一个CMakeLists.txt</span><br><span class="hljs-keyword">add_subdirectory</span>(src)<br></code></pre></td></tr></table></figure></li><li><ul><li>语法：<strong>add_subdirectory(source_dir [binary_dir] [EXCLUDE_FROM_ALL])</strong></li></ul></li><li><p><strong>aux_source_directory - 发现一个目录下所有的源代码文件并将列表存储在一个变量中，这个指令临时被用来自动构建源文件列表</strong></p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cmake"><span class="hljs-comment"># 定义SRC变量，其值为当前目录下所有的源代码文件</span><br><span class="hljs-keyword">aux_source_directory</span>(. SRC)<br><span class="hljs-comment"># 编译SRC变量所代表的源代码文件，生成main可执行文件</span><br><span class="hljs-keyword">add_executable</span>(main <span class="hljs-variable">$&#123;SRC&#125;</span>)<br></code></pre></td></tr></table></figure></li><li><ul><li>语法：<strong>aux_source_directory(dir VARIABLE)</strong></li></ul></li></ul><h4 id="CMake常用变量"><a href="#CMake常用变量" class="headerlink" title="CMake常用变量"></a>CMake常用变量</h4><ul><li><p><strong>CMAKE_C_FLAGS  gcc编译选项</strong></p><p><strong>CMAKE_CXX_FLAGS  g++编译选项</strong></p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cmake"><span class="hljs-comment"># 在CMAKE_CXX_FLAGS编译选项后追加-std=c++11</span><br><span class="hljs-keyword">set</span>(CMAKE_CXX_FLAGS <span class="hljs-string">&quot;$&#123;CMAKE_CXX_FLAGS&#125; -std=c++11&quot;</span>)<br></code></pre></td></tr></table></figure><p><strong>CMAKE_BUILD_TYPE  编译类型(Debug, Release)</strong></p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cmake"><span class="hljs-comment"># 设定编译类型为debug，调试时需要选择debug</span><br><span class="hljs-keyword">set</span>(CMAKE_BUILD_TYPE Debug) <br><span class="hljs-comment"># 设定编译类型为release，发布时需要选择release</span><br><span class="hljs-keyword">set</span>(CMAKE_BUILD_TYPE Release) <br></code></pre></td></tr></table></figure><p><strong>CMAKE_BINARY_DIR</strong></p><p><strong>PROJECT_BINARY_DIR</strong></p><p><strong>&lt;projectname&gt;__BINARY_DIR</strong></p></li><li><ol><li>这三个变量指代的内容是一致的。</li><li>如果是 in source build，指的就是工程顶层目录。</li><li>如果是 out-of-source 编译,指的是工程编译发生的目录。</li><li>PROJECT_BINARY_DIR 跟其他指令稍有区别，不过现在，你可以理解为他们是一致的。</li></ol></li><li><p><strong>CMAKE_SOURCE_DIR</strong></p><p><strong>PROJECT_SOURCE_DIR</strong><br><strong>&lt;projectname&gt;__SOURCE_DIR</strong></p></li><li><ol><li>这三个变量指代的内容是一致的,不论采用何种编译方式,都是工程顶层目录。</li><li>也就是在 in source build时,他跟 CMAKE_BINARY_DIR 等变量一致。</li><li>PROJECT_SOURCE_DIR 跟其他指令稍有区别,现在,你可以理解为他们是一致的。（如果是在子cmake中含义会不同）</li></ol></li></ul><hr><ul><li><strong>CMAKE_C_COMPILER：指定C编译器</strong></li><li><strong>CMAKE_CXX_COMPILER：指定C++编译器</strong></li><li><strong>EXECUTABLE_OUTPUT_PATH：可执行文件输出的存放路径</strong></li><li><strong>LIBRARY_OUTPUT_PATH：库文件输出的存放路径</strong></li></ul><h3 id="CMake编译工程"><a href="#CMake编译工程" class="headerlink" title="CMake编译工程"></a>CMake编译工程</h3><p>CMake目录结构：项目主目录存在一个CMakeLists.txt文件</p><p><strong>两种方式设置编译规则</strong>：</p><ol><li>包含源文件的子文件夹包含CMakeLists.txt文件，主目录的CMakeLists.txt通过add_subdirectory添加子目录即可；</li><li>包含源文件的子文件夹未包含CMakeLists.txt文件，子目录编译规则体现在主目录的CMakeLists.txt中；</li></ol><h4 id="编译流程"><a href="#编译流程" class="headerlink" title="编译流程"></a>编译流程</h4><p><strong>在 linux 平台下使用 CMake 构建C/C++工程的流程如下:</strong></p><ul><li>手动编写 CmakeLists.txt。</li><li>执行命令 <code>cmake PATH</code>生成 Makefile ( PATH 是顶层CMakeLists.txt 所在的目录 )。</li><li>执行命令<code>make</code> 进行编译。</li></ul><hr><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cmake"><span class="hljs-comment"># important tips</span><br>.          <span class="hljs-comment"># 表示当前目录</span><br>./         <span class="hljs-comment"># 表示当前目录</span><br><br>..      <span class="hljs-comment"># 表示上级目录</span><br>../     <span class="hljs-comment"># 表示上级目录</span><br></code></pre></td></tr></table></figure><hr><h4 id="两种构建方式"><a href="#两种构建方式" class="headerlink" title="两种构建方式"></a>两种构建方式</h4><ul><li><p>**内部构建(in-source build)**：不推荐使用</p><p>内部构建会在同级目录下产生一大堆中间文件，这些中间文件并不是我们最终所需要的，和工程源文件放在一起会显得杂乱无章。</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cmake"><span class="hljs-comment">## 内部构建</span><br><br><span class="hljs-comment"># 在当前目录下，编译本目录的CMakeLists.txt，生成Makefile和其他文件</span><br>cmake .<br><span class="hljs-comment"># 执行make命令，生成target</span><br>make<br></code></pre></td></tr></table></figure></li><li><p>**外部构建(out-of-source build)**：==推荐使用==</p><p>将编译输出文件与源文件放到不同目录中</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cmake"><span class="hljs-comment">## 外部构建</span><br><br><span class="hljs-comment"># 1. 在当前目录下，创建build文件夹</span><br>mkdir build <br><span class="hljs-comment"># 2. 进入到build文件夹</span><br>cd build<br><span class="hljs-comment"># 3. 编译上级目录的CMakeLists.txt，生成Makefile和其他文件</span><br>cmake ..<br><span class="hljs-comment"># 4. 执行make命令，生成target</span><br>make<br></code></pre></td></tr></table></figure></li></ul><h3 id="【实战】CMake代码实践"><a href="#【实战】CMake代码实践" class="headerlink" title="【实战】CMake代码实践"></a>【实战】CMake代码实践</h3><p>针对第五章写的两个小项目来写对应的CMakeLists.txt</p><h4 id="最小CMake工程"><a href="#最小CMake工程" class="headerlink" title="最小CMake工程"></a>最小CMake工程</h4><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cmake"><span class="hljs-comment"># Set the minimum version of CMake that can be used</span><br><span class="hljs-keyword">cmake_minimum_required</span>(VERSION <span class="hljs-number">3.0</span>)<br><br><span class="hljs-comment"># Set the project name</span><br><span class="hljs-keyword">project</span> (HELLO)<br><br><span class="hljs-comment"># Add an executable</span><br><span class="hljs-keyword">add_executable</span>(hello_cmake main.cpp)<br></code></pre></td></tr></table></figure><h4 id="多目录工程-直接编译"><a href="#多目录工程-直接编译" class="headerlink" title="多目录工程 - 直接编译"></a>多目录工程 - 直接编译</h4><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs cmake"><span class="hljs-comment"># Set the minimum version of CMake that can be used</span><br><span class="hljs-keyword">cmake_minimum_required</span>(VERSION <span class="hljs-number">3.0</span>)<br><br><span class="hljs-comment">#project name</span><br><span class="hljs-keyword">project</span>(SWAP)<br><br><span class="hljs-comment">#head file pat</span><br><span class="hljs-keyword">include_directories</span>( <span class="hljs-keyword">include</span> )<br><br><span class="hljs-comment">#source directory files to var</span><br><span class="hljs-keyword">add_subdirectory</span>( src DIR_SRCS )<br><br><span class="hljs-comment">#add executable file  </span><br><span class="hljs-keyword">add_executable</span>(swap_02 <span class="hljs-variable">$&#123;TEST_MATH&#125;</span>)<br><br><span class="hljs-comment">#add link library  </span><br><span class="hljs-keyword">target_link_libraries</span>(<span class="hljs-variable">$&#123;FS_BUILD_BINARY_PREFIX&#125;</span>sqrt <span class="hljs-variable">$&#123;LIBRARIES&#125;</span>) <br></code></pre></td></tr></table></figure><h4 id="多目录工程-生成库编译"><a href="#多目录工程-生成库编译" class="headerlink" title="多目录工程 - 生成库编译"></a>多目录工程 - 生成库编译</h4><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs cmake"><span class="hljs-comment"># Set the minimum version of CMake that can be used</span><br><span class="hljs-keyword">cmake_minimum_required</span>(VERSION <span class="hljs-number">3.0</span>)<br><br><span class="hljs-comment">#project name  </span><br><span class="hljs-keyword">project</span>(SWAP_LIBRARY)<br><br><span class="hljs-comment">#add compile options</span><br><span class="hljs-keyword">add_compile_options</span>(<span class="hljs-string">&quot;-Wall -std=c++11&quot;</span>)<br><br><span class="hljs-comment">#set CMAKE_BUILD_TYPE</span><br><span class="hljs-keyword">set</span>( CMAKE_BUILD_TYPE Debug ) <br><br><span class="hljs-comment"># set output binary path  </span><br><span class="hljs-keyword">set</span>(EXECUTABLE_OUTPUT_PATH <span class="hljs-variable">$&#123;PROJECT_BINARY_DIR&#125;</span>/bin)<br><br><span class="hljs-comment">############################################################</span><br><span class="hljs-comment"># Create a library</span><br><span class="hljs-comment">############################################################</span><br><br><span class="hljs-comment">#Generate the static library from the library sources</span><br><span class="hljs-keyword">add_library</span>( swap_library STATIC src/Swap.cpp )<br><br><span class="hljs-keyword">target_include_directories</span>( swap_lib PUBLIC <span class="hljs-variable">$&#123;PROJECT_SOURCE_DIR&#125;</span>/<span class="hljs-keyword">include</span> )<br><br><span class="hljs-comment">############################################################</span><br><span class="hljs-comment"># Create an executable</span><br><span class="hljs-comment">############################################################</span><br><br><span class="hljs-comment"># Add an executable with the above sources</span><br><span class="hljs-keyword">add_executable</span>( swap_01 main.cpp )<br><br><span class="hljs-comment"># link the new swap_01 target with the swap_lib target</span><br><span class="hljs-keyword">target_link_libraries</span>( swap_01 swap_liby )<br></code></pre></td></tr></table></figure><h3 id="结合vscode和cmake的配置案例"><a href="#结合vscode和cmake的配置案例" class="headerlink" title="结合vscode和cmake的配置案例"></a>结合vscode和cmake的配置案例</h3><p><strong>核心思想：</strong></p><ul><li>所有可执行文件放到build目录下</li><li>所有源文件放到src目录下</li><li>单文件编译的配置按vscode默认的来</li><li>多文件编译的配置托管给cmake来处理（注意program标签和cmake输出文件一致）</li></ul><h4 id="对于单文件编译"><a href="#对于单文件编译" class="headerlink" title="对于单文件编译"></a>对于单文件编译</h4><p><code>tasks.json</code></p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs json">&#123;<br>    <span class="hljs-attr">&quot;version&quot;</span>: <span class="hljs-string">&quot;2.0.0&quot;</span>,<br>    <span class="hljs-attr">&quot;tasks&quot;</span>: [<br>        &#123;<br>            <span class="hljs-attr">&quot;type&quot;</span>: <span class="hljs-string">&quot;shell&quot;</span>,<br>            <span class="hljs-attr">&quot;label&quot;</span>: <span class="hljs-string">&quot;g++ build active file&quot;</span>,<br>            <span class="hljs-attr">&quot;command&quot;</span>: <span class="hljs-string">&quot;/usr/bin/g++&quot;</span>,<br>            <span class="hljs-attr">&quot;args&quot;</span>: [<br>                <span class="hljs-string">&quot;-g&quot;</span>,<br>                <span class="hljs-string">&quot;$&#123;file&#125;&quot;</span>,<br>                <span class="hljs-string">&quot;-o&quot;</span>,<br>                <span class="hljs-string">&quot;$&#123;fileDirname&#125;/build/$&#123;fileBasenameNoExtension&#125;&quot;</span><br>            ],<br>            <span class="hljs-attr">&quot;options&quot;</span>: &#123;<br>                <span class="hljs-attr">&quot;cwd&quot;</span>: <span class="hljs-string">&quot;/usr/bin&quot;</span><br>            &#125;,<br>            <span class="hljs-attr">&quot;problemMatcher&quot;</span>: [<br>                <span class="hljs-string">&quot;$gcc&quot;</span><br>            ],<br>            <span class="hljs-attr">&quot;group&quot;</span>: &#123;<br>                <span class="hljs-attr">&quot;kind&quot;</span>: <span class="hljs-string">&quot;build&quot;</span>,<br>                <span class="hljs-attr">&quot;isDefault&quot;</span>: <span class="hljs-literal">true</span><br>            &#125;<br>        &#125;<br>    ]<br>&#125;<br></code></pre></td></tr></table></figure><p><code>launch.json</code></p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs json">&#123;<br>    <span class="hljs-attr">&quot;version&quot;</span>: <span class="hljs-string">&quot;0.2.0&quot;</span>,<br>    <span class="hljs-attr">&quot;configurations&quot;</span>: [<br>        &#123;<br>            <span class="hljs-attr">&quot;name&quot;</span>: <span class="hljs-string">&quot;g++ build and debug active file&quot;</span>,<br>            <span class="hljs-attr">&quot;type&quot;</span>: <span class="hljs-string">&quot;cppdbg&quot;</span>,<br>            <span class="hljs-attr">&quot;request&quot;</span>: <span class="hljs-string">&quot;launch&quot;</span>,<br>            <span class="hljs-attr">&quot;program&quot;</span>: <span class="hljs-string">&quot;$&#123;fileDirname&#125;/build/$&#123;fileBasenameNoExtension&#125;&quot;</span>,<br>            <span class="hljs-attr">&quot;args&quot;</span>: [],<br>            <span class="hljs-attr">&quot;stopAtEntry&quot;</span>: <span class="hljs-literal">true</span>,<br>            <span class="hljs-attr">&quot;cwd&quot;</span>: <span class="hljs-string">&quot;$&#123;workspaceFolder&#125;&quot;</span>,<br>            <span class="hljs-attr">&quot;environment&quot;</span>: [],<br>            <span class="hljs-attr">&quot;externalConsole&quot;</span>: <span class="hljs-literal">false</span>,<br>            <span class="hljs-attr">&quot;MIMode&quot;</span>: <span class="hljs-string">&quot;gdb&quot;</span>,<br>            <span class="hljs-attr">&quot;setupCommands&quot;</span>: [<br>                &#123;<br>                    <span class="hljs-attr">&quot;description&quot;</span>: <span class="hljs-string">&quot;Enable pretty-printing for gdb&quot;</span>,<br>                    <span class="hljs-attr">&quot;text&quot;</span>: <span class="hljs-string">&quot;-enable-pretty-printing&quot;</span>,<br>                    <span class="hljs-attr">&quot;ignoreFailures&quot;</span>: <span class="hljs-literal">true</span><br>                &#125;<br>            ],<br>            <span class="hljs-attr">&quot;preLaunchTask&quot;</span>: <span class="hljs-string">&quot;g++ build active file&quot;</span>,<br>            <span class="hljs-attr">&quot;miDebuggerPath&quot;</span>: <span class="hljs-string">&quot;/usr/bin/gdb&quot;</span><br>        &#125;<br>    ]<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="对于多文件编译"><a href="#对于多文件编译" class="headerlink" title="对于多文件编译"></a>对于多文件编译</h4><p><code>tasks.json</code></p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs json">&#123;<br>    <span class="hljs-attr">&quot;version&quot;</span>: <span class="hljs-string">&quot;2.0.0&quot;</span>,<br>    <span class="hljs-attr">&quot;options&quot;</span>: &#123;<br>        <span class="hljs-attr">&quot;cwd&quot;</span>: <span class="hljs-string">&quot;$&#123;workspaceFolder&#125;/build&quot;</span><br>    &#125;,<br>    <span class="hljs-attr">&quot;tasks&quot;</span>: [<br>        &#123;<br>            <span class="hljs-attr">&quot;type&quot;</span>: <span class="hljs-string">&quot;shell&quot;</span>,<br>            <span class="hljs-attr">&quot;label&quot;</span>: <span class="hljs-string">&quot;cmake&quot;</span>,<br>            <span class="hljs-attr">&quot;command&quot;</span>: <span class="hljs-string">&quot;cmake&quot;</span>,<br>            <span class="hljs-attr">&quot;args&quot;</span>: [<br>                <span class="hljs-string">&quot;..&quot;</span><br>            ]<br>        &#125;,<br>        &#123;<br>            <span class="hljs-attr">&quot;type&quot;</span>: <span class="hljs-string">&quot;shell&quot;</span>,<br>            <span class="hljs-attr">&quot;label&quot;</span>: <span class="hljs-string">&quot;make&quot;</span>,<br>            <span class="hljs-attr">&quot;command&quot;</span>: <span class="hljs-string">&quot;make&quot;</span>,<br>            <span class="hljs-attr">&quot;args&quot;</span>: [<br><br>            ],<br>            <span class="hljs-attr">&quot;group&quot;</span>: &#123;<br>                <span class="hljs-attr">&quot;kind&quot;</span>: <span class="hljs-string">&quot;build&quot;</span>, <br>                <span class="hljs-attr">&quot;isDefault&quot;</span>: <span class="hljs-literal">true</span><br>            &#125;        <br>        &#125;,<br>        &#123;<br>            <span class="hljs-attr">&quot;label&quot;</span>: <span class="hljs-string">&quot;Build&quot;</span>,<br>            <span class="hljs-attr">&quot;dependsOrder&quot;</span>: <span class="hljs-string">&quot;sequence&quot;</span>,<br>            <span class="hljs-attr">&quot;dependsOn&quot;</span>: [<br>                <span class="hljs-string">&quot;cmake&quot;</span>,<br>                <span class="hljs-string">&quot;make&quot;</span><br>            ]<br>        &#125;<br>    ]<br>&#125;<br></code></pre></td></tr></table></figure><p><code>launch.json</code></p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs json">&#123;<br>    <span class="hljs-attr">&quot;version&quot;</span>: <span class="hljs-string">&quot;0.2.0&quot;</span>,<br>    <span class="hljs-attr">&quot;configurations&quot;</span>: [<br>        &#123;<br>            <span class="hljs-attr">&quot;name&quot;</span>: <span class="hljs-string">&quot;g++ build and debug active file&quot;</span>,<br>            <span class="hljs-attr">&quot;type&quot;</span>: <span class="hljs-string">&quot;cppdbg&quot;</span>,<br>            <span class="hljs-attr">&quot;request&quot;</span>: <span class="hljs-string">&quot;launch&quot;</span>,<br>            <span class="hljs-attr">&quot;program&quot;</span>: <span class="hljs-string">&quot;$&#123;fileDirname&#125;/build/main_cmake&quot;</span>,  <span class="hljs-comment">// 注意main_cmake应对应cmake的输出文件名</span><br>            <span class="hljs-attr">&quot;args&quot;</span>: [],<br>            <span class="hljs-attr">&quot;stopAtEntry&quot;</span>: <span class="hljs-literal">true</span>,<br>            <span class="hljs-attr">&quot;cwd&quot;</span>: <span class="hljs-string">&quot;$&#123;workspaceFolder&#125;&quot;</span>,<br>            <span class="hljs-attr">&quot;environment&quot;</span>: [],<br>            <span class="hljs-attr">&quot;externalConsole&quot;</span>: <span class="hljs-literal">false</span>,<br>            <span class="hljs-attr">&quot;MIMode&quot;</span>: <span class="hljs-string">&quot;gdb&quot;</span>,<br>            <span class="hljs-attr">&quot;setupCommands&quot;</span>: [<br>                &#123;<br>                    <span class="hljs-attr">&quot;description&quot;</span>: <span class="hljs-string">&quot;Enable pretty-printing for gdb&quot;</span>,<br>                    <span class="hljs-attr">&quot;text&quot;</span>: <span class="hljs-string">&quot;-enable-pretty-printing&quot;</span>,<br>                    <span class="hljs-attr">&quot;ignoreFailures&quot;</span>: <span class="hljs-literal">true</span><br>                &#125;<br>            ],<br>            <span class="hljs-attr">&quot;preLaunchTask&quot;</span>: <span class="hljs-string">&quot;Build&quot;</span>,<br>            <span class="hljs-attr">&quot;miDebuggerPath&quot;</span>: <span class="hljs-string">&quot;/usr/bin/gdb&quot;</span><br>        &#125;<br>    ]<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>cpp</category>
      
    </categories>
    
    
    <tags>
      
      <tag>project</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
